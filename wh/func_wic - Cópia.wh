 /*
Project      : gr5
Program      : func.wic
Function     : func_wic
Created on   : 31-May-2002   13:43:27
Descripition : programa que agregara todas as funcoes genericas do sistema.
Funções      : deleta_cips()
               sincroniza_pasta
               gerar_abas
               verifica_relacionamento
               montar_filhos
               ver_aba
               campo_autoinc

               19/02/2009 -> Eliana Cosme
               checa-tabela -> LITSCONSORTE - Verifica se há tabelas que a pasta filho tem lançamentos
                               e se pode excluir 

               17/2/2009 09:58:27 - Sonia Perdigão 
               XBP2 -> CONSISTÊNCIA PARA EXCLUSÃO DE ELEMENTOS DAS TABELAS OPERACIONAIS
               LOADCBOXORDER_BUILD -> ORDENAR OS COMBO BOX, PASSAR O QUARTO ELEMENTO FCORDER
               
               18/2/2009 16:39:55 - Sonia Perdigão
               XBP2 -> Retirar aspas simples e duplas de campo caracter evitando erros de query

               19/02/2009 10:47:00 - Valdimari Martins
               XBP2 -> Consistência de foreign key ao deletar um item.

               02/04/2009 17:50:00 - Valdimari Martins  
               CARREGA_CBOX -> Inclusão da Claúsula WHERE para seleção de registros.
               
               24/04/2009 09:50:00 - Valdimari Martins
               PASTA_QUANT -> Inclusão da totalização da aba Recebimento / Ressarcimento.
               
               27/09/2011 00:39 - Glauber Vicente Duma  
               Customização para banco Alfa - Filtro de Revisão / Aprovação de Despesas  
               GetFilterDespesa()
               
                                             
*/

function error_sys(fcMENS)
   local lcERROR_MENS := '' ,;
         lcLAST_SQL   := '' ,;
         lcCOMMAND    := '' as string
   local ii := 0 as int


   lcERROR_MENS += '<!--'+CRLF
   lcERROR_MENS += '# ---------------- ' + dtos(date()) + '  ' + time() +' ----------------'+CRLF
   lcERROR_MENS += '# gmPAGE  : '+gmPAGE+CRLF
   lcERROR_MENS += '# gcLOGIN : '+gcLOGIN+CRLF
   lcERROR_MENS += '# gnUID   : '+str(gnUID)+CRLF
   lcERROR_MENS += '# gmGID   : '+str(gnGID)+CRLF
   lcERROR_MENS += '## Fatal error:'+CRLF
   lcERROR_MENS += fcMENS+CRLF+CRLF
   lcERROR_MENS += procname(6)+'['+ ltrim(str(procline(6))) +']  '+ procname(5)+'['+ ltrim(str(procline(5))) +']  '+ procname(4)+'['+ ltrim(str(procline(4))) +']  '+ procname(3)+'['+ ltrim(str(procline(3))) +']  '+procname(2)+'['+ ltrim(str(procline(2))) +']  '+ procname(1)+'['+ ltrim(str(procline(1))) +']'+CRLF
   lcERROR_MENS += lcLAST_SQL+CRLF+CRLF
   lcERROR_MENS += '## No fatal error:'+CRLF
   for ii := 1 to len(gaERROR_SYS)
      lcERROR_MENS += gaERROR_SYS[ii]+CRLF
   next  ii

   lcERROR_MENS += '# ---------------------------------------------'+CRLF
   lcERROR_MENS += '-->'+CRLF

   WPut('LAST_ERROR',lcERROR_MENS)


   if WSet('ERROR_SYS') != ''
     fcMENS := WSet('ERROR_SYS')
     werror_wic()
   else
     WSet('ERROR_SYS',fcMENS)
     lcLAST_SQL := wSet('_lastsql')
     WSet('WOUT_SPOOL','N')
     WPut('errormens',fcMENS)
     WPut('WUIPROJECTHEAD',WDataGlobal('WUIPROJECTHEAD'))

     if 'licença de uso' $ lower(fcMENS)
        werror_access_wic()
     else
        if "Access Control" $ fcMENS .or. "Acesso" $ fcMENS
           //werror_access_wic()
           exec_page('werror_access.wic',wSet("_LANGUAGE_ACTIVE"))
        else
           //werror_wic()
           exec_page('werror.wic',wSet("_LANGUAGE_ACTIVE"))
        endif
     endif
   endif

   WOut(lcERROR_MENS)
   db_disconnect()
//   WQUIT()
quit

return

// Glauber 24/03/2015
// Sonia o erro estava aqui, este formato abaixo que comentei era para versão linux
// na lib nova esta no novo formato logo abaixo

//function PutError(fcMENS)
// só gera se wdebug esta ativo
//   if gbWDEBUG
//      aadd(gaERROR_SYS, procname(8)+'['+ ltrim(str(procline(8))) +']  '+ procname(7)+'['+ ltrim(str(procline(7))) +']  '+ procname(6)+'['+ ltrim(str(procline(6))) +']  '+ procname(5)+'['+ ltrim(str(procline(5))) +']  '+ procname(4)+'['+ ltrim(str(procline(4))) +']  '+ procname(3)+'['+ ltrim(str(procline(3))) +']  '+ procname(2)+'['+ ltrim(str(procline(2))) +']  '+ procname(1)+'['+ ltrim(str(procline(1))) +']  Row: '+alltrim(str(gnROW))+'  Error: '+transform(fcMENS))
//   endif
//return


function PutError(fcMENS)
// Glauber 29/08/2013
//
// Verificar sempre se o wdebug esta habilitado no wprofile.
//

if WSET('_WDEBUG') == 'ENABLED' .or. WSET('_WDEBUG') == 'ENABLE'
   aadd(gaERROR_SYS, procname(8)+'['+ ltrim(str(procline(8))) +']  '+ procname(7)+'['+ ltrim(str(procline(7))) +']  '+ procname(6)+'['+ ltrim(str(procline(6))) +']  '+ procname(5)+'['+ ltrim(str(procline(5))) +']  '+ procname(4)+'['+ ltrim(str(procline(4))) +']  '+ procname(3)+'['+ ltrim(str(procline(3))) +']  '+ procname(2)+'['+ ltrim(str(procline(2))) +']  '+ procname(1)+'['+ ltrim(str(procline(1))) +']  Row: '+alltrim(str(gnROW))+'  Error: '+transform(fcMENS))
endif
//   aadd(gaERROR_SYS,'Linha: '+alltrim(str(gnROW))+'  --  Erro: '+transform(fcMENS))
return

/*******************************/

// Testa um CGC ou CPF
function chk_CNPJCPF(verCGCCPF)
 local VCCcont:=0
 if empty(verCGCCPF)
   return(.t.)
 endif
   do case
//   case len(alltrim(verCGCCPF)) <= 5 .or. (len(alltrim(verCGCCPF)) > 1 .and. val(verCGCCPF) = 0)
//        mensagem("C¢digo n&#8222;o &#8218; CGC/CPF portanto n&#8222;o ser  usado em documentos fiscais.")
//        return(.t.)
   case len(alltrim(verCGCCPF)) = 14
      verCGCCPF=substr(verCGCCPF,1,2)+"."+substr(verCGCCPF,3,3)+"."+substr(verCGCCPF,6,3)+"/"+substr(verCGCCPF,09,4)+"-"+substr(verCGCCPF,13,2)
      ii:= ix:= total:= digito:= 0
      xtab:= "6543298765432"
      declare tab[13]
      declare cgc[14]
      for ix:= 1 to 13
        tab[ix]:= val(substr(xtab,ix,1))
      next
      for ix = 1 to 18
      if ix <> 3 .and. ix <> 7 .and. ix <> 11 .and. ix <> 16
         ii = ii + 1
         cgc[ii] = val(substr(verCGCCPF,ix,1))
      endif
      next
      for ix = 1 to 13
      total = total + (cgc[ix] * tab[ix])
      next
      digito = total % 11
      if digito = 1 .or. digito = 0
         store 0 to digito
      else
         digito = 11 - digito
      endif
      mdigtot=str(digito,1)
      if substr(verCGCCPF,18,1)#mdigtot
        return(.f.)
      endif
   case len(alltrim(verCGCCPF)) = 11
      verCGCCPF=substr(verCGCCPF,1,3)+"."+substr(verCGCCPF,4,3)+"."+substr(verCGCCPF,7,3)+"-"+substr(verCGCCPF,10,2)
      store 0 to digito1, digito2, valor1, resto
      cpf = alltrim(verCGCCPF)
      valor1 = (val(substr(cpf,11,1))*2) + (val(substr(cpf,10,1))*3) +;
      (val(substr(cpf,9,1))*4) + (val(substr(cpf,7,1))*5) +;
      (val(substr(cpf,6,1))*6) + (val(substr(cpf,5,1))*7) +;
      (val(substr(cpf,3,1))*8) + (val(substr(cpf,2,1))*9) +;
      (val(substr(cpf,1,1))*10)
      resto  = valor1 - INT(valor1/11)*11
      if resto = 0 .or. resto = 1
         digito1 = 0
      else
         digito1 = 11 - resto
      endif
      valor1 = (DIGITO1*2) +(val(substr(cpf,11,1))*3) +;
      (val(substr(cpf,10,1))*4) + (val(substr(cpf,9,1))*5) +;
      (val(substr(cpf,7,1))*6) + (val(substr(cpf,6,1))*7) +;
      (val(substr(cpf,5,1))*8) + (val(substr(cpf,3,1))*9) +;
      (val(substr(cpf,2,1))*10) + (val(substr(cpf,1,1))*11)
      resto  = valor1 - INT(valor1/11)*11
      if resto = 0 .or. resto = 1
         digito2 = 0
      else
         digito2 = 11 - resto
      endif
      mdigtot=str(digito1,1)+str(digito2,1)
      if substr(verCGCCPF,13,2)#mdigtot
        return(.f.)
      endif
   other
     return(.f.)
   endcase
   VCCcont=VCCcont+1
return(.t.)

/*
* Function..: chk_UF(<fcUF>)
* Objetivo..: Verifica se um estado é válido.
* Parâmetros:
*    fcUF.....: Estado
* Retorno...: Retorna .t. caso o estado seja válido, senão retorna .f.
*/

function chk_UF (UF)
     local POSICAO := 0 as int
     local ESTADOS := 'SPMGRJRSSCPRESDFMTMSGOTOBASEALPBPEMARNCEPIPAAMAPFNACRRRO' as string
     POSICAO := at (UF,ESTADOS)
     if POSICAO % 2 = 0
          return (.f.)
     endif
return (.t.)

/*
* Function..: afields2comma(<faFIELDS>,[<fcTABLE>])
* Objetivo..: Montar uma string com a lista de campos de uma tabela
* Parâmetros:
*    faFIELDS.: Vetor com os campos
*    fcTABLE..: Caso seja enviado a string é montada no formato 2
* Retorno...: String de campos nos seguintes formatos:
*     F1.: CAMPO1,CAMPO2,CAMPO3,...,CAMPOn
*     F2.: tabela.CAMPO1,tabela.CAMPO2,tabela.CAMPO3,...,tabela.CAMPOn
*/
function afields2comma(faFIELDS,fcTABLE,faREMOVE)
   local fcFIELDS := '' as string
   local x      := 0 as int
   fcFIELDS := iif(pcount()=1,faFIELDS[1],fcTABLE+'.'+faFIELDS[1])
   for x := 2 to len(faFIELDS)
       fcFIELDS += iif(pcount()=1,','+faFIELDS[x],','+fcTABLE+'.'+faFIELDS[x])
   next ii
return(fcFIELDS)
function inscomadelimeter(fcSTRING)
   local lcSTRING := '' as string
   lcSTRING := alltrim(fcSTRING)
   do while .t.
      if substr(lcSTRING,1,1) = ','
         lcSTRING := substr(lcSTRING,2)
      else
         exit
      endif
   enddo
   do while .t.
      if substr(lcSTRING,len(lcSTRING),1) = ','
         lcSTRING := substr(lcSTRING,1,len(lcSTRING)-1)
      else
         exit
      endif
   enddo
return(','+lcSTRING+',')

/*
* Function..: date2longsrt(fdDATE)
* Objetivo..: retornar data por extenso
* Parâmetros:
*    fdDATE : data
* Retorno...: String no formato:
*     ex: Quarta, 9 de outubro de 2002
*/
function date2longsrt(fdDATE)
   local laMES_EXTENSO := {} ,;
         laDIA_SEMANA  := {} ,;
         laRESULT  := {}  as array
   laMES_EXTENSO := {'Janeiro',;
                     'Fevereiro',;
                     'Marco',;
                     'Abril',;
                     'Maio',;
                     'Junho',;
                     'Julho',;
                     'Agosto',;
                     'Setembro',;
                     'Outubro',;
                     'Novembro',;
                     'Dezembro'}
   laDIA_SEMANA := {'Domingo',;
                    'Segunda',;
                    'Terca',;
                    'Quarta',;
                    'Quinta',;
                    'Sexta',;
                    'Sabado'}
return('RPT_DATA_EXTENSO',laDIA_SEMANA[dow(fdDATE)]+', '+str(day(fdDATE),2)+' de '+laMES_EXTENSO[month(fdDATE)]+' de '+str(year(fdDATE),4))

/*
* Function..: uf()
* Objetivo..: retornar uma lista com as iniciais de estados (UF)
* Parâmetros: Nenhum
* Retorno...: Array Unidimensional
*/
function uf()
return (asort({" ","SP","MG","RJ","RS","SC","PR","ES","DF","MT","MS","GO","TO","BA","SE",;
               "AL","PB","PE","MA","RN","CE","PI","PA","AM","AP","FN","AC","RR","RO"}))

/*
* Function..: sms_device() - Mantida apenas para compatibilidade, deve ser removida qdo os programas antigos (fora de uso)
*             forem apagados (apenas no Windows)
* Objetivo..: ****
* Parâmetros: ****
* Retorno...: array vazio
*/
function sms_device()
return ({})

/*
* Function..: FindUG(fcLIST,fcUSER_GROUP)
* Objetivo..: Validar uma lista de usuários ou grupos
* Parâmetros:
*    fcLIST.......: Lista de usuários ou groupos separados por vírgula (,)
*    fcUSER_GROUP.: [U] - Usuários [G] - Grupos
* Retorno...: Caso os usuários ou grupos não sejam encontrados, uma mensagem de erro contendo os nomes de usuário ou de
*             grupos não econtrados é retornada
*/
function FindUG(fcLIST,fcUSER_GROUP)
   local laLIST := {} ,;
         laRES  := {} as array
   local lcLIST      := '' ,;
         lcITEM      := '' ,;
         lcMSG_ERROR := '' as string
   local ii     := 0 ,;
         liPOS  := 0 as int
   lcLIST := strtran(fcLIST,' ','')
   liPOS := at(',',lcLIST)
   do while liPOS > 0
      aadd(laLIST,alltrim(substr(lcLIST,1,liPOS-1)))
      lcLIST := substr(lcLIST,liPOS+1,(len(lcLIST)-liPOS)+1)
      liPOS := at(',',lcLIST)
   enddo
   if len(lcLIST) > 0
      aadd(laLIST,substr(lcLIST,1,len(lcLIST)))
   endif
   lcLIST  := strtran(fcLIST,' ','')
   if fcUSER_GROUP='U'
      if db_select({'LOGIN'},'acuser',,{'LOGIN in ('+chr(39)+strtran(lcLIST,',',chr(39)+','+chr(39))+chr(39)+')'}) == -1
         error_sys(db_error())
      endif
   else
      if db_select({'NM_GROUP_TASK'},'task_group',,{'NM_GROUP_TASK in ('+chr(39)+strtran(lcLIST,',',chr(39)+','+chr(39))+chr(39)+')'}) == -1
         error_sys(db_error())
      endif
   endif
   laRES := db_fetchall()
   for ii := 1 to len(laLIST)
       lcITEM := alltrim(laLIST[ii])
       if ascan(laRES, {|laFIND| alltrim(laFIND[1]) == lcITEM}) <= 0
          lcMSG_ERROR += laLIST[ii]+','
       endif
   next ii
   if len(lcMSG_ERROR) > 0
      lcMSG_ERROR := iif(fcUSER_GROUP='U','Usuário(s) não encontrado(s): ','Grupo(s) não encontrado(s): ')+;
                     substr(lcMSG_ERROR,1,len(lcMSG_ERROR)-1)
   endif
return(lcMSG_ERROR)

/*
* Function..: lfFindUser(<fcLOGIN>)
* Objetivo..: Buscar e retornar o nome do usuario
* Parâmetros:
*    fcLOGIN.: Login do usuário
* Retorno...: String contendo o nome completo do usuário
*/
function lfFindUser(fcLOGIN)
   local lcNM_USER := '' as string
   local laRES := {} as array
   if db_select({'WUSER'},'acuser',,{'LOGIN='+DLMT+fcLOGIN+DLMT}) == -1
      error_sys(db_error())
   endif
   laRES := db_fetchrow()
   if len(laRES) > 0
      if !empty(laRES[1])
         lcNM_USER := laRES[1]
      else
         lcNM_USER := '<sem nome>'
      endif
   endif
return(lcNM_USER)

/*
* Function..: layout_pasta(fcTP_PASTA,fcPROGRAMA,fbEXTRANET)
* Objetivo..: Selecionar templates para Pasta e altear o valo da variável global gmPAGE para o template selecionado
* Parâmetros:
*    fcTP_PASTA.: Tipo de caso
*    fcPROGRAMA: Nome do programa
*      Programas possíveis:
*       pasta........: mnt.pasta.xxx.html
*       pasta_pre....: mnt.pst.pre.xxx.html
*       andamento....: mnt.pst.and.xxx.html
*       rpt_pasta....: rpt.pasta.xxx.html
*       rpt_andamento: rpt.pst.and.xxx.html
*    fbEXTRANET: Informar se foi chamdo pelo módulo cliente
*      Valores possíveis
*       .T. : chamda pelo módulo Cliente (Extranet)
*       .F. : chamada por outros módulos
*    fcABA: Sub-Página relacionada aquele Layout. Ex: Execucao
* Retorno...:
*   .T. em caso de sucesso
*   .F. em caso de falha
*/
function layout_pasta(fcTP_PASTA,fcPROGRAMA,fbEXTRANET,fcABA)
   local lcPAGE   := '' as string
   local laRESULT := {} as array

   if valtype(pcLAYOUT_PASTA) == 'U'
      if db_select({'LAYOUT_PASTA'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) == -1
         putError('layout_pasta: [pasta_config] - '+db_error())
         return (.f.)
      endif
      laRESULT := db_fetchrow()
   else
      laRESULT := {pcLAYOUT_PASTA}
   endif

   if len(laRESULT) = 0
      putError('layout_pasta: not found: TP_PASTA='+fcTP_PASTA+' in pasta_config')
      return(.f.)
   endif
   if valtype(fcABA) != 'U' .and. !empty(fcABA)
      laRESULT[1]+= '.'+fcABA
   endif
   if fcPROGRAMA = 'pasta'
      lcPAGE := lower('mnt.pasta.'+laRESULT[1]+'.html')
   elseif fcPROGRAMA = 'pasta_pre'
      lcPAGE := lower('mnt.pst.pre.'+laRESULT[1]+'.html')
   elseif fcPROGRAMA = 'mnt.pst.andamento'
      lcPAGE := lower('mnt.pst.andamento'+laRESULT[1]+'.html')
   elseif fcPROGRAMA = 'mnt.ext.andamento'
      lcPAGE := lower('mnt.ext.andamento'+laRESULT[1]+'.html')
   endif

   /*
   if !fbEXTRANET  //Demais módulos
      if fcPROGRAMA = 'pasta'
         lcPAGE := lower('mnt.pasta.'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'pasta_pre'
         lcPAGE := lower('mnt.pst.pre.'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'mnt.pst.andamento'
         lcPAGE := lower('mnt.pst.andamento'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'mnt.ext.andamento'
         lcPAGE := lower('mnt.ext.andamento'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'rpt_pasta'
         lcPAGE := lower('rpt.pasta.'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'rpt_andamento'
         lcPAGE := lower('rpt.pst.and.'+laRESULT[1]+'.html')
      endif
   else                  //Módulo [cliente] (Extranet)
      if fcPROGRAMA = 'pasta'
         lcPAGE := lower('pst.cli.'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'rpt_pasta'
         lcPAGE := lower('rpt.cli.'+laRESULT[1]+'.html')
      elseif fcPROGRAMA = 'rpt_andamento'
         lcPAGE := lower('rpt.cli.and'+laRESULT[1]+'.html')
      endif
   endif

   if db_select({'PROGRAM'},'dbui',,{'PROGRAM='+DLMT+lcPAGE+DLMT},,,,{1}) == -1
      putError('layout_pasta: [dbui] - '+db_error())
      return (.f.)
   endif
   laRESULT := db_fetchrow()
   if len(laRESULT) = 0
      if !fbEXTRANET //Demais Módulos
         if fcPROGRAMA = 'pasta'
            lcPAGE := 'mnt.pasta.html'
         elseif fcPROGRAMA = 'pasta_pre'
            lcPAGE := 'pasta.pre.html'
         elseif fcPROGRAMA = 'mnt.pst.andamento'
            lcPAGE := 'mnt.pst.andamento.html'
         elseif fcPROGRAMA = 'mnt.ext.andamento'
            lcPAGE := 'mnt.ext.andamento.html'
         elseif fcPROGRAMA = 'rpt_pasta'
            lcPAGE := 'rpt.pastas.html'
         elseif fcPROGRAMA = 'rpt_andamento'
            lcPAGE := 'rpt.pst.andamento.html'
         endif
      else                //Módulo [cliente] (Extranet)
         if fcPROGRAMA = 'pasta'
            lcPAGE := 'pst.cli.consulta.html'
         elseif fcPROGRAMA = 'rpt_pasta'
            lcPAGE := 'rpt.cli.pasta.html'
         elseif fcPROGRAMA = 'rpt_andamento'
            lcPAGE := 'rpt.cli.andamento.html'
         endif
      endif
   endif
   */
   WSet('_USER_INTERFACE',lcPAGE)
return(.t.)

/*
* Function..: pasta_abas(fcTP_PASTA)
* Objetivo..: Gerar Abas laterais de acordo com o Layout selecionado
* Parâmetros:
*     fcTP_PASTA.: Tipo de Pasta
* Retorno...: Nenhum
*/
/*function pasta_abas(fcTP_PASTA) */
function pasta_abas(fcTP_PASTA,fnORIGEM)
   local lcOBJ_ID   := '' ,;
         lcNR_PASTA := '' ,;
         lcQUERY    := '' ,;
         lcMENU     := '' as string
   local laRESULT := {} ,;
         laPARAMS := {} ,;
         laQUANT  := {} ,;
         laRES    := {} ,;
         laABAS   := {} as array

   local ii := 0 as int

   local lcTAND := '' as string
   local lcTALE := '' as string

   lcNR_PASTA := wGet('NR_PASTA','C') // Pega o NR_PASTA enviado pelo html
   if val(lcNR_PASTA) == 0
      lcNR_PASTA := getwput('NR_PASTA','C')
   endif

   if valtype(pcLAYOUT_PASTA) == 'U'
      if db_select({'LAYOUT_PASTA'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) = -1
         error_sys(db_error())
      endif
      laRESULT := db_fetchrow()
   else
      laRESULT := {pcLAYOUT_PASTA}
   endif

   if len(laRESULT) = 0
      putError('pasta_abas: not found: TP_PASTA='+fcTP_PASTA+' in pasta_config')
      return(.f.)
   else
      /* Gera Abas de Programas */
      lcMENU := 'PST_'+upper(laRESULT[1])

      /*
      if len(db_findrec({'MENU'},'wmenu','MENU='+DLMT+lcMENU+DLMT)) = 0 // Se o menu de abas relacionado ao layout não existir
         lcMENU := 'PST_PADRAO'                                         // Traz o menu de abas padrão
      endif
      */

      laABAS := structmenu(lcMENU)

      if len(laABAS) > 0

         aadd(laABAS[1],'OBJ_ID')
         aadd(laABAS[1],'WVAL1')
         aadd(laABAS[1],'WVAL2')

         for ii := 2 to len(laABAS)
            lcOBJ_ID := substr( laABAS[ii,1] , rat('/',laABAS[ii,1])+1 ) // Extrai a string depois da ultima barra encontrada.
            lcOBJ_ID := strtran( lcOBJ_ID , '.' , '_' )                  // Transforma pontos em underline.
            aadd(laPARAMS,lcOBJ_ID)
            aadd(laABAS[ii],lcOBJ_ID)
            aadd(laABAS[ii],'')
            aadd(laABAS[ii],'')

         next ii
         laQUANT := pasta_quant(lcNR_PASTA,laPARAMS)

         for ii := 2 to len(laABAS)
            lcOBJ_ID := laABAS[ii,3]

            // Glauber 13/09/2013
            // Adição do contador de andamentos críticos na aba andamentos
            //

            lcTAND:= iif(ascan(laQUANT,{| x | alltrim(x[1]) == lcOBJ_ID}) > 0 ,;
                         alltrim(laQUANT[ascan(laQUANT,{| x | alltrim(x[1]) == lcOBJ_ID}),2]), '')


            if (lcOBJ_ID == 'mnt_pst_andamento_html')

               if (lcNR_PASTA == 'New')
                  laRES := {{'COUNT'},{0}}
               else
                   lcQUERY := "select count(*) from pasta_andamento where NR_PASTA="+lcNR_PASTA+" and FL_ANDAMENTO_CANCELADO = 'N'  AND (FL_ANDAMENTO_EXTERNO <> 'S' or FL_ANDAMENTO_EXTERNO is null) and (FL_CRITICO='S')"
                   if db_query(lcQUERY) == -1
                      error_sys(db_error())
                   endif
                   laRES := db_fetchall()
               endif

               lcTALE:= iif(ascan(laQUANT,{| x | alltrim(x[1]) == lcOBJ_ID}) > 0 ,;
                            alltrim(laRES[2,1]), '')

               laABAS[ii,db_fetchncol(laABAS,'WVAL1')] ='(' + ALLTRIM(str(val(lcTAND))) +')'


               laABAS[ii,db_fetchncol(laABAS,'WVAL2')] = 'C/Alerta ('+ALLTRIM(str(val(lcTALE)))+')'


            else

               if lcTAND<>''
                  laABAS[ii,db_fetchncol(laABAS,'WVAL1')] ='(' + ALLTRIM(str(val(lcTAND))) +')'
               endif

            endif
         next ii
//debug2(laABAS,,50)

/*
.: Inicio Function Debug(Var) Ver. 2 :.

|
| WACTION                                            | WLABEL                                             | OBJ_ID                                             |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/mnt.pasta.ht | Informações Principais                             | mnt_pasta_html                                     |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.escrito | Escritório                                         | psab_escritorio_html                               |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.seg.2co | Seguro (2)                                         | psab_seg_2cont_sinistro_html                       |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.auto.ht | Peças Processuais (0)                              | psab_auto_html                                     |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/mnt.pst.part | Partes (0)                                         | mnt_pst_partes_html                                |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.despesa | Despesas (12)                                      | psab_despesa_html                                  |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/mnt.pst.anda | Andamento (7)                                      | mnt_pst_andamento_html                             |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/mnt.canc.and | Andamentos Cancelados (0)                          | mnt_canc_andamento_html                            |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.dep.con | Depósitos (0)                                      | psab_dep_cont_html                                 |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.pedido. | Pedidos (1)                                        | psab_pedido_html                                   |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.res.sin | Resultado (1)                                      | psab_res_sin_html                                  |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.mvt_con | Lançamentos Contábeis (0)                          | psab_mvt_contabil_html                             |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.jurispr | Jurisprudência (0)                                 | psab_jurisprudencia_html                           |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.analise | Análise de causa                                   | psab_analise_causa_html                            |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.corpora | Corporativo                                        | psab_corporativo_html                              |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.agenda. | Agenda                                             | psab_agenda_html                                   |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.relacio | Relacionamento entre Pastas (0)                    | psab_relacionamento_html                           |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/mnt.pst.docr | Geração Automática de Documentos                   | mnt_pst_docrtf_html                                |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/psab.div.res | Divisão Responsabilidade (0)                       | psab_div_responsabilidade_html                     |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/ps.log.alter | Histórico de Alterações                            | ps_log_alteracao_html                              |
| ------------------------------------------------------------------------------------------------------------------------
| /tokiopr3/gr5.exe/ID=ZQQRJIUWTKMSPLMJ/pst.transf.h | Transferência de Pasta                             | pst_transf_html                                    |
| ------------------------------------------------------------------------------------------------------------------------


*/
         wPut('lstABAS',laABAS)
      endif
      /* Gera Abas de Relatórios */
      lcMENU := 'PST_RPT_'+upper(laRESULT[1])
      /*
      if len(db_findrec({'MENU'},'wmenu','MENU='+DLMT+lcMENU+DLMT)) = 0 // Se o menu de abas relacionado ao layout não existir
         lcMENU := 'PST_RPT_PADRAO'                                     // Traz o menu de abas padrão
      endif
      */
      laABAS := structmenu(lcMENU)
      if len(laABAS) > 0
         aadd(laABAS[1],'OBJ_ID')
         for ii := 2 to len(laABAS)
            aadd(laABAS[ii],'rpt_'+alltrim(str(ii-1)))
         next ii
         wPut('lstRPT_ABAS',laABAS)
      endif
   endif
return(nil)

/*
* Function..: pasta_quant(fcNR_PASTA,fcOBJ_ID)
* Objetivo..: Retorna a quantidade de registros cadastrados nas tabelas de pasta.
*             Exemplo: Contingencia,Penhora,Andamentos...
* Parâmetros:
*    fcNR_PASTA.: Número da Pasta
*    faPARAMS...: Array com os IDS dos objetos
* Retorno...: resultado do db_fetchall()
*/
function pasta_quant(fcNR_PASTA,faPARAMS)
   local lcOBJ_ID := '' as string

   local laRES    := {},;
         laALTERA := {}  as array

   local lnPOS := 0 ,;
         ii    := 0 as int

   if upper(fcNR_PASTA) == 'NEW' .or. empty(fcNR_PASTA)
      fcNR_PASTA := '0'
   endif
   if len(faPARAMS) > 0
     /*
      * Formato do Array laALTERA:
      * Primeira Linha com os cabeçalhos
      * 2.a Linha em diante os dados respectivos
      * Colunas:
      * 1) OBJ_ID        : id do objeto no html
      * 2) TABLE         : tabela a ser realizado o count(*)
      * 3) WHERE         : condição Where
      *
      */
      laALTERA := {{'OBJ_ID',                         'TABLE',                     'WHERE' }}
      aadd(laALTERA,{'mnt_pst_rcs_html',              'pasta_recurso',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'mnt_pst_carta_precatoria_html', 'pasta_ct_precatoria',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'mnt_pst_contingencia_html',     'pasta_contingencia',        'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'mnt_pst_partes_html',           'pasta_outraspartes',        'NR_PASTA='+fcNR_PASTA })
//      aadd(laALTERA,{'mnt_pst_andamento_html',        'pasta_andamento',           'NR_PASTA='+fcNR_PASTA+' and FL_ANDAMENTO_EXTERNO <> "S" and (FL_ANDAMENTO_CANCELADO <> "S" or FL_ANDAMENTO_CANCELADO is null)'})
      aadd(laALTERA,{'mnt_pst_andamento_html',        'pasta_andamento',           'NR_PASTA='+fcNR_PASTA+' and FL_ANDAMENTO_CANCELADO = "N"  AND (FL_ANDAMENTO_EXTERNO <> "S" or FL_ANDAMENTO_EXTERNO is null) and (FL_CRITICO<>"S")'})
      aadd(laALTERA,{'mnt_ext_andamento_html',        'pasta_andamento',           'NR_PASTA='+fcNR_PASTA+' and FL_ANDAMENTO_EXTERNO = "S"  and (FL_ANDAMENTO_CANCELADO <> "S" or FL_ANDAMENTO_CANCELADO is null)'})
      aadd(laALTERA,{'mnt_canc_andamento_html',       'pasta_andamento',           'NR_PASTA='+fcNR_PASTA+' and FL_ANDAMENTO_CANCELADO="S"'})
      aadd(laALTERA,{'mnt_mvt_servico_html',          'mvt_servico',               'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'mnt_mvt_despesa_html',          'mvt_despesa',               'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'pst_aditivo_contrato_html',     'pasta_contrato_aditivo',    'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'pst_1aditivo_contrato_html',    'pasta_contrato_aditivo',   'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'pst_anexo_contrato_html',       'pasta_contrato_anexo',      'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'pst_penhora_html',              'pasta_penhora',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_socios_html',            'pasta_sct_socios',          'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_superintendencia_html',  'pasta_sct_superintendencia','NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_diretoria_html',         'pasta_sct_diretoria',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_conselhos_html',         'pasta_sct_conselhos',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_atos_html',              'pasta_sct_ato',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_atas_html',              'pasta_sct_ata',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_sct_procedimento_html',      'pasta_sct_procedimento',    'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_otgantes_html',              'pasta_prc_outorgante',      'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_otgados_html',               'pasta_prc_outorgado',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'ps_poderes_html',               'pasta_prc_poder',           'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_seguro_html',              'pasta_seguro',              'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_se_cont_html',             'pasta_seguro',              'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_seg_sinistro_html',        'pasta_seguro',              'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_seg_cont_sinistro_html',   'pasta_seguro',              'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_auto_html',                'pasta_auto',                'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_deposito_html',            'pasta_deposito',            'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_garantia_html',            'pasta_garantia',            'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_relacionamento_html',      'pasta_relacionamento',      'NR_PASTA='+fcNR_PASTA+' or NR_PASTA_FILHO='+fcNR_PASTA})
      aadd(laALTERA,{'psab_ra_contratos_html',        'ra_contrato',               'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_ra_ocorrencias_html',      'ra_ocorrencia',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_resultado_html',           'pasta_resultado_pedidos',   'NR_PASTA='+fcNR_PASTA+' and NR_INSTANCIA=1' })
      aadd(laALTERA,{'psab_nuloresultado_html',       'pasta_resultado_pedidos',   'NR_PASTA='+fcNR_PASTA+' and NR_INSTANCIA=1' })
      aadd(laALTERA,{'psab_res_sin_html',             'pasta_resultado_pedidos_sinistro',  'NR_PASTA='+fcNR_PASTA+' and NR_INSTANCIA=1' })
      aadd(laALTERA,{'psab_jurisprudencia_html',      'pasta_jurisprudencia',      'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_rateio_ccusto_html',       'pasta_rateio_ccusto',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_itens_html',               'pasta_itens_contrato',      'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_lic_certificado_html',     'pasta_lic_certificado',     'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_sindicancia_html',         'pasta_contrato_sindicancia','NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_div_responsabilidade_html','pasta_div_responsabilidade','NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_div_responsabilidade_html','pasta_div_responsabilidade','NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_locador_html',             'pasta_contrato_locador',    'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_despesa_html',             'mvt_despesa',               'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_desp_adicionais_html',     'pasta_despesas_adicionais', 'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_mvt_contabil_html',        'mvt_contabil',              'WTABLE='+DLAP+'pasta'+DLAP+' and WPKEY_NUM='+fcNR_PASTA})
      aadd(laALTERA,{'psab_dep_cont_html',            'pasta_deposito',            'NR_PASTA='+fcNR_PASTA })
//      aadd(laALTERA,{'psab_pedido_html',              'pasta_pedidos',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_pedido_html',              'pasta_pedidos',             'NR_PASTA='+fcNR_PASTA + ' and (NR_PEDIDO_ORIGEM = 0 or NR_PEDIDO_ORIGEM is null)'})
      aadd(laALTERA,{'psab_notificacao_html',         'pasta_notificacao',         'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_acordo_html',              'pasta_acordo',              'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_recurso_html',             'pasta_recurso',             'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_ressarc_html',             'pasta_ressarc_rec',         'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_receb_ressarc_html',       'receb_ressarcimento',       'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_ped3_html',                'pasta_pedidos',             'NR_PASTA='+fcNR_PASTA })
     // Glauber 04/10 - aba despesas em grupo
      aadd(laALTERA,{'psab_gr_despesa_html',          'mvtdespesagrupo',           'NR_PASTA='+fcNR_PASTA })
      aadd(laALTERA,{'psab_embargo_html',             'pasta_embargo',             'NR_PASTA='+fcNR_PASTA })

      local lcQUERY := '' as string
      lcQUERY += 'select '+DLAP+space(80)+DLAP+', 0 as QTD '
      for ii := 1 to len(faPARAMS)
         lcOBJ_ID := faPARAMS[ii]
         lnPOS := ascan(laALTERA, { |x| x[1]== lcOBJ_ID })
         if lnPOS > 0
            lcQUERY += ' union'
            lcQUERY += ' select '+DLAP+lcOBJ_ID+DLAP+' as ABA,count(*) as QTD from '+laALTERA[lnPOS,2]
            lcQUERY += ' where '+laALTERA[lnPOS,3]
         endif
      next ii
      if db_query(lcQUERY) == -1
         error_sys(db_error())
      endif
      laRES := db_fetchall()
    endif
return(laRES)

/*
* Function..: pst_cabec(fcNR_PASTA,fcTP_PASTA,flFL_SELECT)
* Objetivo..: Define qual o cabeçalho a ser exibido nos programas de Pasta
*             de acordo com TP_PASTA
* Parâmetros:
*    fcNR_PASTA ..: Numero da Pasta
*    fcTP_PASTA ...: Tipo de Pasta
*    fcFL_SELECT .: .T. caso queira selecionar os campos da tabela pasta, .F. caso queira apenas definir o cabeçalho
* Retorno...: .F. em caso de erro
*             .T. em caso de Sucesso
*/
function pst_cabec(fcNR_PASTA,fcTP_PASTA,flFL_SELECT)
   local laRESULT  := {} ,;
         laFIELDS  := {} ,;
         laFOREIGN := {} as array
   local lcTP_PASTA := '' ,;
         lcWHERE   := '' as string
   local ii := 0 as int
   local luVALUE
   /* Seleciona os dados do Cabeçalho caso flFL_SELECT == .T. */
   if flFL_SELECT
      laFIELDS := structtable(WSet("DB_ACTIVE"),'pasta',1,'A')
      if db_select(laFIELDS,'pasta',,{'NR_PASTA='+fcNR_PASTA}) =-1
         error_sys('pst_cabec:'+db_error())
      endif
      laRESULT := db_fetchall()
      /*
       * Foi necessário a solução provisória abaixo para renomear
       * Campo NR_PROCESSO, devido aparecer 2 vezes em alguns layouts
       * Mas de tabelas disttintas.
       */
      laRESULT[1,db_fetchncol(laRESULT,'NR_PROCESSO')] := 'PST_NR_PROCESSO'
      db2Put(laRESULT)
      laFOREIGN := {{'correspondente','CD_CORRESPONDENTE','NM_CORRESPONDENTE'},;
                    {'cobranca','CD_COBRANCA','NM_COBRANCA'},;
                    {'grupo_economico','CD_GRP_ECONOMICO','NM_GRP_ECONOMICO'},;
                    {'tabela_servico','CD_TB_SERVICO','NM_TB_SERVICO'},;
                    {'tabela_honorario','CD_TB_HONORARIO','NM_TB_HONORARIO'},;
                    {'tabela_despesa','CD_TB_DESPESA','NM_TB_DESPESA'},;
                    {'indice_reajuste','CD_INDICE','NM_INDICE'},;
                    {'centrocusto','CD_CCUSTO','NM_CCUSTO'}}
      for ii:= 1 to len(laFOREIGN)
         luVALUE := laRESULT[2,db_fetchncol(laRESULT,laFOREIGN[ii,2])]
         if valtype(luVALUE) == 'N'
            lcWHERE := laFOREIGN[ii,2]+'='+str(luVALUE)
         elseif valtype(luVALUE) == 'C'
            lcWHERE := laFOREIGN[ii,2]+'='+DLMT+luVALUE+DLMT
         endif
         if db_select({laFOREIGN[ii,3]},laFOREIGN[ii,1],,{lcWHERE}) = -1
            error_sys(db_error())
         endif
         db2Put(db_fetchall())
      next ii
   endif
   /* Define qual cabeçalho será exibido de acordo com fcTP_PASTA */
   if db_select({'LAYOUT_PASTA'},'pasta_config',,{'TP_PASTA='+DLMT+fcTP_PASTA+DLMT}) = -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchrow()
   if len(laRESULT) > 0
      lcMENU := 'PST_'+upper(laRESULT[1])
      if len(db_findrec({'MENU'},'wmenu','MENU='+DLMT+lcMENU+DLMT)) = 0 // Se o menu de abas relacionado ao layout não existir
         lcMENU := 'PST_PADRAO'                                         // Traz o menu de abas padrão
      endif
      wPut('ifCB_'+lcMENU,.T.)
   else
      error_sys('pst_cabec: Tipo de Pasta inválido')
      return(.f.)
   endif
return(.t.)

/*
/*
* Function..: carrega_cbox(faCOMBOS)
* Objetivo..: Carregar dados em objetos combobox
* Parâmetros:
*    faCOMBOS: array contendo as tabelas, campos a serem pesquisadas.
*       Formato:
*       {{tabela1,CAMPO1,'Y',where1}
*        {tabela2,CAMPO2,'N',where2}
*        {tabela3,CAMPO3,'Y',where3}
*        {...}
*        {tabelaN,CAMPOn,'Y/N',wheren}}
*       onde:
*         tabela: Nome da tabela a ser pesquisada
*         CAMPO.: Nome do campo e consequentemente do wic_input atribuido ao combobox
*         Y/N ..: Adicionar linha em branco no inicio do combo [Y/N]
*         WHERE.: Condição para pesquisa do campo.
* Retorno...:
*    Nenhum
*/
function carrega_cbox(faCOMBOS)

   local lcWHERE := '' as string
    
   local laRES := {} ,;
         laPUTV:= {} ,;
         laFIELD:={} ,;
         laDEF := {} ,;
         laATI := {} ,;
         laINA := {} ,;
         laAUX := {} ,;
         laPUTE:= {} ,;
         laPUT := {} as array

   local liPOS := 0 ,;
         ii    := 0,;
         jj    := 0 as int

   for ii := 1 to len(faCOMBOS)

       /*
          Valdimari Martins - 02/04/2009
          Testa se a faCOMBOS tem mais de 3 campos na dimensão atual.
          Caso tenha, alimenta a lcWHERE com faCOMBOS[ii,4] senão deixa em branco.
          Para a seleção retesta o conteúdo da lcWHERE. Da forma abaixo dá erro no
          mnt_pst_objeto, por isso foi trocado a verificação por resultado do if.

          if db_select({faCOMBOS[ii,2]},faCOMBOS[ii,1],,iif(lcWHERE='','',{lcWHERE}),{faCOMBOS[ii,2]}) == -1
             error_sys('carrega_cbox: '+db_error())
          endif

       */
          
       if len(faCOMBOS[ii]) > 3
         lcWHERE := faCOMBOS[ii,4]
       else
         lcWHERE := ''
       endif   

       laDEF := {}
       laATI := {}
       laINA := {}

       laPUT := {}
       laPUTV:= {}

       laAUX := {}

       laPUTE:= {}

       laFIELD := structtable(WSet("DB_ACTIVE"),faCOMBOS[ii,1],1,'A')
       liPOS   := ascan(laFIELD,'FL_ATIVO')

       if liPOS<>0
          if lcWHERE == ''
             if db_select({faCOMBOS[ii,2],'FL_ATIVO'},faCOMBOS[ii,1],,,{faCOMBOS[ii,2]}) == -1
                error_sys('carrega_cbox: '+db_error())
             endif
          else
             if db_select({faCOMBOS[ii,2],'FL_ATIVO'},faCOMBOS[ii,1],,{lcWHERE},{faCOMBOS[ii,2]}) == -1
                error_sys('carrega_cbox: '+db_error())
             endif
          endif

       else

          if lcWHERE == ''
             if db_select({faCOMBOS[ii,2]},faCOMBOS[ii,1],,,{faCOMBOS[ii,2]}) == -1
                error_sys('carrega_cbox: '+db_error())
             endif
          else
             if db_select({faCOMBOS[ii,2]},faCOMBOS[ii,1],,{lcWHERE},{faCOMBOS[ii,2]}) == -1
                error_sys('carrega_cbox: '+db_error())
             endif
          endif

       endif
       laRES := db_fetchall()


       for jj := 2 to len(laRES)
           if liPOS<>0
              if laRES[jj,2] == 'D'
                 aadd(laDEF,laRES[jj,1])
               elseif laRES[jj,2] == 'I'
                 aadd(laINA,laRES[jj,1])
               else
                 aadd(laATI,laRES[jj,1])
              endif
           else
              aadd(laATI,laRES[jj,1])
           endif
       next jj

       if len(laDEF) == 0
          if faCOMBOS[ii,3] == 'Y'  // Adiciona uma linha vazia no inicio do combo, caso seja solicitado
             aadd(laDEF,'')
          endif
       endif

       for jj=1 to len(laDEF)
           aadd(laPUT,laDEF[jj])
           aadd(laPUTV,laDEF[jj])
       next jj

       for jj=1 to len(laATI)
           aadd(laPUT,laATI[jj])
           aadd(laPUTV,laATI[jj])
       next jj

       for jj=1 to len(laINA)
           aadd(laPUTV,laINA[jj])
           aadd(laPUT,'INATIVO - '+laINA[jj])
       next jj

       WPut(faCOMBOS[ii,2]+'.option',laPUT)
       WPut(faCOMBOS[ii,2]+'.optionvalue',laPUTV)

   next ii
return(nil)



/*
* Function..: ctr_nf()
* Objetivo..: Faz controle de números de notas fiscais impressas
* Parâmetros: Nenhum
* Retorno...: Valor inteiro com Número da Nota Fiscal
*/
function ctr_nf()
  local lnNR_NF := 0 ,;
        lnii    := 0  as int
  local lhHANDLE
  if ! file('ctr_nf.lck')
     lhHANDLE := fcreate('ctr_nf.lck',2)
     fclose(lhHANDLE)
  endif
  lnII := 0
  do while .t.
     lnII ++
     if lnII > 10
        return(-1)
     endif
     lhHANDLE := fopen('ctr_nf.lck',2)
     if lhHANDLE = -1
        loop
     endif
     exit
  enddo
  lnII := 0
  do while flockf(lhHANDLE,2) != 0
     lnII ++
     if lnII > 10
        return(-1)
     endif
  enddo
  lnII := 0
  do while .t.
     lnII ++
     if lnII > 10
        return(-1)
     endif
     lnNR_NF := val(freadstr(lhHANDLE,9))+1
     fseek(lhHANDLE,0,0)
     fwrite(lhHANDLE,str(lnNR_NF,9))
     exit
  enddo
  lnII := 0
  do while flockf(lhHANDLE,0) != 0
     lnII ++
     if lnII > 10
        return(-1)
     endif
  enddo
  fclose(lhHANDLE)
return(lnNR_NF)

/*
* Function..: num_at(fcSEARCH,fcSTRING)
* Objetivo..: Contar a quantidade de ocorrencias de uma string em outra
* Parâmetros:
*   fcSEARCH: String a procurar
*   fcSTRING: String alvo da procura
* Retorno...: Número de ocorrencias de fcSEARCH em fcCSTRING
*/
function num_at(fcSEARCH,fcSTRING)
  local lnCOUNT := 0 as int
  do while at(fcSEARCH,fcSTRING) > 0
     fcSTRING := substr(fcSTRING,at(fcSEARCH,fcSTRING)+1)
     lnCOUNT++
  enddo
return(lnCOUNT)

/*
* Function..: make_psthead(fcNR_PASTA,fcTP_PASTA)
* Objetivo..: Monta HTML com cabeçalho das abas das Pastas.
* Parâmetros:
*   fcNR_PASTA: String com Número da Pasta
*   fcTP_PASTA: String com tipo da Pasta
* Retorno...: nenhum
*/
function make_psthead(fcNR_PASTA,fcTP_PASTA)
   local lcFIELD   := '' ,;
         lcTABLE   := '' ,;
         lcCONTENT := '' as string
   local laFIELDS      := {} ,;
         laRES         := {} ,;
         laPUT         := {} ,;
         laJOIN        := {} ,;
         laJOINS       := {} ,;
         laHEAD_FIELDS := {} ,;
         laAUX         := {} as array
   local lnPOS       := 0 ,;
         lnQUANT_COL := 0 ,;
         ii          := 0 ,;
         xx          := 0 as int
   local llSELECT  := .T. as logical // Inicia com Valor Verdadeiro
   local luPSTHEAD

   //Barra de Títulos
   laPUT := wmd_program(WSet('_USER_INTERFACE'))
   if len(laPUT) > 0
      WPut('TITLE','Pasta '+fcNR_PASTA+' - '+fcTP_PASTA+' - '+laPUT[6])
   endif

   luPSTHEAD := str2array(wDataGlobal('PSTHEAD'),'!&')
   if len(luPSTHEAD) == 2
      if luPSTHEAD[1] == alltrim(fcNR_PASTA)
         llSELECT := .f.
         lcCONTENT := luPSTHEAD[2]
      else
         llSELECT := .t.
      endif
   endif
   if llSELECT
      if db_select({'HEAD_FIELDS','QUANT_COL'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) ==-1
         error_sys('make_psthead:'+db_error())
      endif
      laRES := db_fetchrow()
      if len(laRES) > 0
         lnQUANT_COL := laRES[2] // Pega Quantidade de Colunas do pasta_config
         if lnQUANT_COL = 0
            lnQUANT_COL   := 1
         endif
         lcCONTENT := '<br><table border="0" cellpadding="0" cellspacing="1" align="center">'+CRLF
         lcCONTENT += '<tr><td colspan="'+str(lnQUANT_COL * 2)+'">'+CRLF
         lcCONTENT += '<input type="button" value="Localizar Pasta" class="wbutton" onclick="document.location.href='+DLAP+wic_action('wicaction/lst.pasta.html?FL_EXECSEL=Y')+DLAP+'">'+CRLF
//         lcCONTENT += '<input type="button" value="Nova Pasta" class="wbutton" onclick="document.location.href='+DLAP+wic_action('wicaction/mnt.pasta.html?action=new&TP_PASTA='+fcTP_PASTA)+DLAP+'">'+CRLF
         lcCONTENT += '<input type="button" value="Nova Pasta" class="wbutton" onclick="apagaframe();parent.document.location.href='+DLAP+wic_action('wicaction/mnt.pasta.html?action=new&TP_PASTA='+fcTP_PASTA)+DLAP+'">'+CRLF
         lcCONTENT += '</td></tr>'+CRLF
         if ! empty(laRES[1])
            laHEAD_FIELDS := str2array(laRES[1],',') // Lista de Campos a ser gerados código HTML
            laJOINS := {{2,'pasta_outraspartes','pasta_outraspartes.NR_PASTA=pasta.NR_PASTA'},;
                        {2,'pasta_andamento','pasta_andamento.NR_PASTA=pasta.NR_PASTA'},;
                        {2,'pasta_andamento','pasta_andamento.NR_PASTA=pasta.NR_PASTA'},;
                        {2,'pasta_andamento','pasta_andamento.NR_PASTA=pasta.NR_PASTA'},;
                        {2,'pasta_recurso','pasta_recurso.NR_PASTA=pasta.NR_PASTA'},;
                        {2,'correspondente','correspondente.CD_CORRESPONDENTE=pasta.CD_CORRESPONDENTE'},;
                        {2,'cobranca','cobranca.CD_COBRANCA=pasta.CD_COBRANCA'},;
                        {2,'grupo_economico','grupo_economico.CD_GRP_ECONOMICO=pasta.CD_GRP_ECONOMICO'},;
                        {2,'tabela_servico','tabela_servico.CD_TB_SERVICO=pasta.CD_TB_SERVICO'},;
                        {2,'tabela_honorario','tabela_honorario.CD_TB_HONORARIO=pasta.CD_TB_HONORARIO'},;
                        {2,'tabela_despesa','tabela_despesa.CD_TB_DESPESA=pasta.CD_TB_DESPESA'},;
                        {2,'indice_reajuste','indice_reajuste.CD_INDICE=pasta.CD_INDICE'},;
                        {2,'centrocusto','centrocusto.CD_CCUSTO=pasta.CD_CCUSTO'}}

            //Relacionamentos com as 'views' de pessoas
            laAUX := pstcips()  //Retorna todos os CIPS de pasta.
            for ii := 1 to len(laAUX)
               aadd(laJOINS,{2,'pasta_pfpj_'+alltrim(lower(substr(laAUX[ii],5))),'pasta_pfpj_'+alltrim(lower(substr(laAUX[ii],5)))+'.NR_PASTA=pasta.NR_PASTA'})
            next ii

            /*
            aadd(laJOINS,{2,'pasta_pfpj_empresa'                 ,'pasta_pfpj_empresa.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_protocolador'            ,'pasta_pfpj_protocolador.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_advogado_externo'        ,'pasta_pfpj_advogado_externo.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_escritorio'              ,'pasta_pfpj_escritorio.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_parte_contraria'         ,'pasta_pfpj_parte_contraria.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_segurado'                ,'pasta_pfpj_segurado.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_assistente_tecnico'      ,'pasta_pfpj_assistente_tecnico.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_oficial_justica'         ,'pasta_pfpj_oficial_justica.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_perito'                  ,'pasta_pfpj_perito.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_contratado'              ,'pasta_pfpj_contratado.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_contratante'             ,'pasta_pfpj_contratante.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_assistente_acusacao'     ,'pasta_pfpj_assistente_acusacao.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_advogado_interno'        ,'pasta_pfpj_advogado_interno.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_tecnicosinistro'         ,'pasta_pfpj_tecnicosinistro.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_filial'                  ,'pasta_pfpj_filial.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_gestor_interno'          ,'pasta_pfpj_gestor_interno.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_assitente_acusacao'      ,'pasta_pfpj_assitente_acusacao.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_autuado'                 ,'pasta_pfpj_autuado.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_autuante'                ,'pasta_pfpj_autuante.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_contrato_confidenc_para' ,'pasta_pfpj_contrato_confidenc_para.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_contrato_exclusiv_para'  ,'pasta_pfpj_contrato_exclusiv_para.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_cartorio'                ,'pasta_pfpj_cartorio.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_locador'                 ,'pasta_pfpj_locador.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_locatario'               ,'pasta_pfpj_locatario.NR_PASTA=pasta.NR_PASTA'})
            aadd(laJOINS,{2,'pasta_pfpj_devedor'                 ,'pasta_pfpj_devedor.NR_PASTA=pasta.NR_PASTA'})
            */

            /* Gera Lista de Campos para select */
            for ii:= 1 to len(laHEAD_FIELDS)
               if ! empty(alltrim(laHEAD_FIELDS[ii]))
                  lcFIELD := substr(laHEAD_FIELDS[ii],1, (at('.',laHEAD_FIELDS[ii])-1) )
                  lnPOS   := ascan(laJOINS,{ | xx | xx[2]==lcFIELD })
                  if lnPOS > 0 .or. lcFIELD == 'pasta'
                     aadd(laFIELDS,laHEAD_FIELDS[ii])
                  endif
               endif
            next ii

            /* Controle dinâmico de LEFT JOINS */
            for ii := 1 to len(laFIELDS)
               lcFIELD := substr(laFIELDS[ii],1, (at('.',laFIELDS[ii])-1) )
               lnPOS   := ascan(laJOINS,{ | xx | xx[2]==lcFIELD })
               if lnPOS > 0
                  lcTABLE := laJOINS[lnPOS,2]
                  if ascan(laJOIN,{ | xx | xx[2]==lcTABLE }) == 0
                     aadd(laJOIN,laJOINS[lnPOS])
                  endif
               endif

               if at('.CIP',laFIELDS[ii]) > 0
                   laFIELDS[ii] += ' as CIP_'+upper(substr(substr(laFIELDS[ii],1, at('.',laFIELDS[ii])-1 ), 12))
               endif
            next ii

            if db_select(laFIELDS,'pasta',laJOIN,{'pasta.NR_PASTA='+fcNR_PASTA}) == -1
               putError('make_psthead:'+db_error())
               error_sys('Existe uma Falha na configuração das Colunas do Cabeçalho.<br>Por favor, verifique a definição dos Campos.')
            endif
            laRES := db_fetchall()
            xx := 1 // Controla quantidade de Colunas por Linha
            ii := 1 // Controle do laço
            lcCONTENT += '<tr>'+CRLF
            do while ii <= len(laRES[1])
               if ! empty(alltrim(laRES[1,ii]))
                  lcCONTENT += '<td>'+CRLF
// Glauber 06/01/2015 - Conforme pasta 1052 do portal ocorrencias, não esta respeitando a redefinição de campos na função lblfscreen
// Estou fazendo uma gambiarra para contornar esta situação.
//                  lcCONTENT += '   '+lblfscreen(laRES[1,ii])+CRLF
                  lcCONTENT += '   '+nlblfscreen(laRES[1,ii])+CRLF
                  lcCONTENT += '</td>'+CRLF
                  lcCONTENT += '<td>'+CRLF
                  lcCONTENT += '   <input type="text" class="winputreadonly" value="'+alltrim(laRES[2,ii])+'" size="30" readonly>'+CRLF
                  lcCONTENT += '</td>'+CRLF
               else
                  lcCONTENT += '<td colspan="2"></td>'+CRLF
               endif
               if xx == lnQUANT_COL // Sempre que xx for 2, fecha <tr> e zera conteudo xx
                  lcCONTENT +='</tr>'+CRLF
                  lcCONTENT +='<tr>'+CRLF
                  xx := 0
               endif
               xx++
               ii ++
            enddo
            lcCONTENT += '</tr>'+CRLF
            lcCONTENT += '</table><br>'+CRLF
            wDataGlobal('PSTHEAD',array2str({fcNR_PASTA,lcCONTENT},'!&')) // Grava na variável Global.
         else
            lcCONTENT += '<tr><td><font color="red">Colunas de Cabeçalho não definidas</font></td></tr>'+CRLF
            lcCONTENT += '</table><br>'+CRLF
         endif
      else
         error_sys('make_psthead: Tipo de Pasta Inválido')
         return(.f.)
      endif
   endif
   wPut('PSTHEAD',lcCONTENT)
   wPut('NR_PASTA',fcNR_PASTA)
   wPut('TP_PASTA',fcTP_PASTA)
return(nil)

function gchklogin()
   local lcTIME     := '',;
         lcTIME_NOW := '',;
         lcTSTP     := '' as string
   local laRESULT   := {} as array

   lcTIME     := substr(time(),1,5)
   lcTIME_NOW := time()
   lcTIME_NOW := dtos(date())+substr(lcTIME_NOW,1,2)+substr(lcTIME_NOW,4,2)+substr(lcTIME_NOW,7,2)


   if wSet("_USER_INTERFACE") != "login.html"
      if wSet('FL_USER') = 'Y'
         error_sys("Access Control: Usuário Bloqueado!")
         return(.f.)
      endif
      if wSet('FL_PWD') = 'Y'
         error_sys("Access Control: Senha Bloqueada!")
         return(.f.)
      endif
      if wSet('DT_VALIDADE_PSW') < date()
         wPut('MENSCHANGEPASS','Senha expirada. Necessário cadastrar uma Nova.')
         wSet("_USER_INTERFACE","pass.change.html")
         return(.f.)
      endif
      if ! (str(dow(date()),1) $ wSet('PSW_DIASSEMANA'))
         error_sys("Access Control: Acesso não permitido para hoje!")
         return(.f.)
      endif
      if lcTIME < wSet('PSW_HR_INICIO') .or. lcTIME > wSet('PSW_HR_FIM')
         error_sys("Access Control: Acesso não permitido fora do horário definido!")
         return(.f.)
      endif

      // Glauber 27/05/2015 - Implementação do bloqueio por número de ip.

      if wSet('_AC_WIP') == 'ENABLE' .and. ! Empty(WSet('WIP'))
         if (wgetenv('REMOTE_ADDR') != WSet('WIP'))
            error_sys("Access Control: Acesso não permitido fora da rede de trabalho!")
            return(.f.)
         endif
//          wout('<br><b>REMOTE_ADDR:' + wgetenv('REMOTE_ADDR'))
//          wout('<br><b>WIP........:' + WSet('WIP'))
      endif

      if wSet('_NEWAC_TIMEOUT') == 'ENABLE' .and. ! Empty(WSet('WTIME_OUT'))


         if db_select({'WDATELAST','WTIMELAST'},'waccess',,{'WN_ACCESS = ' + alltrim(gnWN_ACS)}) = -1
            error_sys('Access Control: '+db_error())
         endif
         laRESULT := db_fetchall()

         if len(laRESULT) == 2
            aadd(laRESULT[1],'WTIME_OUT')
            aadd(laRESULT[2],WSet('WTIME_OUT'))
         endif

         lcTSTP :=  calctstp(datetime2tstp(db_fetchcolvalue(laRESULT,'WDATELAST',2),db_fetchcolvalue(laRESULT,'WTIMELAST',2)), time2val(db_fetchcolvalue(laRESULT,'WTIME_OUT',2)))

/*       wout('<br><b>WTIME_OUT:' + WSet('WTIME_OUT'))
         wout('<br><b>ID........:' + WDataURL('ID'))
         wout('<br><b>gnWN_ACS..:' + str(gnWN_ACS))
         wout('<br><b>lcTSTP....:' + lcTSTP)
         wout('<br><b>lcTIME_NOW:' + lcTIME_NOW)
*/
         if val(lcTIME_NOW) > val(lcTSTP)
            error_sys('Access Control: Session Expired')
         endif

/*
      WTIME_OUT:00:24:00
      ID........:XQOOPLOPMHNNOKLI
      gnWN_ACS..: 50211
      lcTSTP....:2015 05 28 10 22 29
      lcTIME_NOW:2015 05 28 10 00 05
*/ 
     endif
   endif
return(.t.)

/*
* Function..: cip2login(fcCIP)
* Objetivo..: Pesquisa um CIP em acuser
* Parâmetros:
*    fcCIP.: Número do CIP
* Retorno...: Retorna o login do respectivo CIP
*/
function cip2login(fcCIP)
   local laRESULT := {} as array
   local lcLOGIN := '' as string
   if valtype(fcCIP) == 'U' .or. empty(fcCIP)
      puterror('cip2login: CIP não definido')
      return(lcLOGIN)
   endif
   if db_select({'LOGIN'},'acuser',,{'CIP='+DLAP+fcCIP+DLAP}) == -1
      puterror('cip2login: '+db_error())
      return(lcLOGIN)
   endif
   laRESULT := db_fetchrow()
   if len(laRESULT) > 0
      lcLOGIN := alltrim(laRESULT[1])
   else
      puterror('cip2login: Login não definido para o CIP '+fcCIP)
   endif
return(lcLOGIN)

/*
* Function..: psab_logs()
* Objetivo..: Gravacao do historico de alterações da Pasta
* Parâmetros:
*    faSAVE.....: array bidimensional com os dados a serem comparados
*    fcTABLE....: Tabela alvo da comparação
*    fcWHERE....: Condição where para pesquisa na tabela alvo
*    fcLOCATION.: Local da alteração. Ex: Informações principais, Seguro, Peças processuais, etc...
*    fcNR_PASTA.: Número da pasta
*
* Retorno: boolean
*    .T. em caso de gravação bem sucedida
*    .F. em caso de falha
*/
function psab_logs(faSAVE,fcTABLE,fcWHERE,fcNR_PASTA,fcLOCATION)
   local laDIFFROW   := {} ,;
         laFLD_HIST  := {} ,;
         laSAVE_HIST := {} ,;
         laSAVE_AUX  := {} as array
   // Gravacao do historico de alterações da Pasta (Informações Principais) ------------------------------------------------------------

   local ii := 0 as int
//   debug2(fasave)
//   debug2(fctable)
//   debug2(fcwhere)
   laDIFFROW := db_diffrow(faSAVE,fcTABLE,fcWHERE)

   if len(laDIFFROW) > 0
      laFLD_HIST := structtable(WSet("DB_ACTIVE"),'pasta_log_altera',1,'A')
      aadd(laSAVE_HIST,laFLD_HIST)
      for ii := 1 to len(laDIFFROW)
          for iiC := 1 to len(laFLD_HIST)
              do case
                 case laFLD_HIST[iiC] == 'NR_PASTA'
                    aadd(laSAVE_AUX,fcNR_PASTA)
                 case laFLD_HIST[iiC] == 'NR_CONTROLE'
                    aadd(laSAVE_AUX,0)
                 case laFLD_HIST[iiC] == 'LOGIN'
                    aadd(laSAVE_AUX,WSet('LOGIN'))
                 case laFLD_HIST[iiC] == 'WFIELD'
                    aadd(laSAVE_AUX,laDIFFROW[ii,1])
                 case laFLD_HIST[iiC] == 'CONTEUDO_ANTERIOR'
                    if valtype(laDIFFROW[ii,2]) == 'D'
                       aadd(laSAVE_AUX,dtoc(laDIFFROW[ii,2]))
                    elseif valtype(laDIFFROW[ii,2]) == 'N'
                       //aadd(laSAVE_AUX,str(laDIFFROW[ii,2]))
                       aadd(laSAVE_AUX,wpictrans(laDIFFROW[ii,1],laDIFFROW[ii,2]))
                    else
                       aadd(laSAVE_AUX,laDIFFROW[ii,2])
                    endif
                 case laFLD_HIST[iiC] == 'CONTEUDO_NOVO'
                    if valtype(laDIFFROW[ii,2]) == 'D'
                       aadd(laSAVE_AUX,dtoc(laDIFFROW[ii,3]))
                    elseif valtype(laDIFFROW[ii,2]) == 'N'
//                       aadd(laSAVE_AUX,str(laDIFFROW[ii,3]))
                       aadd(laSAVE_AUX,wpictrans(laDIFFROW[ii,1],laDIFFROW[ii,3]))
/*
verificar a funçao é utilizada na unimed 
*/
                    else
                       aadd(laSAVE_AUX,laDIFFROW[ii,3])
                    endif
                 case laFLD_HIST[iiC] == 'DT_ALTERACAO'
                    aadd(laSAVE_AUX,dtos(date()))
                 case laFLD_HIST[iiC] == 'HR_ALTERACAO'
                    aadd(laSAVE_AUX,time())
                 case laFLD_HIST[iiC] == 'LOCAL_ALTERACAO'
                    aadd(laSAVE_AUX,fcLOCATION)
                 otherwise
                    aadd(laSAVE_AUX,nil)
              endcase
          next iiC
          aadd(laSAVE_HIST,laSAVE_AUX)
          laSAVE_AUX := {}
      next ii

      if db_insert(laSAVE_HIST,'pasta_log_altera') == -1
         puterror('psab_logs: Log não gravado - '+db_error())
         return(.f.)
      endif
   endif
return(.t.)


/*
* Function..: psab_logdel()
* Objetivo..: Gravacao no log de registro excluídos da tabela [pasta] e tabelas filhas
* Parâmetros:
*    fcNR_PASTA.: Número da pasta
*    fcKEY......: Ultimo campo chave da tabela. É usado como idenficador do registro excluído
*    fuVALUE....: Valor/conteúdo do ultimo campo chave
*    fcDATA_DEL.: Informação do que foi excluído. Ex: 'Pasta excluida', 'Andamento excluido'. Caso não seja enviado
*                 será gravado por padrão a string 'Registro excluído'
*    fcLOCATION.: Local onde ocorreu a exclusão. Ex: Informações principais, Seguro, Peças processuais, etc...
*
* Retorno: boolean
*    .T. em caso de gravação bem sucedida
*    .F. em caso de falha
*/
function psab_logdel(fcNR_PASTA,fcKEY,fuVALUE,fcDATA_DEL,fcLOCATION)
   local laFLD_HIST  := {} ,;
         laSAVE_HIST := {} ,;
         laSAVE_AUX  := {} as array

   local ii := 0 as int

   if valtype(fcNR_PASTA) == 'U' .or. empty(fcNR_PASTA)
      puterror('psab_logdel: Número da Pasta não informado')
      return(.f.)
   endif
   if valtype(fcKEY) == 'U' .or. empty(fcKEY)
      puterror('psab_logdel: Chave não informada')
      return(.f.)
   endif
   if valtype(fuVALUE) == 'U' .or. empty(fuVALUE)
      puterror('psab_logdel: Valor da chave não informado')
      return(.f.)
   endif
   if valtype(fcLOCATION) == 'U' .or. empty(fcLOCATION)
      puterror('psab_logdel: Local da exclusão não informado')
      return(.f.)
   endif

   do case
      case valtype(fuVALUE) == 'D'
         fuVALUE := dtoc(fuVALUE)
      case valtype(fuVALUE) == 'N' .or. valtype(fuVALUE) == 'N'
         fuVALUE := alltrim(str(fuVALUE))
   endcase

   laFLD_HIST := structtable(WSet("DB_ACTIVE"),'pasta_log_altera',1,'A')
   aadd(laSAVE_HIST,laFLD_HIST)
   for iiC := 1 to len(laFLD_HIST)
       do case
          case laFLD_HIST[iiC] == 'NR_PASTA'
             aadd(laSAVE_AUX,fcNR_PASTA)
          case laFLD_HIST[iiC] == 'NR_CONTROLE'
             aadd(laSAVE_AUX,0)
          case laFLD_HIST[iiC] == 'LOGIN'
             aadd(laSAVE_AUX,WSet('LOGIN'))
          case laFLD_HIST[iiC] == 'WFIELD'
             aadd(laSAVE_AUX,fcKEY)
          case laFLD_HIST[iiC] == 'CONTEUDO_ANTERIOR'
             aadd(laSAVE_AUX,fuVALUE)
          case laFLD_HIST[iiC] == 'CONTEUDO_NOVO'
             if valtype(fcDATA_DEL) == 'U'
                aadd(laSAVE_AUX,'Registro Excluído')
             else
                aadd(laSAVE_AUX,fcDATA_DEL)
             endif
          case laFLD_HIST[iiC] == 'DT_ALTERACAO'
             aadd(laSAVE_AUX,dtos(date()))
          case laFLD_HIST[iiC] == 'HR_ALTERACAO'
             aadd(laSAVE_AUX,time())
          case laFLD_HIST[iiC] == 'LOCAL_ALTERACAO'
             aadd(laSAVE_AUX,fcLOCATION)
          otherwise
             aadd(laSAVE_AUX,nil)
       endcase
   next iiC
   aadd(laSAVE_HIST,laSAVE_AUX)
   laSAVE_AUX := {}
   if db_insert(laSAVE_HIST,'pasta_log_altera') == -1
      puterror('psab_logdel: Log não gravado - '+db_error())
      return(.f.)
   endif
return(.t.)

/*
* Function..: pfpj_logs()
* Objetivo..: Gravacao do historico de alterações de Pessoas
* Parâmetros:
*    faSAVE........: array bidimensional com os dados a serem comparados
*    fcTABLE.......: Tabela alvo da comparação
*    fcWHERE.......: Condição where para pesquisa na tabela alvo
*    fcLOCATION....: Local da alteração. Ex: Informações principais, Seguro, Peças processuais, etc...
*    fcNR_CONTROLE.: Número de Controle da Pessoa
*
* Retorno: boolean
*    .T. em caso de gravação bem sucedida
*    .F. em caso de falha
*/
function pfpj_logs(faSAVE,fcTABLE,fcWHERE,fcNR_CONTROLE,fcLOCATION)
   local laDIFFROW   := {} ,;
         laFLD_HIST  := {} ,;
         laSAVE_HIST := {} ,;
         laSAVE_AUX  := {} as array
   // Gravacao do historico de alterações da Pasta (Informações Principais) ------------------------------------------------------------
   laDIFFROW := db_diffrow(faSAVE,fcTABLE,fcWHERE)

   if len(laDIFFROW) > 0
      laFLD_HIST := structtable(WSet("DB_ACTIVE"),'pfpj_log_altera',1,'A')
      aadd(laSAVE_HIST,laFLD_HIST)
      for ii := 1 to len(laDIFFROW)
          for iiC := 1 to len(laFLD_HIST)
              do case
                 case laFLD_HIST[iiC] == 'NR_CONTROLE'
                    aadd(laSAVE_AUX,fcNR_CONTROLE)
                 case laFLD_HIST[iiC] == 'NR_SEQUENCIA'
                    aadd(laSAVE_AUX,0)
                 case laFLD_HIST[iiC] == 'LOGIN'
                    aadd(laSAVE_AUX,WSet('LOGIN'))
                 case laFLD_HIST[iiC] == 'WFIELD'
                    aadd(laSAVE_AUX,laDIFFROW[ii,1])
                 case laFLD_HIST[iiC] == 'CONTEUDO_ANTERIOR'
                    if valtype(laDIFFROW[ii,2]) == 'D'
                       aadd(laSAVE_AUX,dtoc(laDIFFROW[ii,2]))
                    elseif valtype(laDIFFROW[ii,2]) == 'N'
                       aadd(laSAVE_AUX,str(laDIFFROW[ii,2]))
                    else
                       aadd(laSAVE_AUX,laDIFFROW[ii,2])
                    endif
                 case laFLD_HIST[iiC] == 'CONTEUDO_NOVO'
                    if valtype(laDIFFROW[ii,2]) == 'D'
                       aadd(laSAVE_AUX,dtoc(laDIFFROW[ii,3]))
                    elseif valtype(laDIFFROW[ii,2]) == 'N'
                       aadd(laSAVE_AUX,str(laDIFFROW[ii,3]))
                    else
                       aadd(laSAVE_AUX,laDIFFROW[ii,3])
                    endif
                 case laFLD_HIST[iiC] == 'DT_ALTERACAO'
                    aadd(laSAVE_AUX,dtos(date()))
                 case laFLD_HIST[iiC] == 'HR_ALTERACAO'
                    aadd(laSAVE_AUX,time())
                 case laFLD_HIST[iiC] == 'LOCAL_ALTERACAO'
                    aadd(laSAVE_AUX,fcLOCATION)
                 otherwise
                    aadd(laSAVE_AUX,nil)
              endcase
          next iiC
          aadd(laSAVE_HIST,laSAVE_AUX)
          laSAVE_AUX := {}
      next ii
      if db_insert(laSAVE_HIST,'pfpj_log_altera') == -1
         puterror('pfpj_logs: Log não gravado - '+db_error())
         return(.f.)
      endif
   endif
return(.t.)

/*
* Function..: pfpj_logdel()
* Objetivo..: Gravacao no log de registro excluídos da tabela de Pessoas e filhas
* Parâmetros:
*    fcNR_CONTROLE.: Número de Controle da Pessoa
*    fcKEY.........: Ultimo campo chave da tabela. É usado como idenficador do registro excluído
*    fuVALUE.......: Valor/conteúdo do ultimo campo chave
*    fcDATA_DEL....: Informação do que foi excluído. Ex: 'Pasta excluida', 'Andamento excluido'. Caso não seja enviado
*                    será gravado por padrão a string 'Registro excluído'
*    fcLOCATION....: Local onde ocorreu a exclusão. Ex: Informações principais, Seguro, Peças processuais, etc...
*
* Retorno: boolean
*    .T. em caso de gravação bem sucedida
*    .F. em caso de falha
*/
function pfpj_logdel(fcNR_CONTROLE,fcKEY,fuVALUE,fcDATA_DEL,fcLOCATION)
   local laFLD_HIST  := {} ,;
         laSAVE_HIST := {} ,;
         laSAVE_AUX  := {} as array

   local ii := 0 as int

   if valtype(fcNR_CONTROLE) == 'U' .or. empty(fcNR_CONTROLE)
      puterror('pfpj_logdel: Número da Pasta não informado')
      return(.f.)
   endif
   if valtype(fcKEY) == 'U' .or. empty(fcKEY)
      puterror('pfpj_logdel: Chave não informada')
      return(.f.)
   endif
   if valtype(fuVALUE) == 'U' .or. empty(fuVALUE)
      puterror('pfpj_logdel: Valor da chave não informado')
      return(.f.)
   endif
   if valtype(fcLOCATION) == 'U' .or. empty(fcLOCATION)
      puterror('pfpj_logdel: Local da exclusão não informado')
      return(.f.)
   endif

   do case
      case valtype(fuVALUE) == 'D'
         fuVALUE := dtoc(fuVALUE)
      case valtype(fuVALUE) == 'N' .or. valtype(fuVALUE) == 'N'
         fuVALUE := alltrim(str(fuVALUE))
   endcase

   laFLD_HIST := structtable(WSet("DB_ACTIVE"),'pfpj_log_altera',1,'A')
   aadd(laSAVE_HIST,laFLD_HIST)
   for iiC := 1 to len(laFLD_HIST)
       do case
          case laFLD_HIST[iiC] == 'NR_CONTROLE'
             aadd(laSAVE_AUX,fcNR_CONTROLE)
          case laFLD_HIST[iiC] == 'NR_SEQUENCIA'
             aadd(laSAVE_AUX,0)
          case laFLD_HIST[iiC] == 'LOGIN'
             aadd(laSAVE_AUX,WSet('LOGIN'))
          case laFLD_HIST[iiC] == 'WFIELD'
             aadd(laSAVE_AUX,fcKEY)
          case laFLD_HIST[iiC] == 'CONTEUDO_ANTERIOR'
             aadd(laSAVE_AUX,fuVALUE)
          case laFLD_HIST[iiC] == 'CONTEUDO_NOVO'
             if valtype(fcDATA_DEL) == 'U'
                aadd(laSAVE_AUX,'Registro Excluído')
             else
                aadd(laSAVE_AUX,fcDATA_DEL)
             endif
          case laFLD_HIST[iiC] == 'DT_ALTERACAO'
             aadd(laSAVE_AUX,dtos(date()))
          case laFLD_HIST[iiC] == 'HR_ALTERACAO'
             aadd(laSAVE_AUX,time())
          case laFLD_HIST[iiC] == 'LOCAL_ALTERACAO'
             aadd(laSAVE_AUX,fcLOCATION)
          otherwise
             aadd(laSAVE_AUX,nil)
       endcase
   next iiC
   aadd(laSAVE_HIST,laSAVE_AUX)
   laSAVE_AUX := {}
   if db_insert(laSAVE_HIST,'pfpj_log_altera') == -1
      puterror('pfpj_logdel: Log não gravado - '+db_error())
      return(.f.)
   endif
return(.t.)

/*
* Data Criação: 07.07.2005 - Eduardo
* Function.....: pedproc_contingencia(fnNR_PASTA,fcOBJETO,fnPC_RISCO)
* Objetivo.....: Sincronizar tabela [pasta_contingencia] com o campo pasta.OBJETO
* Parâmetros:
*    fnNR_PASTA.: Número da pasta
*    fcOBJETO...: Objetos da Pasta (pasta.OBJETO)
*    fnPC_RISCO.: Risco da Pasta (pasta.PC_RISCO)
*
* Retorno: Nenhum
*/
function pedproc_contingencia(fnNR_PASTA,fcOBJETO,fnPC_RISCO)
   local lcPEDIDO_PROCESSO := '' as string
   local laRESULT          := {} ,;
         laPEDIDO_PROCESSO := {} ,;
         laSAVE            := {} as array

   local ii := 0 as int

   /* Verificando se os parâmetros fcOBJETO e fnPC_RISCO existem,
      Caso não, pega da tabela pasta. */
   if valtype(fcOBJETO) == 'U' .or. valtype(fnPC_RISCO) == 'U'
      if db_select({'OBJETO','PC_RISCO'},'pasta',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
         error_sys('pedproc_contingencia('+alltrim(str(procline()))+'): '+db_error())
      endif
      laRESULT := db_fetchrow()
      if len(laRESULT) > 0
         fcOBJETO   := laRESULT[1]
         fnPC_RISCO := laRESULT[2]
      else
         error_sys('pedproc_contingencia('+alltrim(str(procline()))+'): Pasta não encontrada.')
      endif
   endif

   fcOBJETO := strtran(fcOBJETO,DLAP,'`')
   fcOBJETO := strtran(fcOBJETO,DLMT,'`')

   /* Selecionando dados da tabela pasta_contingencia. */
   if db_select({'PEDIDO_PROCESSO'},'pasta_contingencia',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
      error_sys('pedproc_contingencia('+alltrim(str(procline()))+'): '+db_error())
   endif
   laRESULT := db_fetchall()

   /* Sincronizando a tabela pasta_contingencia com pasta */
   if ! empty(alltrim(fcOBJETO))
      laPEDIDO_PROCESSO := str2array(fcOBJETO,',')
      if len(laPEDIDO_PROCESSO) > 0
         for ii := 1 to len(laPEDIDO_PROCESSO)
            laPEDIDO_PROCESSO[ii] := alltrim(strtran(laPEDIDO_PROCESSO[ii],CRLF))
         next ii
         laSAVE := {{'NR_PASTA','PEDIDO_PROCESSO','VL_PEDIDO','VL_RISCO','PC_RISCO'}}
         for ii := 1 to len(laPEDIDO_PROCESSO)
            lcPEDIDO_PROCESSO := alltrim(laPEDIDO_PROCESSO[ii])
            if len(lcPEDIDO_PROCESSO) > 0
               if ascan(laSAVE,{| i | alltrim(i[2])==lcPEDIDO_PROCESSO }) == 0
                  if ascan(laRESULT,{| x | alltrim(x[1]) == lcPEDIDO_PROCESSO}) == 0
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO,0,0,fnPC_RISCO})
                  endif
               endif
            endif
         next ii
      endif
   endif

   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
         lcPEDIDO_PROCESSO := alltrim(strtran(laRESULT[ii,db_fetchncol(laRESULT,'PEDIDO_PROCESSO')],CRLF))
         if ascan(laPEDIDO_PROCESSO,lcPEDIDO_PROCESSO) == 0
            if db_delete('pasta_contingencia','NR_PASTA='+str(fnNR_PASTA)+' and PEDIDO_PROCESSO='+DLAP+lcPEDIDO_PROCESSO+DLAP) == -1
               error_sys('pedproc_contingencia('+alltrim(str(procline()))+'): '+db_error())
            endif
         endif
      next ii
   endif
   if len(laSAVE) > 1
      if db_insert(laSAVE,'pasta_contingencia') == -1
         error_sys('pedproc_contingencia('+alltrim(str(procline()))+'): '+db_error())
      endif
   endif
return(nil)

/*
* Data Criação: 11.07.2005 - Eduardo
* Function.....: pedproc_resultado(fnNR_PASTA,fcOBJETO)
* Objetivo.....: Sincronizar tabela [pasta_resultado_pedidos] com o campo pasta.OBJETO
* Parâmetros:
*    fnNR_PASTA.: Número da pasta
*    fcOBJETO...: Objetos da Pasta (pasta.OBJETO)
*
* Retorno: Nenhum
*/
function pedproc_resultado(fnNR_PASTA,fcOBJETO)
   local lcPEDIDO_PROCESSO := '' as string
   local laRESULT          := {} ,;
         laPEDIDO_PROCESSO := {} ,;
         laSAVE            := {} as array

   local ii := 0 as int

   /* Verificando se os parâmetros fcOBJETO e fnPC_RISCO existem,
      Caso não, pega da tabela pasta. */
   if valtype(fcOBJETO) == 'U'
      if db_select({'OBJETO'},'pasta',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
         error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
      endif
      laRESULT := db_fetchrow()
      if len(laRESULT) > 0
         fcOBJETO   := laRESULT[1]
      else
         error_sys('pedproc_resultado('+alltrim(str(procline()))+'): Pasta não encontrada.')
      endif
   endif

   fcOBJETO := strtran(fcOBJETO,DLAP,'`')
   fcOBJETO := strtran(fcOBJETO,DLMT,'`')

   /* Selecionando dados da tabela pasta_resultado_pedidos. */
   if db_select({'distinct PEDIDO_PROCESSO'},'pasta_resultado_pedidos',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
      error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
   endif
   laRESULT := db_fetchall()

   /* Sincronizando a tabela pasta_resultado_pedidos com pasta */
   if ! empty(alltrim(fcOBJETO))
      laPEDIDO_PROCESSO := str2array(fcOBJETO,',')
      if len(laPEDIDO_PROCESSO) > 0
         for ii := 1 to len(laPEDIDO_PROCESSO)
            laPEDIDO_PROCESSO[ii] := alltrim(strtran(laPEDIDO_PROCESSO[ii],CRLF))
         next ii

         laSAVE := {{'NR_PASTA','PEDIDO_PROCESSO','NR_INSTANCIA','FL_RESULTADO_PEDIDO','VL_RESULTADO'}}
         for ii := 1 to len(laPEDIDO_PROCESSO)
            lcPEDIDO_PROCESSO := alltrim(laPEDIDO_PROCESSO[ii])
            if len(lcPEDIDO_PROCESSO) > 0
               if ascan(laSAVE, {| i | alltrim(i[2]) == lcPEDIDO_PROCESSO}) == 0
                  if ascan(laRESULT,{| x | alltrim(x[1]) == lcPEDIDO_PROCESSO}) == 0
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO,1,'',0})
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO,2,'',0})
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO,3,'',0})
                  endif
               endif
            endif
         next ii
      endif
   endif

   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
         lcPEDIDO_PROCESSO := alltrim(strtran(laRESULT[ii,db_fetchncol(laRESULT,'PEDIDO_PROCESSO')],CRLF))
         if ascan(laPEDIDO_PROCESSO,lcPEDIDO_PROCESSO) == 0
            if db_delete('pasta_resultado_pedidos','NR_PASTA='+str(fnNR_PASTA)+' and PEDIDO_PROCESSO='+DLAP+lcPEDIDO_PROCESSO+DLAP) == -1
               error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
            endif
         endif
      next ii
   endif
   if len(laSAVE) > 1
      if db_insert(laSAVE,'pasta_resultado_pedidos') == -1
         error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
      endif
   endif
return(nil)

/*
* Data Criação: 01.02.2006 - Eduardo
* Function.....: pedproc_itens(fnNR_PASTA,fcOBJETO)
* Objetivo.....: Sincronizar tabela [pasta_itens_contrato] com o campo pasta.OBJETO
* Parâmetros:
*    fnNR_PASTA.: Número da pasta
*    fcOBJETO...: Objetos da Pasta (pasta.OBJETO)
*
* Retorno: Nenhum
*/
function pedproc_itens(fnNR_PASTA,fcOBJETO)
   local lcPEDIDO_PROCESSO := '' as string
   local laRESULT          := {} ,;
         laPEDIDO_PROCESSO := {} ,;
         laSAVE            := {} as array

   local ii := 0 as int

   /* Verificando se os parâmetros fcOBJETO existe,
      Caso não, pega da tabela pasta. */
   if valtype(fcOBJETO) == 'U'
      if db_select({'OBJETO'},'pasta',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
         error_sys('pedproc_itens('+alltrim(str(procline()))+'): '+db_error())
      endif
      laRESULT := db_fetchrow()
      if len(laRESULT) > 0
         fcOBJETO   := laRESULT[1]
      else
         error_sys('pedproc_itens('+alltrim(str(procline()))+'): Pasta não encontrada.')
      endif
   endif

   fcOBJETO := strtran(fcOBJETO,DLAP,'`')
   fcOBJETO := strtran(fcOBJETO,DLMT,'`')

   /* Selecionando dados da tabela pasta_itens_contrato. */
   if db_select({'distinct PEDIDO_PROCESSO'},'pasta_itens_contrato',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
      error_sys('pedproc_itens('+alltrim(str(procline()))+'): '+db_error())
   endif
   laRESULT := db_fetchall()

   /* Sincronizando a tabela pasta_itens_contrato com pasta */
   if ! empty(alltrim(fcOBJETO))
      laPEDIDO_PROCESSO := str2array(fcOBJETO,',')
      if len(laPEDIDO_PROCESSO) > 0
         for ii := 1 to len(laPEDIDO_PROCESSO)
            laPEDIDO_PROCESSO[ii] := alltrim(laPEDIDO_PROCESSO[ii])
         next ii

         laSAVE := {{'NR_PASTA','PEDIDO_PROCESSO'}}
         for ii := 1 to len(laPEDIDO_PROCESSO)
            lcPEDIDO_PROCESSO := alltrim(laPEDIDO_PROCESSO[ii])
            if len(lcPEDIDO_PROCESSO) > 0
               if ascan(laSAVE, {| i | alltrim(i[2]) == lcPEDIDO_PROCESSO}) == 0
                  if ascan(laRESULT,{| x | alltrim(x[1]) == lcPEDIDO_PROCESSO}) == 0
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO})
                  endif
               endif
            endif
         next ii
      endif
   endif

   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
         lcPEDIDO_PROCESSO := alltrim(laRESULT[ii,db_fetchncol(laRESULT,'PEDIDO_PROCESSO')])
         if ascan(laPEDIDO_PROCESSO,lcPEDIDO_PROCESSO) == 0
            if db_delete('pasta_itens_contrato','NR_PASTA='+str(fnNR_PASTA)+' and PEDIDO_PROCESSO='+DLAP+lcPEDIDO_PROCESSO+DLAP) == -1
               error_sys('pedproc_itens('+alltrim(str(procline()))+'): '+db_error())
            endif
         endif
      next ii
   endif
   if len(laSAVE) > 1
      if db_insert(laSAVE,'pasta_itens_contrato') == -1
         error_sys('pedproc_itens('+alltrim(str(procline()))+'): '+db_error())
      endif
   endif
return(nil)

/*
* Data Criação: 11.07.2005 - Eduardo
* Function.....: pedproc_sin_resultado(fnNR_PASTA,fcTP_PASTA)
* Objetivo.....: Sincronizar tabela [pasta_resultado_pedidos_sinistro] com a tabela [pasta_pedidos]
* Parâmetros:
*    fnNR_PASTA.: Número da pasta
*    fcTP_PASTA.: Tipo da Pasta
*
* Retorno: Nenhum
*/
function pedproc_sin_resultado(fnNR_PASTA,fcTP_PASTA)
   local laRESULT          := {} ,;
         laPEDIDO_PROCESSO := {} ,;
         laUPDATE          := {} ,;
         laSAVE            := {} as array

   local ii := 0 as int

   /* Selecionando dados da tabela pasta_pedidos. */
   if db_select({'NR_PASTA',;
                 'NR_CONTROLE',;
                 'PEDIDO_PROCESSO',;
                 'NR_CONTROLE_SEGURO'},;
                 'pasta_pedidos',;
                 {{0,'pasta_objeto','pasta_objeto.OBJETO=pasta_pedidos.PEDIDO_PROCESSO'}},;
                 {'pasta_pedidos.NR_PASTA='+alltrim(str(fnNR_PASTA))+' and pasta_objeto.TP_PASTA = '+DLAP+fcTP_PASTA+DLAP+' and pasta_objeto.FL_VISIVEL ='+DLAP+'W'+DLAP}) == -1
      error_sys(db_error())
   endif
   laPEDIDO_PROCESSO := db_fetchall()

   /* Selecionando pedidos do resultado */
   if db_select({'NR_PASTA',;
                 'NR_CONTROLE',;
                 'NR_INSTANCIA'},'pasta_resultado_pedidos_sinistro',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   /* Sincronizando a tabela pasta_resultado_pedidos com pasta */
   if len(laPEDIDO_PROCESSO) > 1
      laSAVE := {{'NR_PASTA','NR_CONTROLE','NR_INSTANCIA','PEDIDO_PROCESSO','NR_CONTROLE_SEGURO'}}
      laUPDATE := {{'NR_PASTA','NR_CONTROLE','NR_CONTROLE_SEGURO'}}
      for ii := 2 to len(laPEDIDO_PROCESSO)
         lcNR_CONTROLE := alltrim(str(laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'NR_CONTROLE')]))
         /*
             Glauber 10/06/2010: Quando é informado um numero de seguro na aba pedidos, não esta sincronizando  na aba resultado.
             
         */
         if ascan(laRESULT, {| i | alltrim(i[2]) == lcNR_CONTROLE}) == 0

            aadd(laSAVE,{fnNR_PASTA,;
                         val(lcNR_CONTROLE),;
                         1,;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'PEDIDO_PROCESSO')],;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'NR_CONTROLE_SEGURO')]})

            aadd(laSAVE,{fnNR_PASTA,;
                         val(lcNR_CONTROLE),;
                         2,;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'PEDIDO_PROCESSO')],;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'NR_CONTROLE_SEGURO')]})

            aadd(laSAVE,{fnNR_PASTA,;
                         val(lcNR_CONTROLE),;
                         3,;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'PEDIDO_PROCESSO')],;
                         laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'NR_CONTROLE_SEGURO')]})
         else  // Caso exista, fazer o sincronismo do número do seguro
              //laUPDATE := {{'NR_PASTA','NR_CONTROLE','NR_CONTROLE_SEGURO'}}
              aadd(laUPDATE,{fnNR_PASTA,val(lcNR_CONTROLE),laPEDIDO_PROCESSO[ii,db_fetchncol(laPEDIDO_PROCESSO,'NR_CONTROLE_SEGURO')]})
         endif
      next ii

   endif

   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
         lcNR_CONTROLE := alltrim(str(laRESULT[ii,db_fetchncol(laRESULT,'NR_CONTROLE')]))
         if ascan(laPEDIDO_PROCESSO,{| x | alltrim(x[2]) == lcNR_CONTROLE}) == 0         
            if db_delete('pasta_resultado_pedidos_sinistro','NR_PASTA='+str(fnNR_PASTA)+' and NR_CONTROLE='+DLAP+lcNR_CONTROLE+DLAP) == -1
               error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
            endif
         endif
      next ii
   endif
   if len(laSAVE) > 1
      if db_insert(laSAVE,'pasta_resultado_pedidos_sinistro') == -1
         error_sys(db_error())
      endif
   endif
   // laUPDATE := {{'NR_PASTA','NR_CONTROLE','NR_CONTROLE_SEGURO'}}
   // Sincronizando alterações no nr_controle_seguro
   if len(laUPDATE) > 1
      for ii := 2 to len(laUPDATE)
          if db_replace({{'NR_CONTROLE_SEGURO'},{laUPDATE[ii,3]}},'pasta_resultado_pedidos_sinistro',{'NR_PASTA='+str(laUPDATE[ii,1])+' and NR_CONTROLE='+DLAP+str(laUPDATE[ii,2])+DLAP}) == -1
             error_sys('pedproc_resultado('+alltrim(str(procline()))+'): '+db_error())
          endif
          
      next ii 
   endif
return(nil)


/*
* Data Criação: 25.07.2006 - Eduardo
* Function.....: pedproc_valor(fnNR_PASTA,fcOBJETO)
* Objetivo.....: Sincronizar tabela [pasta_valor_pedidos] com o campo pasta.OBJETO
* Parâmetros:
*    fnNR_PASTA.: Número da pasta
*    fcOBJETO...: Objetos da Pasta (pasta.OBJETO)
*
* Retorno: Nenhum
*/
function pedproc_valor(fnNR_PASTA,fcOBJETO)
   local lcPEDIDO_PROCESSO := '' as string
   local laRESULT          := {} ,;
         laPEDIDO_PROCESSO := {} ,;
         laSAVE            := {} as array

   local ii := 0 as int

   /* Verificando se o parâmetro fcOBJETO existe. Caso não, pega da tabela pasta. */
   if valtype(fcOBJETO) == 'U' .or. valtype(fnPC_RISCO) == 'U'
      if db_select({'OBJETO'},'pasta',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
         error_sys('pedproc_valor('+alltrim(str(procline()))+'): '+db_error())
      endif
      laRESULT := db_fetchrow()
      if len(laRESULT) > 0
         fcOBJETO   := laRESULT[1]
      else
         error_sys('pedproc_valor('+alltrim(str(procline()))+'): Pasta não encontrada.')
      endif
   endif

   fcOBJETO := strtran(fcOBJETO,DLAP,'`')
   fcOBJETO := strtran(fcOBJETO,DLMT,'`')

   /* Selecionando dados da tabela pasta_valor_pedidos. */
   if db_select({'PEDIDO_PROCESSO'},'pasta_valor_pedidos',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
      error_sys('pedproc_valor('+alltrim(str(procline()))+'): '+db_error())
   endif
   laRESULT := db_fetchall()

   /* Sincronizando a tabela pasta_valor_pedidos com pasta */
   if ! empty(alltrim(fcOBJETO))
      laPEDIDO_PROCESSO := str2array(fcOBJETO,',')
      if len(laPEDIDO_PROCESSO) > 0
         for ii := 1 to len(laPEDIDO_PROCESSO)
            laPEDIDO_PROCESSO[ii] := alltrim(strtran(laPEDIDO_PROCESSO[ii],CRLF))
         next ii
         laSAVE := {{'NR_PASTA','PEDIDO_PROCESSO','DT_RISCO','DT_RISCO2'}}
         for ii := 1 to len(laPEDIDO_PROCESSO)
            lcPEDIDO_PROCESSO := alltrim(laPEDIDO_PROCESSO[ii])
            if len(lcPEDIDO_PROCESSO) > 0 .and. (substr(lcPEDIDO_PROCESSO,1,len(lcPEDIDO_PROCESSO))<> CRLF)
               if ascan(laSAVE,{| i | alltrim(i[2])==lcPEDIDO_PROCESSO }) == 0
                  if ascan(laRESULT,{| x | alltrim(x[1]) == lcPEDIDO_PROCESSO}) == 0
                     aadd(laSAVE,{fnNR_PASTA,lcPEDIDO_PROCESSO, date(), date()})
                  endif
               endif
            endif
         next ii
      endif
   endif

   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
          lcPEDIDO_PROCESSO := alltrim(strtran(laRESULT[ii,db_fetchncol(laRESULT,'PEDIDO_PROCESSO')],CRLF))
          if ascan(laPEDIDO_PROCESSO,lcPEDIDO_PROCESSO) == 0
             if db_delete('pasta_valor_pedidos','NR_PASTA='+str(fnNR_PASTA)+' and PEDIDO_PROCESSO='+DLAP+lcPEDIDO_PROCESSO+DLAP) == -1
                error_sys('pedproc_valor('+alltrim(str(procline()))+'): '+db_error())
             endif
          endif
      next ii
   endif
   if len(laSAVE) > 1
      if db_insert(laSAVE,'pasta_valor_pedidos') == -1
         error_sys('pedproc_valor('+alltrim(str(procline()))+'): '+db_error())
      endif
   endif
return(nil)



/*
* Data Criação: 13.10.2005 - Eduardo
* Function.....: pst_mkpastafiltro()
* Objetivo.....: Alimentar campo pasta.PASTA_FILTRO com conteudo de pasta_seguro.CD_RAMOSRSN
* Parâmetros:
*    fcNR_PASTA....: Número da pasta
*
* Retorno: Nenhum
*/
function pst_mkpastafiltro(fcNR_PASTA)
   local lcAUX := '' as string
   local laRESULT := {} as array
   local ii := 0 as int

   if db_select({'ramosrsn.seguroramo',;
                 'ramosrsn.seguroproduto',;
                 'ramosrsn.seguroprofit'},;
                 'pasta_seguro',;
                 {{2,'ramosrsn','ramosrsn.CD_RAMOSRSN=pasta_seguro.CD_RAMOSRSN'}},;
                 {'pasta_seguro.CD_RAMOSRSN is not null and pasta_seguro.CD_RAMOSRSN <> '+DLAP+DLAP,;
                  'pasta_seguro.NR_PASTA='+fcNR_PASTA}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      for ii := 2 to len(laRESULT)
         for xx := 1 to len(laRESULT[ii])
            if ! empty(alltrim(laRESULT[ii,xx]))
               lcAUX += '#'
               lcAUX += laRESULT[ii,xx]
            endif
         next xx
      next ii
      if ! empty(lcAUX)
         lcAUX += '#'
      endif

      if db_update({{'PASTA_FILTRO'},{lcAUX}},'pasta',{'NR_PASTA='+fcNR_PASTA}) == -1
         error_sys(db_error())
      endif
   endif
return(nil)

/*
* Data Criação: 31.10.2005 - Eduardo
* Function.....: verif_reqfield(fcPROGRAM,faDEFAULT_FIELDS)
* Objetivo.....: Faz teste de consistência dos campso obrigatórios definidos no catálogo
* Parâmetros:
*   fcPROGRAM........: Nome do Programa a ser validado.
*   faDEFAULT_FIELDS.: (Opcional) Vetor com campos obrigatórios além dos definidos no catálogo.
*
* Retorno: Nenhum
*/
function verif_reqfield(fcPROGRAM,faDEFAULT_FIELDS)
   if valtype(fcPROGRAM) != 'C'
      return (.f.)
      puterror('verif_reqfield: Parâmetro fcPROGRAM não definido.')
   endif

   local laAUX    := wmd_program(fcPROGRAM) ,;
         laVALIDA := {} as array

   local ii := 0 as int

   local llRETURN := .t. as logical

   //Capturando campos obrigatórios da wmd e adicionando os campos default.
   laAUX := wmd_reqfield(fcPROGRAM)
   if len(laAUX) > 0
      if ! empty(alltrim(laAUX[2]))
         laVALIDA := str2array(laAUX[2],',')
      endif
   endif

   if valtype(faDEFAULT_FIELDS) == 'A'
      if len(faDEFAULT_FIELDS) > 0
         for ii := 1 to len(faDEFAULT_FIELDS)
            if ascan(laVALIDA,faDEFAULT_FIELDS[ii]) == 0
               aadd(laVALIDA,faDEFAULT_FIELDS[ii])
            endif
         next ii
      endif
   endif

   //Fazendo a validação
   for ii := 1 to len(laVALIDA)
      if WGet(laVALIDA[ii],'B') //Se campo não existe na tela, não faz validação
         if valtype(WGet(laVALIDA[ii])) == 'C'
            if empty(alltrim(WGet(laVALIDA[ii],'C')))
               llRETURN := .f.
            endif
         elseif valtype(WGet(laVALIDA[ii])) == 'N'
            if WGet(laVALIDA[ii],'N') == 0
               llRETURN := .f.
            endif
         elseif valtype(WGet(laVALIDA[ii])) == 'D'
            if empty(alltrim(WGet(laVALIDA[ii],'DS')))
               llRETURN := .f.
            endif
         endif

         if ! llRETURN
            walert(lblfscreen(laVALIDA[ii])+' é um campo obrigatório!')
            get2put()
            exit
         endif
      endif
   next ii

return (llRETURN)

/*
* Data Criação: 31.10.2005 - Eduardo
* Function.....: init_reqfield(fcPROGRAM,faDEFAULT_FIELDS)
* Objetivo.....: Marca os campos obrigatórios na tela na cor vermelha
* Parâmetros:
*   fcPROGRAM........: Nome do Programa a ser validado.
*   faDEFAULT_FIELDS.: (Opcional) Vetor com campos obrigatórios além dos definidos no catálogo.
*
* Retorno: Nenhum
*/
function init_reqfield(fcPROGRAM,faDEFAULT_FIELDS)
   local laVALIDA := {} ,;
         laXPUT   := {} as array

   laXPUT := wmd_reqfield(fcPROGRAM)
   if len(laXPUT) > 0
      if ! empty(alltrim(laXPUT[2]))
         laVALIDA := str2array(laXPUT[2],',')
      endif
   endif

   if valtype(faDEFAULT_FIELDS) == 'A'
      if len(faDEFAULT_FIELDS) > 0
         for ii := 1 to len(faDEFAULT_FIELDS)
            if ascan(laVALIDA,faDEFAULT_FIELDS[ii]) == 0
               aadd(laVALIDA,faDEFAULT_FIELDS[ii])
            endif
         next ii
      endif
   endif



   for ii := 1 to len(laVALIDA)
      *WPut(laVALIDA[ii]+'.label.style.font-weight','bold')
      *WPut(laVALIDA[ii]+'.label.style.color','red')

      *WPut(laVALIDA[ii]+'.class','winputobriga')
      WPut(laVALIDA[ii]+'.style.border','1px solid red')

   next ii

return (nil)


/*
* Function..: pfpj_abas(fcPFPJ_NATUREZA)
* Objetivo..: Gera Abas para Cadastro de pessoas.
* Parâmetros:
*     fcPFPJ_NATUREZA.: Natureza: "Fisica" ou "Juridica"
*     fcNR_CONTROLE...: Numero de controle da Pessoa
* Retorno...: Nenhum
*/
function pfpj_abas(fcPFPJ_NATUREZA,fcNR_CONTROLE)
   local lcOBJ_ID   := '' ,;
         lcMENU     := '' as string
   local laRESULT := {} ,;
         laPARAMS := {} ,;
         laQUANT  := {} ,;
         laABAS   := {} as array
   local ii := 0 as int

   /* Gera Abas de Programas */
   lcMENU := 'PFPJ_'+alltrim(upper(fcPFPJ_NATUREZA))

   laABAS := structmenu(lcMENU)

   if len(laABAS) > 0
      aadd(laABAS[1],'OBJ_ID')
      for ii := 2 to len(laABAS)
         lcOBJ_ID := substr( laABAS[ii,1] , rat('/',laABAS[ii,1])+1 ) // Extrai a string depois da ultima barra encontrada.
         lcOBJ_ID := strtran( lcOBJ_ID , '.' , '_' )                  // Transforma pontos em underline.
         aadd(laPARAMS,lcOBJ_ID)
         aadd(laABAS[ii],lcOBJ_ID)
      next ii
      laQUANT := pfpj_quant(fcNR_CONTROLE,laPARAMS)

      for ii := 2 to len(laABAS)
         lcOBJ_ID := laABAS[ii,3]
         laABAS[ii,db_fetchncol(laABAS,'WLABEL')] += iif(ascan(laQUANT,{| x | alltrim(x[1]) == lcOBJ_ID}) > 0 ,;
                                                         ' ('+alltrim(laQUANT[ascan(laQUANT,{| x | alltrim(x[1]) == lcOBJ_ID}),2 ])+')', '' )
      next ii
      wPut('lstABAS',laABAS)
   endif

   /* Gera Abas de Relatórios */
   /*
   lcMENU := 'PST_RPT_'+upper(laRESULT[1])
   if len(db_findrec({'MENU'},'wmenu','MENU='+DLMT+lcMENU+DLMT)) = 0 // Se o menu de abas relacionado ao layout não existir
      lcMENU := 'PST_RPT_PADRAO'                                     // Traz o menu de abas padrão
   endif
   laABAS := structmenu(lcMENU)
   if len(laABAS) > 0
      aadd(laABAS[1],'OBJ_ID')
      for ii := 2 to len(laABAS)
         aadd(laABAS[ii],'rpt_'+alltrim(str(ii-1)))
      next ii
      wPut('lstRPT_ABAS',laABAS)
   endif
   */
return(nil)

/*
* Function..: pfpj_quant(fcNR_CONTROLE,laPARAMS)
* Objetivo..: Retorna a quantidade de registros cadastrados nas tabelas de pasta.
*             Exemplo: Contingencia,Penhora,Andamentos...
* Parâmetros:
*    fcNR_PASTA.: Número da Pasta
*    faPARAMS...: Array com os IDS dos objetos
* Retorno...: resultado do db_fetchall()
*/
function pfpj_quant(fcNR_CONTROLE,faPARAMS)
   local lcOBJ_ID := '' as string

   local laRES    := {},;
         laALTERA := {}  as array

   local lnPOS := 0 ,;
         ii    := 0 as int

   if upper(fcNR_CONTROLE) == 'NEW' .or. empty(fcNR_CONTROLE)
      fcNR_CONTROLE := '0'
   endif
   if len(faPARAMS) > 0
     /*
      * Formato do Array laALTERA:
      * Primeira Linha com os cabeçalhos
      * 2.a Linha em diante os dados respectivos
      * Colunas:
      * 1) OBJ_ID        : id do objeto no html
      * 2) TABLE         : tabela a ser realizado o count(*)
      * 3) WHERE         : condição Where
      *
      */
      laALTERA  := {{'OBJ_ID'                     ,'TABLE'             ,'WHERE' }}
      aadd(laALTERA,{'aba_socios_pfpj_html'       ,'pfpj_socios'       ,'NR_CONTROLE='+fcNR_CONTROLE })
      aadd(laALTERA,{'aba_administracao_pfpj_html','pfpj_administracao','NR_CONTROLE='+fcNR_CONTROLE })
      aadd(laALTERA,{'aba_contas_pfpj_html'       ,'pfpj_conta'        ,'NR_CONTROLE='+fcNR_CONTROLE })
      aadd(laALTERA,{'aba_contato_pfpj_html'      ,'pfpj_contato'      ,'NR_CONTROLE='+fcNR_CONTROLE })

      local lcQUERY := '' as string
      lcQUERY += 'select '+DLAP+space(80)+DLAP+', 0 as QTD '
      for ii := 1 to len(faPARAMS)
         lcOBJ_ID := faPARAMS[ii]
         lnPOS := ascan(laALTERA, { |x| x[1]== lcOBJ_ID })
         if lnPOS > 0
            lcQUERY += ' union'
            lcQUERY += ' select '+DLAP+lcOBJ_ID+DLAP+' as ABA,count(*) as QTD from '+laALTERA[lnPOS,2]
            lcQUERY += ' where '+laALTERA[lnPOS,3]
         endif
      next ii
      if db_query(lcQUERY) == -1
         error_sys(db_error())
      endif
      laRES := db_fetchall()
    endif
return(laRES)

/*
* Function..: make_pfpjhead(fcNR_CONTROLE,fcPFPJ_NATUREZA)
* Objetivo..: Monta HTML com cabeçalho das abas de Pessoas.
* Parâmetros:
*   fcNR_CONTROLE..: String com Número de controle da Pessoa
*   fcPFPJ_NATUREZA: String com tipo da Pasta
* Retorno...: nenhum
*/
function make_pfpjhead(fcNR_CONTROLE,fcPFPJ_NATUREZA)
   local lcFIELD   := '' ,;
         lcTABLE   := '' ,;
         lcCONTENT := '' as string
   local laFIELDS      := {} ,;
         laRES         := {} ,;
         laPUT         := {} ,;
         laJOIN        := {} ,;
         laJOINS       := {} ,;
         laHEAD_FIELDS := {} as array
   local lnPOS       := 0 ,;
         lnQUANT_COL := 0 ,;
         ii          := 0 ,;
         xx          := 0 as int
   local llSELECT  := .T. as logical // Inicia com Valor Verdadeiro
   local luPFPJHEAD

   luPFPJHEAD := str2array(wDataGlobal('PFPJHEAD'),'!&')
   if len(luPFPJHEAD) == 2
      if luPFPJHEAD[1] == alltrim(fcNR_CONTROLE)
         llSELECT := .f.
         lcCONTENT := luPFPJHEAD[2]
      else
         llSELECT := .t.
      endif
   endif
   if llSELECT
      lnQUANT_COL := 2 // Pega Quantidade de Colunas do pasta_config
      lcCONTENT := '<br><table border="0" cellpadding="0" cellspacing="1" align="center">'+CRLF
      lcCONTENT += '<tr><td colspan="'+str(lnQUANT_COL * 2)+'">'+CRLF
      lcCONTENT += '<input type="button" value="Localizar Pessoa" class="wbutton" onclick="document.location.href='+DLAP+wic_action('wicaction/pfpj.lst.html?FL_EXECSEL=Y')+DLAP+'">'+CRLF
      lcCONTENT += '<input type="button" value="Nova Pessoa Fisica" class="wbutton" onclick="document.location.href='+DLAP+wic_action('wicaction/pfpj.mnt.html?action=new&PFPJ_NATUREZA=Fisica')+DLAP+'">'+CRLF
      lcCONTENT += '<input type="button" value="Nova Pessoa Juridica" class="wbutton" onclick="document.location.href='+DLAP+wic_action('wicaction/pfpj.mnt.html?action=new&PFPJ_NATUREZA=Juridica')+DLAP+'">'+CRLF
      lcCONTENT += '</td></tr>'+CRLF
      laFIELDS := {'pfpj.CIP',;
                   'pfpj.PFPJ',;
                   'pfpj.PFPJ_ATIVIDADE',;
                   'pfpj.CARGO',;
                   'pfpj.CNPJ_CPF',;
                   'pfpj.IE'}

      if db_select(laFIELDS,'pfpj',,{'pfpj.NR_CONTROLE='+fcNR_CONTROLE}) == -1
         error_sys('make_pfpjhead:'+db_error())
      endif
      laRES := db_fetchall()
      xx := 1 // Controla quantidade de Colunas por Linha
      ii := 1 // Controle do laço
      lcCONTENT += '<tr>'+CRLF
      do while ii <= len(laRES[1])
         if ! empty(alltrim(laRES[1,ii]))
            lcCONTENT += '<td>'+CRLF
            lcCONTENT += '   '+lblfscreen(laRES[1,ii])+CRLF
            lcCONTENT += '</td>'+CRLF
            lcCONTENT += '<td>'+CRLF
            lcCONTENT += '   <input type="text" class="winputreadonly" value="'+alltrim(laRES[2,ii])+'" size="30" readonly>'+CRLF
            lcCONTENT += '</td>'+CRLF
         else
            lcCONTENT += '<td colspan="2"></td>'+CRLF
         endif
         if xx == lnQUANT_COL // Sempre que xx for 2, fecha <tr> e zera conteudo xx
            lcCONTENT +='</tr>'+CRLF
            lcCONTENT +='<tr>'+CRLF
            xx := 0
         endif
         xx++
         ii ++
      enddo
      lcCONTENT += '</tr>'+CRLF
      lcCONTENT += '</table><br>'+CRLF
      wDataGlobal('PFPJHEAD',array2str({fcNR_CONTROLE,lcCONTENT},'!&')) // Grava na variável Global.
   endif

   laPUT := wmd_program(WSet('_USER_INTERFACE'))
   if len(laPUT) > 0
      WPut('TITLE','Pessoa '+fcPFPJ_NATUREZA+' - '+laPUT[6])
   endif

   WPut('PFPJHEAD',lcCONTENT)
   WPut('NR_CONTROLE',fcNR_CONTROLE)
   WPut('PFPJ_NATUREZA',fcPFPJ_NATUREZA)
return(nil)


/*
* Function..: pstcips()
* Objetivo..: Retorna vetor de CIPS utilizados nas pastas
* Retorno...: Vetor de Strings com os nomes dos campos CIPS.
*/
function pstcips()
   local laCIPS := {} as array

   aadd(laCIPS,'CIP_PROTOCOLADOR')
   aadd(laCIPS,'CIP_EMPRESA')
   aadd(laCIPS,'CIP_ADVOGADO_EXTERNO')
   aadd(laCIPS,'CIP_ESCRITORIO')
   aadd(laCIPS,'CIP_PARTE_CONTRARIA')
   aadd(laCIPS,'CIP_SEGURADO')
   aadd(laCIPS,'CIP_ASSISTENTE_TECNICO')
   aadd(laCIPS,'CIP_OFICIAL_JUSTICA')
   aadd(laCIPS,'CIP_PERITO')
   aadd(laCIPS,'CIP_CONTRATADO')
   aadd(laCIPS,'CIP_CONTRATANTE')
   aadd(laCIPS,'CIP_ASSISTENTE_ACUSACAO')
   aadd(laCIPS,'CIP_ADVOGADO_INTERNO')
   aadd(laCIPS,'CIP_TECNICOSINISTRO')
   aadd(laCIPS,'CIP_FILIAL')
   aadd(laCIPS,'CIP_GESTOR_INTERNO')
   aadd(laCIPS,'CIP_AUTUADO')
   aadd(laCIPS,'CIP_AUTUANTE')
   aadd(laCIPS,'CIP_CONTRATO_CONFIDENC_PARA')
   aadd(laCIPS,'CIP_CONTRATO_EXCLUSIV_PARA')
   aadd(laCIPS,'CIP_CARTORIO')
   aadd(laCIPS,'CIP_LOCADOR')
   aadd(laCIPS,'CIP_LOCATARIO')
   aadd(laCIPS,'CIP_DEVEDOR')
   aadd(laCIPS,'CIP_CONSULENTE')
   aadd(laCIPS,'CIP_RELATOR')
   aadd(laCIPS,'CIP_RESPONSAVEL_BAIXA')
   aadd(laCIPS,'CIP_SOLICITANTE')
   aadd(laCIPS,'CIP_LICENCIADO')
   aadd(laCIPS,'CIP_FAVORECIDO')
   aadd(laCIPS,'CIP_CONTATO')
   aadd(laCIPS,'CIP_IMOBILIARIA')
   aadd(laCIPS,'CIP_CONDOMINIO')
   aadd(laCIPS,'CIP_GERENTE')
   aadd(laCIPS,'CIP_COTITULAR')
   aadd(laCIPS,'CIP_TITULAR')
   aadd(laCIPS,'CIP_MENOR_ASSISTIDO')
   aadd(laCIPS,'CIP_DIRETORIA')
   aadd(laCIPS,'CIP_AGENTE_INTERNACIONAL')
   aadd(laCIPS,'CIP_ELABORADO_POR')
   aadd(laCIPS,'CIP_AUTORIZADO_POR')
   aadd(laCIPS,'CIP_TRANSFERENCIA')
   aadd(laCIPS,'CIP_PRORROGACAO')
   aadd(laCIPS,'CIP_ANALISTA_RESPONSAVEL')
   aadd(laCIPS,'CIP_COMPRADOR')
   aadd(laCIPS,'CIP_LOJA_ORIGEM_PROBLEMA')
   aadd(laCIPS,'CIP_GESTOR')
   aadd(laCIPS,'CIP_SUP_AREA_SOLICITANTE')
   aadd(laCIPS,'CIP_ATENDENTE')
   aadd(laCIPS,'CIP_SUPAREASOLICITANTE')
   aadd(laCIPS,'CIP_ESTIPULANTE')
// 1/3/2011 4:56:44 PM
// Sonia Perdigão - Customização IBI template CIVEL_LOJA_CONT
   aadd(laCIPS,'CIP_USO_EXCLUSIVO_BANCO')
// ALTERAÇÃO UNIMED - CONSULTIVO 2
// Sonia Perdigão - 01/11/2010 09:56:36 PM
   aadd(laCIPS,'CIP_SEGURADORA')
   aadd(laCIPS,'CIP_PESSOA_FISICA')
   aadd(laCIPS,'CIP_PESSOA_JURIDICA')
// ALTERAÇÃO VPAR - SOCIETARIO4
// Sonia Perdigão - 03/11/2010 07:07:28 PM
   aadd(laCIPS,'CIP_GESTOR_SOCIETARIO')
   aadd(laCIPS,'CIP_GESTOR_UNIDADE')
// alfa
   aadd(laCIPS,'CIP_EMPRESA_PAGADORA')
   aadd(laCIPS,'CIP_CONSULTOR_INTERNO')
// alteração unimed - consultivo 2
// Sonia Perdigão - 12/11/2012 11:23:05
   aadd(laCIPS,'CIP_ADVOGADO_RESPONSAVEL')
   aadd(laCIPS,'CIP_RECLAMANTE')
// ALTERAÇÃO VPAR - SOCIETARIO4
// Sonia Perdigão - 25/4/2011 16:50:25
   aadd(laCIPS,'CIP_GESTOR_INTERNO2')
   aadd(laCIPS,'CIP_INCORPORADA')
   aadd(laCIPS,'CIP_INCORPORADORA')
// Fase 3 - 2013 - VPAR
// Sonia Perdigao
// 12/08/2013 11:58:11
   aadd(laCIPS,'CIP_EQUIP_FISC')
   aadd(laCIPS,'CIP_RESP_FISC')
   aadd(laCIPS,'CIP_EMP_INCORPORADA')
// Prudential Contrato 4
// Sonia 18/05/2016 09:24:09   
   aadd(laCIPS,'CIP_ENVIADO_POR')
// suzano 22/08/2016 11:00:37
   aadd(laCIPS,'CIP_APROVADOR1')
   aadd(laCIPS,'CIP_APROVADOR2')
   aadd(laCIPS,'CIP_APROVADOR3')
   aadd(laCIPS,'CIP_APROVADOR4')
   aadd(laCIPS,'CIP_APROVADOR5')
   aadd(laCIPS,'CIP_REPRESENTANTE1')
   aadd(laCIPS,'CIP_REPRESENTANTE2')
   aadd(laCIPS,'CIP_CONTRAPARTE1')
   aadd(laCIPS,'CIP_CONTRAPARTE2')
   aadd(laCIPS,'CIP_GESTOR_TECNICO')
   aadd(laCIPS,'CIP_EMPRESA_SOLICITANTE')
   aadd(laCIPS,'CIP_CONSELHEIRO')
   aadd(laCIPS,'CIP_EMPRESA_ATIVO')
   aadd(laCIPS,'CIP_CONFERENTE')
   aadd(laCIPS,'CIP_ANALISTA_JURIDICO') 
   aadd(laCIPS,'CIP_RESPONSAVEL')   
   aadd(laCIPS,'CIP_RESPONSAVEL1')   
   aadd(laCIPS,'CIP_RESPONSAVEL2')              


return(laCIPS)


/*
* Function..: rpt_error()
* Objetivo..: Envio do relatório de erro ao suporte INSO.
* Retorno...:
*/
function rpt_error()

      local lcFROM       := '',;
            lcTO         := '',;
            lcSUBJECT    := '',;
            lcMESSAGE    := '' as string

      if !empty(WSet('EMAIL_SUPORTE'))
         lcTO := WSet('EMAIL_SUPORTE')
      else
         lcTO := 'suporte@inso.com.br'
      endif

      lcSUBJECT    := WSet('NM_EMPRESA')+' - Erro no ISJ ocorrido em '+dtoc(date())
      lcFROM       := WGet('EMAIL')
      lcMESSAGE    := WGet('EXTRA')+CRLF+CRLF+WGet('LAST_ERROR')

      if ! wsendmail(lcFROM,lcTO,,,lcSUBJECT,lcMESSAGE)
         walert('Erro ao enviar relatório!')
         WOut('<script language="javascript">history.go(-1);</script>')
      else
         walert('Relatório enviado com sucesso!')
         portal_html()
      endif
return

/***
*
* Rotina para executar paginação
*
* fnCOUNT: Passa o numero total de registros no select
*
*/

Function paginacao(fnCOUNT,fcMSGTYPE,fcQUICK_SEARCH,fcURL)

  local ii          := 0 ,;
        lnGOTO_PAGE := WGet('GOTO_PAGE','N') ,;
        lnNR_PAGES  := 0 ,;
        lnROWS_PAGE := 0 ,;
        lnMAX_PAGES := 0 ,;
        lnPAGE_INI  := 0 ,;
        lnPAGE_FIN  := 0 ,;
        lnLIMIT1    := 0 ,;
        lnLIMIT2    := 0 as int

   local lcCODE     := '' as string

   local laPAGES    := {} ,;
         laLIMIT    := {} ,;
         laRETURN   := {} as array
   if fnCOUNT > 0
      if lnGOTO_PAGE <= 0
         lnGOTO_PAGE := 1
      endif
      lnMAX_PAGES := iif(val(WSet('MAX_PAGES'))==0,10,val(WSet('MAX_PAGES')))
      lnROWS_PAGE := iif(val(WSet('ROWS_PAGE'))==0,10,val(WSet('ROWS_PAGE')))

      if lnROWS_PAGE > fnCOUNT
         lnROWS_PAGE := fnCOUNT
      endif
      lnNR_PAGES := fnCOUNT/lnROWS_PAGE

      if (fnCOUNT % lnROWS_PAGE) > 0
         lnNR_PAGES += 1
      endif

      lnMAX_PAGES := iif(lnNR_PAGES < lnMAX_PAGES,lnNR_PAGES,lnMAX_PAGES)
      if lnGOTO_PAGE == 1
         lnPAGE_INI := 1                              // Página inicial
         lnPAGE_FIN := lnMAX_PAGES                    // Página final
      else
         if alltrim(WGet('MORE')) == 'Y'              // Visualizar as próximas 10 páginas, se possível
            lnPAGE_INI := lnGOTO_PAGE
            lnPAGE_FIN := lnMAX_PAGES+(lnGOTO_PAGE-1)
            if lnPAGE_FIN > lnNR_PAGES
               lnPAGE_FIN := lnNR_PAGES
            endif
         elseif alltrim(WGet('LESS')) == 'Y'          // Visualizar as 10 páginas anteriores, se possível
            lnPAGE_INI := lnGOTO_PAGE-lnMAX_PAGES+1
            lnPAGE_FIN := lnGOTO_PAGE
         else
            lnPAGE_INI := WGet('FIRST_PAGE','N')
            lnPAGE_FIN := WGet('LAST_PAGE','N')
         endif
      endif

      aadd(laPAGES,{'PROGRAM_CALL','NR_PAGE'})
      for ii := lnPAGE_INI to lnPAGE_FIN
          lcCODE := wic_action('wicaction/'+fcURL+'?GOTO_PAGE='+alltrim(str(ii)))
          lcCODE += '&FIRST_PAGE='+alltrim(str(lnPAGE_INI))+'&LAST_PAGE='+alltrim(str(lnPAGE_FIN))
          if ii == lnPAGE_INI
             lcCODE += '&LESS=Y'
          endif
          if ii == lnPAGE_FIN .and. lnPAGE_FIN < lnNR_PAGES
             lcCODE += '&MORE=Y'
          endif

          // Manter a pesquisa do usuário caso ela exista e demais parametros
          if !empty(fcQUICK_SEARCH)
             lcCODE += '&QUICK_SEARCH='+fcQUICK_SEARCH
          endif

          if !empty(fcMSGTYPE)
             lcCODE += '&MSGTYPE='+fcMSGTYPE
          endif

          aadd(laPAGES,{lcCODE,alltrim(str(ii))})
      next ii
      WPut('ifRESULT',.T.)
      WPut('PAGES',laPAGES)

      lnLIMIT1 := iif(lnGOTO_PAGE == 1,0,((lnGOTO_PAGE*lnROWS_PAGE)-1)-(lnROWS_PAGE-1))
      lnLIMIT2 := lnROWS_PAGE
      laLIMIT  := {lnLIMIT1,lnLIMIT2}

      aadd(laRETURN,{'NR_PAGES',lnNR_PAGES})
      aadd(laRETURN,{'ROWS_PAGE',lnROWS_PAGE})
      aadd(laRETURN,{'GOTO_PAGE',lnGOTO_PAGE})
      aadd(laRETURN,{'LIMIT',laLIMIT})
   else
      aadd(laRETURN,{'NR_PAGES' ,0})
      aadd(laRETURN,{'ROWS_PAGE',0})
      aadd(laRETURN,{'GOTO_PAGE',0})
      aadd(laRETURN,{'LIMIT',{}})
   endif
return(laRETURN)

/*
* Function..: pstcips()
* Objetivo..: Retorna o Percentual de um determinado Risco cadastrado na tabela [exito_riscoperda].
* Parâmetros:
*    fnPC_RISCO.: Código do Risco
* Retorno...: Percentual de Risco
*/
function pc_risco(fnPC_RISCO)
   local lnPC_RISCO_CALCULO := 0 as int
   local laRESULT := {} as array
   if db_select({'PC_RISCO_CALCULO'},'exito_riscoperda',,{'PC_RISCO='+str(fnPC_RISCO)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchrow()
   if len(laRESULT) > 0
      lnPC_RISCO_CALCULO := laRESULT[1]
   endif
return (lnPC_RISCO_CALCULO)

/*
* Function..: psab_find()
* Objetivo..: Verifica se determinada Aba existe pata um Tipo de Pasta.
* Parâmetros:
*    fcTP_PASTA.: Tipo de Pasta
*    fcPROGRAM..: Nome do programa (Aba)
* Retorno...: .t. Caso o programa esteja presente nas Abas
*             .f. Caso o programa não esteja presente nas Abas
*/
function psab_find(fcTP_PASTA,fcPROGRAM)
   local laRESULT := {} ,;
         laMENU   := {} as array

   if valtype(pcLAYOUT_PASTA) == 'U'
      if db_select({'LAYOUT_PASTA'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) == -1
         error_sys(db_error())
      endif
      laRESULT := db_fetchrow()
   else
      laRESULT := {pcLAYOUT_PASTA}
   endif
   if len(laRESULT) > 0
      laMENU := structmenu('PST_'+alltrim(upper(laRESULT[1])))
      if len(laMENU) > 1
         if ascan(laMENU, {| x | substr(x[1],rat('/',x[1])+1) == fcPROGRAM}) > 0
            return (.t.)
         endif
      endif
   endif
return (.f.)

/*
* Data.Criação.: 30.11.2006 - Glauber
* Function.....: Formata_Memo(fcMEMO,fnCOLUNAS,fcQUEBRA)
* Objetivo.....: Formata uma string ou campo memo especificando a quantidade de caracteres para executar a quebra
*                e a string a ser inserida como quebra.
* Parâmetros...:
*    fcMEMO....: Campo memo ou string a ser formatada.
*    fnCOLUNAS.: Quantidade de colunas a serem contadas para executar a quebra
*    fcQUEBRA..: Caracter a ser utilizado como quebra de linha.
* Retorno......: String formatada.
*/

function Formata_Memo(fcMEMO,fnCOLUNAS,fcQUEBRA)

   local lnCOLUNAS := 0,;
         lnLINHAS  := 0,;
         ii        := 0 as numeric
   local lcQUEBRA  := '',;
         lcRETORNO := '' as string

   lnCOLUNAS := iif(fnCOLUNAS > 0, fnCOLUNAS, 80)
   lcQUEBRA  := iif(! empty(fcQUEBRA), fcQUEBRA, chr(13)+chr(10))
   lnLINHAS  := mlcount(fcMEMO,lnCOLUNAS)
   for ii := 1 to lnLINHAS
       lcRETORNO += memoline(fcMEMO,lnCOLUNAS,ii) + lcQUEBRA
   next ii
return(lcRETORNO)

/*
* Data.Criação.: 06.12.2006 - Glauber
* Function.....: mklogin(fnWGID,fcCIP)
* Objetivo.....: Gerar o conteudo para o campo LOGIN de acordo com regras definidas em acgroup.LOGIN_PICT
*
* Parâmetros...:
*    fnWGID....: Código do Perfil do usuário.
*    fcCIP.....: CIP do usuário
* Retorno......: Login gerado a partir das regras definidas no Perfil.
*/

function mklogin(fnWGID,fcCIP)


   local lcRETORNO as string
   local laVALIDA     := {},;
         laLOGIN_PICT := {},;
         laRESULT     := {} as array
   local lnii         := 0,;
         lnstrlen     := 0 as numeric

   laVALIDA := structtable(WSet("DB_ACTIVE"),'pfpj',1,'N')

   // Recupera a máscara de login e começa a fazer as substituições

   if db_select({'LOGIN_PICT'},'acgroup',,{'WGID='+str(fnWGID)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      if ! empty(laRESULT[2,ascan(laRESULT,{|x| x[1] == 'LOGIN_PICT'})])
         laLOGIN_PICT := str2array(alltrim(laRESULT[2,ascan(laRESULT,{|x| x[1] == 'LOGIN_PICT'})]),'+')
         for lnii := 1 to len(laLOGIN_PICT)
             if substr(laLOGIN_PICT[lnii],1,1) == '['
                laLOGIN_PICT[lnii] := strtran(laLOGIN_PICT[lnii], '[','substr('+DLAP )
                laLOGIN_PICT[lnii] := strtran(laLOGIN_PICT[lnii], ']',')' )
             else
                laLOGIN_PICT[lnii] := DLAP + laLOGIN_PICT[lnii] + DLAP
             endif
             if lnii == len(laLOGIN_PICT)
                lcRETORNO += laLOGIN_PICT[lnii]
             else
                lcRETORNO += laLOGIN_PICT[lnii] + '+'
             endif
         next lnii
      else
         return('')
      endif
   endif

   // Recupera os dados da pessoa e começa a fazer as substituições

   if db_select(laVALIDA,'pfpj',,{'CIP='+DLAP+fcCIP+DLAP}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      //WOUT('')
      for lnii := 1 to len(laRESULT[1])
          if valtype(laRESULT[2,lnii]) == 'N'
             lcRETORNO := strtran(lcRETORNO,DLAP+laRESULT[1,lnii]+DLAP,alltrim(str(laRESULT[2,lnii]))+DLAP)
          elseif valtype(laRESULT[2,lnii]) == 'D'
             lcRETORNO := strtran(lcRETORNO,DLAP+laRESULT[1,lnii]+DLAP,dtoc(laRESULT[2,lnii])+DLAP)
          else
             lcRETORNO := strtran(lcRETORNO,DLAP+laRESULT[1,lnii]+DLAP, (strtran(laRESULT[2,lnii],' ','_')) + DLAP)
          endif
          //? lcRETORNO, ';'
      next lnii
      //? 'lcretorno', lcRETORNO
   endif


return(&lcRETORNO)



/*
* Data.Criação.: 07.12.2006 - Glauber
* Function.....: chknewlogin(fnWGID,fcCIP,fcLOGIN)
* Objetivo.....: Verificar se o login esta de conformidade com as regras definidas em perfil.
*
* Parâmetros...:
*    fnWGID....: Código do Perfil do usuário.
*    fcCIP.....: Cip do usuario
*    fcLOGIN...: Login do usuario
* Retorno......: Retorna .t. em caso de sucesso, .f. caso não atenda as regras.
*/

function chknewlogin(fnWGID,fcCIP,fcLOGIN)


   local lcLOGIN      := '' ,;
         lcRETORNO    := '' as string
   local laRESULT     := {},;
         laVALIDA     := {},;
         laRET_PARSER := {},;
         laLOGIN_PICT := {} as array
   local lnii         := 0,;
         lnNUMEROS    := 0,;
         lnXX         := 0,;
         lnPICT_NUM   := 0,;
         lnPICT_LET   := 0,;
         lnLETRAS     := 0 as numeric

    laVALIDA := structtable(WSet("DB_ACTIVE"),'pfpj',1,'N')

   // Recupera a máscara de login e começa a fazer as substituições

   if db_select({'LOGIN_QTDMAX','LOGIN_QTDMIN','LOGIN_QTDMINCHAR','LOGIN_QTDMINNUM','LOGIN_PICT'},'acgroup',,{'WGID='+str(fnWGID)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      lcLOGIN := mklogin(fnWGID,fcCIP)

      if (laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMIN')] > 0) .and. (laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMAX')]>0) .or.;
         (laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMINNUM')] >0) .and. (laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMINCHAR')]>0)

         // Contagem das letras e números que o login contém
         for lnii := 1 to len(lcLOGIN)
             //if valtype(substr(lcLOGIN,lnii,1)) == 'N'
             if substr(lcLOGIN,lnii,1) $ '0123456789'
                ++lnNUMEROS
             else
                ++lnLETRAS
             endif
         next lnii
         // Verifica se o tamanho do login satifaz a condição quantidade mínima e máxima
         if (len(lcLOGIN) < laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMIN')]) .or. (len(lcLOGIN) > laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMAX')])
            return(.F.)
         endif
         // Verifica se o login satifaz a condição quantidade mínima e máxima de letras e números
         if (lnNUMEROS < laRESULT[2, ascan(laRESULT[1], 'LOGIN_QTDMINNUM')]) .or. (lnLETRAS < laRESULT[2, ascan(laRESULT[1],'LOGIN_QTDMINCHAR')])
            return(.F.)
         endif
      endif

      // Verifica se a máscara de login não esta em branco, caso não esteja, faz a contagem dos numeros e caracteres fixos

      //if len(laRESULT) > 1
      if len(laRESULT[2,ascan(laRESULT[1],'LOGIN_PICT')]) > 0
            laLOGIN_PICT := str2array(alltrim(laRESULT[2,ascan(laRESULT[1],'LOGIN_PICT')]),'+')
            for lnii := 1 to len(laLOGIN_PICT)
                if substr(laLOGIN_PICT[lnii],1,1) <> '['
                   for lnXX := 1 to len(laLOGIN_PICT[lnii])
                       if (val(substr(laLOGIN_PICT[lnii],lnXX,1)) > 0) .or. (substr(laLOGIN_PICT[lnii],lnXX,1)== '0')
                          ++lnNUMEROS
                       else
                          ++lnLETRAS
                       endif
                   next lnXX
                endif
            next lnii
         //endif
         // Verifica se os parametros retornado pelo parser esta presente no login
         laRET_PARSER := parsernewlogin(fnWGID,fcCIP)
         //wout('')
         for lnii := 1 to len(laRET_PARSER)
             //? laRET_PARSER[lnii],'-'
             if at(laRET_PARSER[lnii],strtran(fcLOGIN,' ','_')) == 0
                //? 'NÃO PASSOU NO PARSER'
                return(.F.)
             endif
         next lnii

      else
         // Caso não utilizar a regra de validação, verificar se o login esta correto
         if len(lcLOGIN) > 0
            if (upper(fcLOGIN) == upper(lcLOGIN))
               return(.t.)
            else
               return(.f.)
            endif
         endif
      endif
   endif
return(.t.)

/*
* Data.Criação.: 12.12.2006 - Glauber
* Function.....: parsernewlogin(fnWGID,fcCIP,fcLOGIN)
* Objetivo.....: Esta função é utilizada pela função chknewlogin com o objetivo de processar os dados solicitados *..............: atravéz da macro [] e retornar um array com seus valores.
*
* Parâmetros...:
*    fnWGID....: Código do Perfil do usuário.
*    fcCIP.....: Cip do usuario
* Retorno......: Retorna um array contendo o resultado executado pela função.
*/

Static function parsernewlogin(fnWGID,fcCIP)


   local lcRETORNO as string
   local laVALIDA     := {},;
         laLOGIN_PICT := {},;
         laLOGIN_RET  := {},;
         laCONVERTE   := {},;
         laRESULT     := {} as array
   local lnii         := 0,;
         lnindice     := 0,;
         lnaa         := 0,;
         lnstrlen     := 0 as numeric

   laVALIDA := structtable(WSet("DB_ACTIVE"),'pfpj',1,'N')

   // Recupera a máscara de login e começa a fazer as substituições

   if db_select({'LOGIN_PICT'},'acgroup',,{'WGID='+str(fnWGID)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      laLOGIN_PICT := str2array(alltrim(laRESULT[2,ascan(laRESULT,{|x| x[1] == 'LOGIN_PICT'})]),'+')
      for lnii := 1 to len(laLOGIN_PICT)
          if substr(laLOGIN_PICT[lnii],1,1) == '['
               laLOGIN_PICT[lnii] := strtran(laLOGIN_PICT[lnii], '[','substr(' )
               laLOGIN_PICT[lnii] := strtran(laLOGIN_PICT[lnii], ']',')' )
               aadd(laLOGIN_RET,laLOGIN_PICT[lnii])
          endif
      next lnii
   endif

   // Recupera os dados da pessoa e começa a fazer as substituições

   if db_select(laVALIDA,'pfpj',,{'CIP='+DLAP+fcCIP+DLAP}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      for lnii := 1 to len(laRESULT[1])
          for lnaa := 1 to len(laLOGIN_RET)
              lnindice := at('substr('+DLAP+laRESULT[1,lnii],laLOGIN_RET[lnaa])
              if lnindice > 0
                 if valtype(laRESULT[2,lnii]) == 'N'
                    laLOGIN_RET[lnaa] := strtran(laLOGIN_RET[lnaa],DLAP+laRESULT[1,lnii]+DLAP,DLAP+alltrim(str(laRESULT[2,lnii]))+DLAP)
                 elseif valtype(laRESULT[2,lnii]) == 'D'
                    laLOGIN_RET[lnaa] := strtran(laLOGIN_RET[lnaa],DLAP+laRESULT[1,lnii]+DLAP,DLAP+dtoc(laRESULT[2,lnii])+DLAP)
                 else
                    laLOGIN_RET[lnaa] := strtran(laLOGIN_RET[lnaa],DLAP+laRESULT[1,lnii]+DLAP,DLAP+strtran(laRESULT[2,lnii],' ','_')+DLAP)
                 endif
              endif
          next lnaa
      next lnii
   endif
   // Executa os comandos de substr
   for lnii := 1 to len(laLOGIN_RET)
       lcRETORNO := laLOGIN_RET[lnii]
       lcRETORNO := eval({|| &lcRETORNO})
       laLOGIN_RET[lnii] := lcRETORNO
   next lnii

return(laLOGIN_RET)

/*
* Data.Criação.: 08.02.2007 - Glauber
* Function.....: mkwhere(faFIELDS,fcSEARCH)
* Objetivo.....: Gerar a cláusula "where" a partir de uma lista de capos e string de pesquisa informado.
*
* Parâmetros...:
*    faFIELDS..: Vetor com os campos a serem gerados.
*    fcSEARCH..: String de Pesquisa.
* Retorno......: String da instrução where.
*/

Function mkwhere(faFIELDS, fcSEARCH)

    local laCAMPOS  := {},;
          laSEARCH  := {},;
          laRETORNO := {} as array
    local lnII      :=  0,;
          lnXX      :=  0,;
          lnZZ      :=  0  as numeric
    local lcRETORNO := '',;
          lcTMP     := '',;
          lcSWAP    := ''  as string

    // Remove o caracter inválido na pesquisa, para não ter problemas na consulta sql

    laSEARCH := str2array(strtran(fcSEARCH, chr(39),''),{',',' '})

    // Cria um novo array com os nomes dos campos sem o '.'

    for lnXX := 1 to len(faFIELDS)
        if at('.',faFIELDS[lnXX]) > 0
           aadd(laCAMPOS, substr(faFIELDS[lnXX],(at('.',faFIELDS[lnXX])+1),len(faFIELDS[lnXX])))
        else
           aadd(laCAMPOS,faFIELDS[lnXX])
        endif
    next lnXX
    lcRETORNO := ''
    for lnXX := 1 to len(laSEARCH)
        if len(lcRETORNO) > 1
           lcRETORNO += ' and '
        endif
        lcRETORNO := ''
        for lnII := 1 to len(laCAMPOS)
            if len(lcRETORNO) > 1 .and. lnII <= len(laCAMPOS)
               lcRETORNO += ' or '
            endif
            lcSWAP := '('
            for lnZZ := 1 to len(laSEARCH[lnXX])
                if (wmd_fieldtype(laCAMPOS[lnII]) == 'FLOAT' .or. wmd_fieldtype(laCAMPOS[lnII]) == 'NUMERIC' .or. wmd_fieldtype(laCAMPOS[lnII]) == 'INTEGER') .and. (val(laSEARCH[lnXX,lnZZ]) > 0)
                   if ctod(laSEARCH[lnXX,lnZZ]) == ctod('  /  /    ')
                      if len(lcSWAP) > 1
                         lcSWAP += ' or '
                      endif
                      lcSWAP += laCAMPOS[lnII] + ' = ' + alltrim(laSEARCH[lnXX,lnZZ])
                   endif
                elseif (wmd_fieldtype(laCAMPOS[lnII]) == 'CHAR' .or. wmd_fieldtype(laCAMPOS[lnII]) == 'VARCHAR' .or. wmd_fieldtype(laCAMPOS[lnII]) == 'TEXT')
                       if val(laSEARCH[lnXX,lnZZ]) == 0 .and. ctod(laSEARCH[lnXX,lnZZ]) == ctod('  /  /    ')
                          if len(lcSWAP) > 1
                             lcSWAP += ' or '
                          endif
                          lcSWAP += laCAMPOS[lnII] + ' like '+DLAP+'%' + alltrim(laSEARCH[lnXX,lnZZ]) + '%'+DLAP
                       elseif val(laSEARCH[lnXX,lnZZ]) > 0 .and. ctod(laSEARCH[lnXX,lnZZ]) == ctod('  /  /    ')
                          if len(lcSWAP) > 1
                             lcSWAP += ' or '
                          endif
                          lcSWAP += laCAMPOS[lnII] + ' like ' +DLAP+ +'%'+alltrim(laSEARCH[lnXX,lnZZ]) + '%'+DLAP
                       endif
                elseif (wmd_fieldtype(laCAMPOS[lnII]) == 'DATE' )
                       if val(dtos(ctod(laSEARCH[lnXX,lnZZ]))) > 0
                          if len(lcSWAP) > 1
                             lcSWAP += ' or '
                          endif
                          lcSWAP += laCAMPOS[lnII] + ' = ' + DLAP + substr(dtos(ctod(laSEARCH[lnXX,lnZZ])),1,4)+'-'+ substr(dtos(ctod(laSEARCH[lnXX,lnZZ])),5,2) +'-'+substr(dtos(ctod(laSEARCH[lnXX,lnZZ])),7,2) + DLAP
                       endif
                endif
            next lnZZ
            lcRETORNO += lcSWAP + ')'
        next lnII
        aadd(laRETORNO,lcRETORNO)
    next lnXX
    lcRETORNO := '('
    if len(laRETORNO) > 1
       for lnXX := 1 to len(laRETORNO)
           lcRETORNO += strtran(laRETORNO[lnXX], ' or ()','')
           if lnXX < len(laRETORNO)
              lcRETORNO += ' and '
           endif
       next lnXX
    else
       lcRETORNO += strtran(laRETORNO[1], ' or ()','')
    endif
    lcRETORNO += ')'
    lcRETORNO := strtran(lcRETORNO, '() or ','')

return(lcRETORNO)

/*
* Data.Criação.....: 03.03.2007 - Glauber
* Function.........: grpman_where()
* Objetivo.........: Analisar se existem registros na tabela 'acgroup_manage' para o WGID. Caso exista
*                    retorna a condição where com os WGIDS que o usuário pode visualisar.
*
* Parâmetros.......:
*  pcTABLE.........: Nome da tabela a ser retornado na expressão where juntamente com o campo WGID.
* Retorno..........: retorna a condição where com os WGIDS que o usuário pode visualisar.
*/

Function grpman_where(pcTABLE)

   local lcRETORNO := '',;
         lcWHERE   := '' as string
   local lnXX      := 0  as numeric


   lcWHERE := 'WGID = ' + str(Wset('WGID'))
   if db_select({'WGID_ALLOW'},'acgroup_manage',,{lcWHERE},{'WGID','WGID_ALLOW'}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      //if ! empty(pcTABLE)
      //   lcRETORNO := alltrim(pcTABLE) + '.WGID in ('+ str(wset('WGID'))+','
      //else
      //   lcRETORNO := 'acgroup.WGID in ('+ str(wset('WGID'))+','
      //endif
      lcRETORNO := 'acgroup.WGID in (' //+ str(wset('WGID'))+','
      for lnXX := 2 to len(laRESULT)
          lcRETORNO += alltrim(str(laRESULT[lnXX,1]))
          if lnXX < len(laRESULT)
             lcRETORNO += ','
          endif
      next lnXX
      lcRETORNO += ')'
   endif
   return(lcRETORNO)

/*
* Data.Criação.: 22.03.2007 - Glauber
* Function.....: wac_tp_pasta(fcTP_PASTA)
* Objetivo.....: Verificar as permissões para um tipo de pasta e redefine as variáveis globais de controle de
*                acesso.
*
* Parâmetros...:
*    fcTP_PASTA: Tipo da pasta
* Retorno......: Nenhum
*/
/*
function wac_tp_pasta(fcTP_PASTA)

   local laPERMS  := {},;
         laFIELDS := {} as array

   #define fcWPERM_EXEC  3 // Permissão de execução
   #define fcWPERM_READ  4 // Permissão de leitura
   #define fcWPERM_WRITE 5 // Permissão de escrita
   #define fcWPERM_CREATE 6 // Permissão de inserção
   #define fcWPERM_DELETE 7 // Permissão de exclusão

   laFIELDS := {'WGID','WPROGRAM','WPERM_EXEC','WPERM_READ','WPERM_WRITE','WPERM_CREATE','WPERM_DELETE'}

   if Wset('WFL_MASTER') == 'Y' .or. empty(alltrim(fcTP_PASTA))
      return
   endif

   if db_select(laFIELDS,'acgroup_program',,{'WGID='+str(Wset('WGID'))+ ' and WPROGRAM = '+DLAP+fcTP_PASTA+DLAP}) = -1
      error_sys(db_error())
   endif
   laPERMS := db_fetchall()

   if len(laPERMS) == 1
      return
      //error_sys('Access Control: Sem permissão para execução.')
   else
      if laPERMS[2,fcWPERM_EXEC] !=  'Y' // Permissão de Execução
         error_sys('Access Control: Sem permissão para execução.')
      endif
      gbWAC_CREATE := iif(laPERMS[2,fcWPERM_CREATE] == 'Y',.T.,.F.)
      gbWAC_READ   := iif(laPERMS[2,fcWPERM_READ] == 'Y',.T.,.F.)
      gbWAC_WRITE  := iif(laPERMS[2,fcWPERM_WRITE] == 'Y',.T.,.F.)
      gbWAC_DELETE := iif(laPERMS[2,fcWPERM_DELETE] == 'Y',.T.,.F.)
   endif

return
*/
/*
* Function..: fromto(fcTABLE,faSAVE)  - " DE PARA "
* Objetivo..: Verifica e altera conteudo de laSAVE, de acordo com regras da ferramenta DE/PARA
* Parâmetros: fcTABLE  -> tabela
              faSAVE   -> array formato laSAVE
* Retorno...: array formato laSAVE com regras da ferramenta DE/PARA aplicadas
*/
/*
Function fromto(fcTABLE,faSAVE)

       local laRES       := {} ,;
             laRES1      := {} ,;
             laJOIN      := {} ,;
             laFROMTO    := {} ,;
             laFIELDS    := {} ,;
             laRESULT    := {} ,;
             laFROMTO_AUX:= {}  as array

       local ii       := 0   ,;
             zz       := 0   ,;
             yy       := 0   ,;
             aa       := 0   ,;
             lnROL    := 0   ,;
             lnPOS    := 0   ,;
             lnPOS1   := 0    as int

       local lcWHERE  := ''  ,;
             lcFROMTO := ''  ,;
             lcTABLE  := upper(fcTABLE) as string

       local llCOND   := .t. as logical

       // Buscando as definições DE/PARA
       if db_select({'NR_CTRFROMTO'},'WFFROMTO',,{"WFTABLE="+DLAP+lcTABLE+DLAP+" and fl_active='Y'"}) = -1
          error_sys(db_error())
       endif
       if len(laRESULT := db_fetchall()) > 1
          for ii := 2 to len(laRESULT)   // executa o for N vezes conforme as regras forem cadastradas
              laFIELDS := {'wffromto_condition_content.WFIELD_CONDITION',;
                           'wffromto_condition_content.NR_ROW',;
                           'wffromto_condition_content.WFCONTENT',;
                           'wffromto_condition_content.WFCONTENT2',;
                           'wffromto_condition_content.NR_CTRFROMTO',;
                           'wffromto_condition.WFCONDITION'}

              lcWHERE  := 'wffromto_condition_content.NR_CTRFROMTO = '+alltrim(str(laRESULT[ii,1]))

              laJOIN := { { 2,'wffromto_condition' ,'wffromto_condition_content.NR_CTRFROMTO = wffromto_condition.NR_CTRFROMTO and '+;
                                                   'wffromto_condition_content.WFIELD_CONDITION = wffromto_condition.WFIELD_CONDITION'}}

              if db_select(laFIELDS,'wffromto_condition_content',laJOIN,{lcWHERE},{'wffromto_condition_content.NR_ROW'}) = -1
                 error_sys(db_error())
              endif
              if len(laRES := db_fetchall()) > 1
                 for yy := 2 to len(faSAVE)     // se o array laSAVE conter mais de um registro a salvar
                     llCOND := .t.
                     lnROL := laRES[2,db_fetchncol(laRES,'NR_ROW')]
                     zz := 2
                     while zz <= (len(laRES)+1)
                         if zz <= len(laRES) .and. (lnROL = laRES[iif((zz > len(laRES)),(zz-1),zz),db_fetchncol(laRES,'NR_ROW')])
                            lnPOS := ascan(faSAVE[1], laRES[zz,db_fetchncol(laRES,'WFIELD_CONDITION')])
                            if lnPOS > 0
                               if laRES[zz,db_fetchncol(laRES,'WFCONDITION')] == 'E'       // CONDIÇÃO IGUAL
                                  if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'N'
                                     if !(val(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) = faSAVE[yy,lnPOS])
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                                     if !ctod(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) = faSAVE[yy,lnPOS]
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'C'
                                     if !(laRES[zz,db_fetchncol(laRES,'WFCONTENT')] == faSAVE[yy,lnPOS])
                                        llCOND := .f.
                                     endif
                                  endif
                               elseif laRES[zz,db_fetchncol(laRES,'WFCONDITION')] == 'D'   // CONDIÇÃO DIFERENTE
                                  if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'N'
                                     if !(val(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) <> faSAVE[yy,lnPOS])
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                                     if !ctod(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) <> faSAVE[yy,lnPOS]
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'C'
                                     if !(laRES[zz,db_fetchncol(laRES,'WFCONTENT')] <> faSAVE[yy,lnPOS])
                                        llCOND := .f.
                                     endif
                                  endif
                               elseif laRES[zz,db_fetchncol(laRES,'WFCONDITION')] == 'I'   // CONDIÇÃO INTERVALO
                                  if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'N'
                                     if !(faSAVE[yy,lnPOS] >= val(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) .and.;
                                          faSAVE[yy,lnPOS] <= val(laRES[zz,db_fetchncol(laRES,'WFCONTENT2')]))
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                                     if !(faSAVE[yy,lnPOS] >= ctod(laRES[zz,db_fetchncol(laRES,'WFCONTENT')]) .and. ;
                                          faSAVE[yy,lnPOS] <= ctod(laRES[zz,db_fetchncol(laRES,'WFCONTENT2')]))
                                        llCOND := .f.
                                     endif
                                  elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'C'
                                     if !(faSAVE[yy,lnPOS] >= laRES[zz,db_fetchncol(laRES,'WFCONTENT')] .and.;
                                          faSAVE[yy,lnPOS] <= laRES[zz,db_fetchncol(laRES,'WFCONTENT2')])
                                        llCOND := .f.
                                     endif
                                  endif
                               endif
                               if llCOND
                                  aadd(laFROMTO_AUX , {laRES[zz,db_fetchncol(laRES,'NR_CTRFROMTO')],;      // Nr Controle
                                                       laRES[zz,db_fetchncol(laRES,'WFIELD_CONDITION')],;  // Campo Alvo
                                                       faSAVE[yy,lnPOS] })                                 // Conteúdo
                               endif
                            endif
                         else
                            if llCOND // se todas as condições de filtro foram aceitas
                               laFROMTO := aclone(laFROMTO_AUX)
                               laFROMTO_AUX := {}
                               if db_select({'wffromto_target_content.WFIELD_TARGET'   ,; //busca conteúdo para substituição no array de salvamento (laSAVE)
                                             'wffromto_target_content.WFCONTENT_TARGET',;
                                             'wffromto_target.FL_OVERWRITE'            ,;
                                             'wffromto_target.NR_CTRFROMTO'           },;
                                             'wffromto_target_content',;
                                             {{2,'wffromto_target','wffromto_target_content.NR_CTRFROMTO  = wffromto_target.NR_CTRFROMTO and '+;
                                                                   'wffromto_target_content.WFIELD_TARGET = wffromto_target.WFIELD_TARGET'}},;
                                             {'wffromto_target_content.NR_CTRFROMTO = '+alltrim(str(laRESULT[ii,1]))+' and wffromto_target_content.NR_ROW='+alltrim(str(lnROL))}) = -1
                                  error_sys(db_error())
                               endif
                               if len(laRES1 := db_fetchall()) > 1
                                  for aa:= 2 to len(laRES1)
                                      lnPOS1 := ascan(faSAVE[1], laRES1[aa,db_fetchncol(laRES1,'WFIELD_TARGET')])
                                      if lnPOS1 > 0
                                         if laRES1[aa,db_fetchncol(laRES1,'FL_OVERWRITE')] == 'Y'
                                            if     wmd_wfieldtype(faSAVE[1,lnPOS1],'gr5') = 'N'    // faz a alteração ao campo pois o cadastrado é texto
                                                 faSAVE[yy,lnPOS1] := val(laRES1[aa,db_fetchncol(laRES1,'WFCONTENT_TARGET')])
                                            elseif wmd_wfieldtype(faSAVE[1,lnPOS1],'gr5') = 'D'
                                                 faSAVE[yy,lnPOS1] := ctod(laRES1[aa,db_fetchncol(laRES1,'WFCONTENT_TARGET')])
                                            elseif wmd_wfieldtype(faSAVE[1,lnPOS1],'gr5') = 'C'
                                                 faSAVE[yy,lnPOS1] := laRES1[aa,db_fetchncol(laRES1,'WFCONTENT_TARGET')]
                                            endif

                                            // gera array com campos/conteudos alterados e envia para o alçada
                                            aadd(laFROMTO, { laRES1[aa,db_fetchncol(laRES1,'NR_CTRFROMTO')]    ,;   // Nr Controle
                                                             laRES1[aa,db_fetchncol(laRES1,'WFIELD_TARGET')]   ,;   // Campo Alvo
                                                             laRES1[aa,db_fetchncol(laRES1,'WFCONTENT_TARGET')]})   // Conteúdo
                                         endif
                                      endif
                                  next aa
                               endif
                            endif
                            if zz <= len(laRES)
                               lnROL := laRES[zz,db_fetchncol(laRES,'NR_ROW')]
                               zz := zz - 1
                            endif
                            llCOND := .t.
                         endif
                         zz ++
                     end
                 next yy
              endif
          next ii
       endif

       if len(laFROMTO) > 0
          lcFROMTO := arrayBI2str(laFROMTO,',')      // altera o formato do array
       endif
       wDataGlobal('DE_PARA', lcFROMTO ) // Grava array convertido na variável Global

return(faSAVE)
*/

/*
* Function..: alcada(fcTABLE,faSAVE,faWHERE,fcTYPE)
* Objetivo..: Verifica as regras definidas para a Alcada.
* Parâmetros: fcTABLE  -> tabela
             faSAVE   -> array formato laSAVE
             fcWHERE  -> condicao where caso fcTYPE = U
             fcTYPE   -> função que chamou alcada() ( I = db_insert / U = db_update )
* Retorno...: .t. alcada aplicada
              .f. alcada nao aplicada
*/
/*
function alcada(fcTABLE,faSAVE,faWHERE,fcTYPE)

   local laRES      := {} ,;
         laTRANS    := {} ,;
         laTRANS1   := {} ,;
         laTRANS2   := {} ,;
         laTRANS_AUX:= {} ,;
         laJOIN     := {} ,;
         laWHERE    := {} ,;
         laFIELDS   := {} ,;
         laRESULT   := {} ,;
         laRESULT1  := {} ,;
         laRESULT2  := {} ,;
         laGROUP    := {} ,;
         laAI       := {} ,;
         laPKEY     := {}  as array

   local ii       := 0   ,;
         ii1      := 0   ,;
         ii2      := 0   ,;
         ii3      := 0   ,;
         ii4      := 0   ,;
         yy       := 0   ,;
         lnPOS    := 0   ,;
         lnPOS1   := 0   ,;
         lnWGID   := 0   ,;
         lnINCREMENTO:=0 ,;
         lnNIVEL_WGID:=0 ,;
         lnNIVEL_REG :=0  as int

   local lcWHERE   := '',;
         lcMSG     := '',;
         lcMSG1    := '',;
         lcMSG2    := '',;
         lcPROJECT := '',;
         lcCONDICAO:= '',;
         lcTABLE   := upper(fcTABLE) as string

   local llGRAVA  := .f. as logical

   if fcTYPE = 'I'
      laAI   := db_fetchainc(lcTABLE, 'GR5') // Busca campo Auto Incremento
      laPKEY := db_fetchpkey(lcTABLE,,'GR5') // Busca chave primária da tabela alvo do Insert/Update
      for ii := 1 to len(laPKEY)
          if len(lcCONDICAO) > 0
             lcCONDICAO += ' and '
          endif
          lnPOS := ascan(laAI,laPKEY[ii])
          if lnPOS > 0
             lcCONDICAO += laPKEY[ii]+' = '+alltrim(wset('_db_insert_id'))
          else
             if valtype(faSAVE[2,db_fetchncol(faSAVE,laPKEY[ii])]) = 'N'
                lcCONDICAO += laPKEY[ii]+' = '+alltrim(str(faSAVE[2,db_fetchncol(faSAVE,laPKEY[ii])]))
             else
                lcCONDICAO += laPKEY[ii]+' = "'+alltrim(faSAVE[2,db_fetchncol(faSAVE,laPKEY[ii])])+'"'
             endif
          endif
      next ii
   elseif fcTYPE = 'U'
      laWHERE := faWHERE
   endif

   if db_select({'WGID','WGROUP'},'acgroup') = -1
      error_sys(db_error())
   endif
   laGROUP := db_fetchall()

   lcWHERE:= 'WTABLE='+DLAP+lcTABLE+DLAP+' and (FL_OPERATION='+DLAP+fcTYPE+DLAP+' or FL_OPERATION="R")'
   if db_select({'WFIELD','FL_OPERATION','WGID_EXCEPTION','NR_NIVEL','WFCONDITION'},'alcada',,{lcWHERE}) = -1 // Buscando regras da Alcada.
      error_sys(db_error())
   endif
   if len(laRESULT := db_fetchall()) > 1
      db_begin()
      for ii := 2 to len(laRESULT) // No caso de mais de uma regra para a mesma tabela.
          lcMSG := ''
          lnPOS := db_fetchncol(faSAVE,laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')])    // Verifica se o campo da regra esta contido no array "laSAVE"
          if lnPOS > 0
             if db_select({'WFIELD','WFCONTENT','WFCONTENT2','WGID','NR_NIVEL'},'alcada_conteudo',,;
                          {"WTABLE="+DLAP+lcTABLE+DLAP+" and WFIELD="+DLAP+laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')]+DLAP  }) = -1
                db_rollback()
                error_sys(db_error())
             endif
             if len(laRESULT1 := db_fetchall()) > 1         // Busca as condições para solicitar o perfil de aprovação da a
                lnPOS1 := ascan(laRESULT1,{ |z| alltrim(str(z[4])) == alltrim(str(Wset('WGID'))) }) // Buscando o Nivel do WGID que esta fazendo o Insert/Updatex
                if lnPOS1 > 0
                   lnNIVEL_WGID := laRESULT1[lnPOS1,5]
                endif
                for yy := 2 to len(faSAVE)          // se o array laSAVE conter mais de um registro a salvar
                    if fcTYPE = 'U'
                       lcCONDICAO := laWHERE[yy-1]
                    endif
                    llGRAVA    :=.f.
                    laTRANS    :={}
                    laTRANS_AUX:={}
                    laTRANS1   :={}
                    laTRANS2   :={}
                    aadd(laTRANS, {'WTABLE','DT_TRANSACAO','HR_TRANSACAO','LOGIN_TRANSACAO','WGID','WFWHERE_EXP' }) // CABEÇALHO DE ALCADA_TRANSACAO
                    aadd(laTRANS1,{'NR_CONTROLE','WFIELD','WFCONTENT'})
                    aadd(laTRANS_AUX , lcTABLE )                                        // WTABLE
                    aadd(laTRANS_AUX , date())                                          // DT_TRANSACAO
                    aadd(laTRANS_AUX , time())                                          // HR_TRANSACAO
                    aadd(laTRANS_AUX , wset("LOGIN") )                                  // LOGIN_TRANSACAO
                    aadd(laTRANS2    , '' )                                             // NR_CONTROLE
                    aadd(laTRANS2    , laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')] )   // WFIELD
                    for ii1 := 2 to len(laRESULT1)
                        // verificando as condições dfiltro
                        if laRESULT[ii,db_fetchncol(laRESULT,'WFCONDITION')] == 'E'    // Igual
                           if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'N'  // verifica o tipo do campo
                              if (val(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')] ) = faSAVE[yy,lnPOS])
                                 lnNIVEL_REG := laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]   // Se Nivel do Insert/Update menor que o Nivel do WGID da Regra.
                                 lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                 aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                 aadd(laTRANS2  , faSAVE[yy,lnPOS] )
                                 llGRAVA := .t.
                              endif
                           elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                              if ctod(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')]) = faSAVE[yy,lnPOS]
                                 lnNIVEL_REG := laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]   // Se Nivel do Insert/Update menor que o Nivel do WGID da Regra.
                                 lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                 aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                 aadd(laTRANS2    , faSAVE[yy,lnPOS] )
                                 llGRAVA := .t.
                              endif
                           elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'C'
                              if (laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')] == faSAVE[yy,lnPOS])
                                 lnNIVEL_REG := laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]   // Se Nivel do Insert/Update menor que o Nivel do WGID da Regra.
                                 lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                 aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                 aadd(laTRANS2    , faSAVE[yy,lnPOS] )
                                 llGRAVA := .t.
                              endif
                           endif
                        else                                                              // Intervalo
                           if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'N'
                                 if (faSAVE[yy,lnPOS] >= val(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')]) .and.;
                                     faSAVE[yy,lnPOS] <= val(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT2')]))
                                    lnNIVEL_REG :=  laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]
                                    lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                    aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                    aadd(laTRANS2    , faSAVE[yy,lnPOS] )
                                    llGRAVA := .t.
                                 endif
                           elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                                 if (faSAVE[yy,lnPOS] >= ctod(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')]) .and. ;
                                     faSAVE[yy,lnPOS] <= ctod(laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT2')]))
                                    lnNIVEL_REG :=  laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]
                                    lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                    aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                    aadd(laTRANS2    , dtos(faSAVE[yy,lnPOS]) )
                                    llGRAVA := .t.
                                 endif
                           elseif wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'C'
                                 if (faSAVE[yy,lnPOS] >= laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT')] .and.;
                                     faSAVE[yy,lnPOS] <= laRESULT1[ii1,db_fetchncol(laRESULT1,'WFCONTENT2')])
                                    lnNIVEL_REG :=  laRESULT1[ii1,db_fetchncol(laRESULT1,'NR_NIVEL')]
                                    lnWGID := laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')]
                                    aadd(laTRANS_AUX , laRESULT1[ii1,db_fetchncol(laRESULT1,'WGID')])   // WGID
                                    aadd(laTRANS2    , faSAVE[yy,lnPOS] )
                                    llGRAVA := .t.
                                 endif
                           endif
                        endif
                    next ii1
                    // Caso nenhuma das regras passou pelo filtro "AND" existe o perfil de Exceção, este perfil será o gestor.
                    if ! llGRAVA .and. laRESULT[ii,db_fetchncol(laRESULT,'WGID_EXCEPTION')] > 0
                       lnNIVEL_REG := laRESULT[ii,db_fetchncol(laRESULT,'NR_NIVEL')]          // compara com o nivel da Exceção.
                       lnWGID      := laRESULT[ii,db_fetchncol(laRESULT,'WGID_EXCEPTION')]
                       aadd(laTRANS_AUX , laRESULT[ii,db_fetchncol(laRESULT,'WGID_EXCEPTION')])   // WGID
                       if wmd_wfieldtype(faSAVE[1,lnPOS],'gr5') = 'D'
                          aadd(laTRANS2  , dtos(faSAVE[yy,lnPOS]))
                       else
                          aadd(laTRANS2  , faSAVE[yy,lnPOS] )
                       endif
                       llGRAVA := .t.
                    endif
                    //   lnNIVEL_WGID = nivel do usuário que esta salvando o registro
                    //   lnNIVEL_REG  = nivel da regra da alcada
                    if llGRAVA .and. (lnNIVEL_WGID < lnNIVEL_REG)
                       aadd(laTRANS_AUX , lcCONDICAO )   // condicao where enviada pelo db_update ou criada apos o  db_insert
                       aadd(laTRANS  , laTRANS_AUX )
                       aadd(laTRANS1 , laTRANS2)
                       // Verifica se existe campos alvos, que devem ser adicionados ou alterados no laSAVE
                       if db_select({'WFIELD_TARGET','WFCONTENT'},'alcada_acao',,{"WTABLE="+DLAP+lcTABLE+DLAP+' and WFIELD='+DLAP+laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')]+DLAP  }) = -1
                          db_rollback()
                          error_sys(db_error())
                       endif
                       if len(laRESULT2 := db_fetchall()) > 1
                          for ii3 := 2 to len(laRESULT2)
                              laTRANS2 := {}
                              aadd(laTRANS2 , '') // NR_CONTROLE
                              aadd(laTRANS2 , laRESULT2[ii3,db_fetchncol(laRESULT2,'WFIELD_TARGET')]) // WFIELD
                              aadd(laTRANS2 , laRESULT2[ii3,db_fetchncol(laRESULT2,'WFCONTENT')])     // WFCONTENT
                              aadd(laTRANS1 , laTRANS2)
                          next ii3
                       endif
                       // Existe algum CAMPO ALVO no DE/PARA que seja o campo da regra atual do ALÇADA ?
                       // Caso exista deve-se travar a alteração que o DE/PARA deveria realizar e manter os valores da base
                       if len(laRESULT2 := str2arrayBI(wDataGlobal('DE_PARA'),',')) > 0 // pegando os campos que devem ir para a aprovação do gestor
                          lcCOMPARA := laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')]
                          lnPOS1    := ascan(laRESULT2,{ |z| z[2] = lcCOMPARA })        // procura o array de campos do DE/PARA o campo principal da alçada
                          if lnPOS1 > 0                                                 // se achou pega todos os campos que pertencem a regra DE/PARA
                             for ii2 := 1 to len(laRESULT2)
                                 if (laRESULT2[ii2,1] == laRESULT2[lnPOS1,1]) .and.;    // os Nr controles são iguais, sendo assim são da mesma regra de DE/PARA
                                    laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')] <> laRESULT2[ii2,2]    // para não duplicar o campo alvo do DE PARA e do campo da Alçada.
                                    laTRANS2 := {}
                                    aadd(laTRANS2 , '')                                     // NR_CONTROLE
                                    aadd(laTRANS2 , laRESULT2[ii2,2])                       // CAMPO
                                    aadd(laTRANS2 , laRESULT2[ii2,3])                       // WFCONTENT
                                    aadd(laTRANS1 , laTRANS2)
                                 endif
                             next ii2
                          endif
                       endif
                    endif
                    if len(laTRANS) > 1
                       // excluindo os campos do array "laSAVE", pois tem que manter o conteúdo original,
                       // ja que o conteúdo digitado vai para aprovação do gestor
                       for ii1 :=2 to len(laTRANS1)
                           if fcTYPE = 'A'                                                       // nao grava conteudo caso a operação seja UPDATE, o conteudo vai para alçada.
                              drop_field(@faSAVE, laTRANS1[ii1,db_fetchncol(laTRANS1,'WFIELD')]) // se for inclusao de registro  inclui o conteudo, mas mesmo assim solicita alçada.
                           endif
                           lcMSG += lblfscreen(alltrim(laTRANS1[ii1,db_fetchncol(laTRANS1,'WFIELD')]))+chr(10)
                       next ii1
                       // Verifica se já existe a alcada lancada
                       if db_select({'alcada_transacao.nr_controle','alcada_transacao.wgid'},;
                                     'alcada_transacao'             ,;
                                     {{2,'alcada_transacao_conteudo','alcada_transacao.NR_CONTROLE=alcada_transacao_conteudo.NR_CONTROLE'}},;
                                     {"alcada_transacao.wtable='"+lcTABLE+"' and alcada_transacao.fl_alcada = 'P' and alcada_transacao.wfwhere_exp='"+lcCONDICAO+"' and alcada_transacao_conteudo.wfield = '"+laRESULT[ii,db_fetchncol(laRESULT,'WFIELD')]+"'"}) = -1
                          error_sys(db_error())
                       endif
                       if len(laRES := db_fetchall()) < 2
                          lcPROJECT := wset('_PROJECT')
                          wset('_PROJECT', 'workflow')
                          if db_insert(laTRANS,'alcada_transacao') = -1
                             db_rollback()
                             error_sys(db_error())
                          endif
                          lnINCREMENTO := db_insert_id()
                          for ii1 :=2 to len(laTRANS1)
                              laTRANS1[ii1,1] := lnINCREMENTO
                          next ii1
                          if db_insert(laTRANS1,'alcada_transacao_conteudo') = -1
                             db_rollback()
                             error_sys(db_error())
                          endif
                          wset('_PROJECT',lcPROJECT)
                       endif
                       lnPROCURA := lnWGID
                       lcMSG1 += 'Os campos abaixo não foram salvos, pois necessitam de aprovação da Alçada do perfil '+laGROUP[ascan(laGROUP,{ |x| x[1]=lnPROCURA},2),2]+chr(10)
                       lcMSG1 += lcMSG
                       lcMSG1 += chr(10)
                    endif
                next yy
             endif
          endif
      next ii
      if len(lcMSG1) > 0
         walert(lcMSG1)
      endif
      db_commit()
   endif
return(.t.)
*/

/*Function..: drop_field(faSAVEX,fcFIELD)
* Objetivo..: Retira do array bidimencional determinada coluna identificada por fcFIELD
* Parâmetros: faSAVEX -> array bidimencional
              fcFIELD -> campo identificador de coluna a ser excluida.
* Retorno...: faSAVEX - array sem a coluna fcFIELD
*/
/*
function drop_field(faSAVEX,fcFIELD)
   local a1   := 1 ,;
         lnPOS:= 0 as int


   lnPOS := db_fetchncol(faSAVEX,upper(fcFIELD))
   if lnPOS > 0
      for a1 := 1 to len(faSAVEX)
          adel(faSAVEX[a1],lnPOS)
          asize(faSAVEX[a1],len(faSAVEX[a1])-1)
      next a1
      return(.t.)
   endif
return(.f.)


function arrayBI2str(faARRAY,fcSEP)
       local az    := 0 ,;
             az1   := 0  as int
       local lcRET := '' ,;
             lcRET1:= '' as string

       for az := 1 to len(faARRAY)
           if len(lcRET) > 1
              lcRET += '|'
           endif
           lcRET1 := ''
           for az1 := 1 to len(faARRAY[az])
               if len(lcRET1) > 1
                  lcRET1 += fcSEP
               endif
               if valtype(faARRAY[az,az1]) = 'N'
                  lcRET1 += str(faARRAY[az,az1])
               elseif valtype(faARRAY[az,az1]) = 'D'
                  lcRET1 += dtoc(faARRAY[az,az1])
               else
                  lcRET1 += faARRAY[az,az1]
               endif
           next az1
           lcRET += alltrim(lcRET1)
       next az
return(lcRET)


function str2arrayBI(fcSTRING,fcSEP)
       local lnFIN := 0  as int
       local laRETURN := {} as array
       while .t.
           lnFIN := at('|',fcSTRING)
           lcSTRING := alltrim(substr(fcSTRING,1, iif(lnFIN>0,lnFIN-1,len(fcSTRING))))
           if empty(lcSTRING)
              exit
           else
              aadd(laRETURN,  str2array(lcSTRING,fcSEP) )
              fcSTRING := alltrim(substr(fcSTRING,lnFIN+1))
              if lnFIN <= 0
                 exit
              endif
           endif
       end
return(laRETURN)
*/
/*
* Data Criação: 03.04.2007 - Glauber
* Function.....: migracao_aba_valor()
* Objetivo.....: Migrar valores das pastas que utilizem os templates Civil2, Civil_adm_cade, Civil_securit_com_sinistro,
*                Civil_securit_sem_sinistro e DPVAT.
* Parâmetros:
*    ...........:
*    ...........:
*
* Retorno: Nenhum
*/

function migracao_aba_valor()

  local laRESULT     := {},;
        laRESULT2    := {},;
        laSAVE       := {},;
        laFIELDS     := {},;
        laSAVE_AUX   := {},;
        laCAMPOS     := {},;
        laJOIN       := {},;
        laREGRA      := {}   as array
  local lnRESULT     := 0 ,;
        lnXX         := 0 ,;
        lxYY         := 0 ,;
        lnGRAVAR     := 0    as int
  local lcEVAL       := '',;
        lcGRAVAR     := '',;
        lcWHERE      := ''   as string

  // Atualização dos valores do risco (coluna PC_RISCO)

  laFIELDS := {'NR_PASTA','PC_RISCO','PC_RISCO2'}
  // Array com o conjunto de bloco de código onde é processado a regra e retornado o valor a atualizar
  laREGRA  := { '{|lnRESULT| iif((lnRESULT >=  0 .and. lnRESULT <=  40),  20, 0)}',;
                '{|lnRESULT| iif((lnRESULT >= 41 .and. lnRESULT <=  60),  50, 0)}',;
                '{|lnRESULT| iif((lnRESULT >= 61 .and. lnRESULT <=  80),  80, 0)}',;
                '{|lnRESULT| iif((lnRESULT >= 80 .and. lnRESULT <= 100), 100, 0)}' }

   lcWHERE := 'TP_PASTA in (select TP_PASTA from pasta_config where '
   lcWHERE +=           '(layout_pasta = '+DLAP+'Civel2'+DLAP
   lcWHERE +=           ' or layout_pasta = '+DLAP+'Civel_adm_cade'+DLAP
   lcWHERE +=           ' or layout_pasta = '+DLAP+'Civel_securit_com_sinistro'+DLAP
   lcWHERE +=           ' or layout_pasta = '+DLAP+'Civel_securit_sem_sinistro '+DLAP
   lcWHERE +=           ' or layout_pasta = '+DLAP+'DPVAT'+DLAP+'))'

   if db_select(laFIELDS,'pasta',,{lcWHERE}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      db_begin()
      for lnXX := 2 to len(laRESULT)
          // lcEVAL verica qual o campo contém o maior valor do risco e retorna o nome do campo, PC_RISCO ou PC_RISCO2
          lcEVAL   := iif(laRESULT[lnXX,ascan(laRESULT[1],'PC_RISCO')] > laRESULT[lnXX,ascan(laRESULT[1],'PC_RISCO2')], 'PC_RISCO','PC_RISCO2')
          lnRESULT := laRESULT[lnXX,ascan(laRESULT[1],lcEVAL)] // Armazena o maior valor
          // Array com o conjunto de bloco de código onde é processado a regra e retornado o valor a atualizar
          for lnYY := 1 to len(laREGRA)
              lcGRAVAR := laREGRA[lnYY]
              lnGRAVAR := eval(&lcGRAVAR,lnRESULT)
              if lnGRAVAR > 0
                 exit
              endif
          next lnYY
          // Atualiza o registro da tabela pasta
          if lnGRAVAR > 0 .and. laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')] > 0
             lcWHERE := 'NR_PASTA = '+ alltrim(str(laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')]))
             if db_replace({{'PC_RISCO'},{lnGRAVAR}},'pasta',{lcWHERE}) == -1
                db_rollback()
                error_sys(db_error())
             endif
          endif
      next lnXX
      db_commit()
   endif

   // Este bloco atualiza as colunas PEDIDO_PROCESSO, VL_PEDIDO, DT_RISCO, DT_RISCO2, VL_RISCO, VL_RISCO2,
   //                                PC_RISCO, PC_RISCO2 da tabela pasta_valor_pedidos

   laFIELDS := {'pasta_contingencia.NR_PASTA',;
                'pasta_contingencia.PEDIDO_PROCESSO',;
                'pasta_contingencia.VL_PEDIDO',;
                'pasta.DT_RISCO',;
                'pasta_contingencia.VL_RISCO',;
                'pasta_contingencia.PC_RISCO'}

   laJOIN   := {{2,'pasta','pasta_contingencia.NR_PASTA = pasta.NR_PASTA'}}

   laCAMPOS := {}
   aadd({'Emissão de apólice'                        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Exibição de documentos'                    , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Furto em armazém'                          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Furto em estacionamento'                   , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Honorários Extracontratuais'               , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Honorários médicos'                        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Incêndio'                                  , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Inclusão de cobertura'                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Inclusão de segurado na apólice'           , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização contratual'                    , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização diária incapacidade temporária', 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização extracontratual'               , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Indenização perda habilitação vôo'         , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização por morte'                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização Securitária Contratual'        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Indenização Securitária Extracontratual'   , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Informações'                               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Interceptação de passagem'                 , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Intermediação'                             , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Invalidez + Dams'                          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Investigação'                              , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Molhadura'                                 , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Morte + Dams'                              , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Mudança de faixa'                          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Multa'                                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Multa diária Extracontratual'              , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Multa Extracontratual'                     , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Não cancelamento de apólice'               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Não exclusão de cobertura'                 , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Ordenando depósito em juízo'               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Pagamento de benefício Contratual'         , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Pagamento de benefício Extracontratual'    , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Perdas e danos'                            , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Plano previdência averbado'                , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Plano previdência instituído'              , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Publicidade'                               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Quitação dívida'                           , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Quitação do Saldo Devedor Contratual'      , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Quitação do Saldo Devedor Extracontratual' , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'RCTRC'                                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Reativação da apólice'                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Reembolso de serviços'                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Reembolso de serviços Contratual'          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Reembolso de serviços Extracontratual'     , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Reintegração ao plano'                     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Remuneração'                               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Renda Contratual'                          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Renda Extracontratual'                     , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Repique'                                   , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Representação'                             , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando documento - apólice'          , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando documentos - sinistros'       , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando informação'                   , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando informação - apólice'         , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando informação - criminal'        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando informação - sinistro'        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando informação de salvado'        , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Requisitando suspensão de indenização'     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Ressarcimento de Franquia'                 , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Restituição do prêmio ou contribuição'     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Roubo de carga'                            , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Sigilo e confidencialidade'                , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Sucumbência'                               , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Sucumbência Contratual'                    , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Sucumbência Extracontratual'               , 'VL_RISCO2', 'PC_RISCO2'})
   aadd({'Tombamento de carga'                       , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Transferência de reservas'                 , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Transferência de Titularidade/Salvado'     , 'VL_RISCO' , 'PC_RISCO' })
   aadd({'Veículo do terceiro na contra-mão'         , 'VL_RISCO' , 'PC_RISCO' })

   lcWHERE  :=  'pasta_contingencia.nr_pasta in (select nr_pasta from pasta where TP_PASTA in'
   lcWHERE  +=  '(select TP_PASTA from pasta_config where '
   lcWHERE  +=  '(layout_pasta = '+DLAP+'Civel2'+DLAP+ 'or layout_pasta = '+DLAP+'Civel_adm_cade'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'Civel_securit_com_sinistro'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'Civel_securit_sem_sinistro'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'DPVAT'+DLAP+')))'

   if db_select(laFIELDS,'pasta_contingencia',laJOIN,{lcWHERE}) == -1
      error_sys(db_error())
   endif

   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      db_begin()
      for lnXX := 2 to len(laRESULT)
          if laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')] > 0
             laSAVE     := {{'NR_PASTA','PEDIDO_PROCESSO','VL_PEDIDO','DT_RISCO','DT_RISCO2'}}
             laSAVE_AUX := {laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')],;
                            laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')],;
                            laRESULT[lnXX,ascan(laRESULT[1],'VL_PEDIDO')],;
                            laRESULT[lnXX,ascan(laRESULT[1],'DT_RISCO')],;
                            laRESULT[lnXX,ascan(laRESULT[1],'DT_RISCO')]}
             lcEVAL := laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')]
             lnYY := ascan(laCAMPOS,{|xvetor|xvetor[1] == lcEVAL})
             if lnYY > 0
                aadd(laSAVE[1],laCAMPOS[lnYY,2])
                aadd(laSAVE[1],laCAMPOS[lnYY,3])
                aadd(laSAVE_AUX,laRESULT[lnXX,ascan(laRESULT[1],'VL_RISCO')])
                aadd(laSAVE_AUX,laRESULT[lnXX,ascan(laRESULT[1],'PC_RISCO')])
             endif
             aadd(laSAVE,laSAVE_AUX)
             lcWHERE := 'NR_PASTA = '+ alltrim(str(laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')]))
             lcWHERE += ' AND PEDIDO_PROCESSO = '+DLAP+laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')]+DLAP
             if db_replace(laSAVE,'pasta_valor_pedidos',{lcWHERE}) == -1
                db_rollback()
                error_sys(db_error())
             endif
          endif
      next lnXX
      db_commit()
   endif

   // Bloco que atualiza dados originados da tabela pasta, cujo pasta_valor_pedidos.VL_RISCO + pasta_valor_pedidos.VL_RISCO2 == 0

   laFIELDS := {'pasta_valor_pedidos.NR_PASTA',;
                'pasta_valor_pedidos.PEDIDO_PROCESSO',;
                'pasta_valor_pedidos.VL_PEDIDO',;
                'pasta.DT_RISCO',;
                'pasta_valor_pedidos.VL_RISCO',;
                'pasta_valor_pedidos.PC_RISCO',;
                'pasta_valor_pedidos.VL_RISCO2',;
                'pasta_valor_pedidos.PC_RISCO2'}

   laJOIN   := {{2,'pasta','pasta_valor_pedidos.NR_PASTA = pasta.NR_PASTA'}}

   lcWHERE  :=  'pasta_valor_pedidos.nr_pasta in (select nr_pasta from pasta where TP_PASTA in'
   lcWHERE  +=  '(select TP_PASTA from pasta_config where '
   lcWHERE  +=  '(layout_pasta = '+DLAP+'Civel2'+DLAP+ 'or layout_pasta = '+DLAP+'Civel_adm_cade'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'Civel_securit_com_sinistro'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'Civel_securit_sem_sinistro'+DLAP
   lcWHERE  +=  ' or layout_pasta = '+DLAP+'DPVAT'+DLAP+')))'

   if db_select(laFIELDS,'pasta_valor_pedidos',laJOIN,{lcWHERE}) == -1
      error_sys(db_error())
   endif

   laRESULT := db_fetchall()
   if len(laRESULT) > 1
      db_begin()
      for lnXX := 2 to len(laRESULT)
          if laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')] > 0 .and. ((laRESULT[lnXX,ascan(laRESULT[1],'VL_RISCO')] + laRESULT[lnXX,ascan(laRESULT[1],'VL_RISCO2')]) == 0)
             lcWHERE := 'NR_PASTA = '+ alltrim(str(laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')]))
             lcWHERE += ' AND PEDIDO_PROCESSO = '+DLAP+laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')]+DLAP
             laSAVE     := {{'NR_PASTA','PEDIDO_PROCESSO','VL_RISCO','PC_RISCO','DT_RISCO','DT_RISCO2','VL_RISCO2', 'PC_RISCO2'}}
             // Selecionar dados da tabela pasta
             if db_select({'OBJETO','TP_PASTA','DT_RISCO','VL_RISCO','PC_RISCO','VL_RISCO2','PC_RISCO2'},'pasta',,{'NR_PASTA = '+alltrim(str(laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')]))}) == -1
                error_sys(db_error())
             endif
             laRESULT2 := db_fetchall()
             if len(laRESULT2) > 1
                laSAVE     := {{'NR_PASTA','PEDIDO_PROCESSO','VL_RISCO','PC_RISCO','DT_RISCO','DT_RISCO2','VL_RISCO2', 'PC_RISCO2'}}
                laSAVE_AUX := {laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')],;
                               'MIGRAÇÃO - '+laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')],;
                               laRESULT2[2,ascan(laRESULT2[1],'VL_RISCO')],;
                               laRESULT2[2,ascan(laRESULT2[1],'PC_RISCO')],;
                               laRESULT2[2,ascan(laRESULT2[1],'DT_RISCO')],;
                               laRESULT2[2,ascan(laRESULT2[1],'DT_RISCO')],;
                               laRESULT2[2,ascan(laRESULT2[1],'VL_RISCO2')],;
                               laRESULT2[2,ascan(laRESULT2[1],'PC_RISCO2')]}
                aadd(laSAVE,laSAVE_AUX)
                if db_update(laSAVE,'pasta_valor_pedidos',{lcWHERE}) == -1
                   db_rollback()
                   error_sys(db_error())
                endif
                // Atualização do campo objeto na tabela pasta
                lcEVAL := strtran(laRESULT2[2,ascan(laRESULT2[1],'OBJETO')],laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')] ,'MIGRAÇÃO - '+laRESULT[lnXX,ascan(laRESULT[1],'PEDIDO_PROCESSO')] )
                if db_replace({{'OBJETO'},{lcEVAL}},'pasta',{'NR_PASTA = '+alltrim(str(laRESULT[lnXX,ascan(laRESULT[1],'NR_PASTA')]))}) == -1
                   db_rollback()
                   error_sys(db_error())
                endif
                // Inserção do novo registro na tabela pasta_objeto
                if db_replace({{'TP_PASTA','OBJETO'},{laRESULT2[2,ascan(laRESULT2[1],'TP_PASTA')],lcEVAL}},'pasta_objeto',{'TP_PASTA = '+DLAP+laRESULT2[2,ascan(laRESULT2[1],'TP_PASTA')]+DLAP + ' AND OBJETO = '+ DLAP+lcEVAL+DLAP}) == -1
                   db_rollback()
                   error_sys(db_error())
                endif
             endif
          endif
      next lnXX
      db_commit()
   endif
return


/*
* Data Criação: 02.06.2007 - Glauber
* Function.....: wdgtp_pasta()
* Objetivo.....: Retornar o tipo de pasta de uma determinada pasta.
*
* Parâmetros:
*    fcNR_PASTA.: Número da pasta
*    ...........:
*
* Retorno: Tipo da pasta
*/

Function wdgtp_pasta(fcNR_PASTA)

    local laCACHE   := {},;
          laRESULT  := {} as array

    local lcTP_PASTA := '',;
          lcNR_PASTA := '',;
          lcRETORNO  := '' as string

    if empty(fcNR_PASTA)
       return('')
    endif
    // Recuperar o valor no cache
    laCACHE    := str2array(WDataGlobal('TP_PASTA'),'|')
    if ! empty(laCACHE[1]) .and. ! empty(laCACHE[2])
       lcNR_PASTA := laCACHE[1]
       lcTP_PASTA := laCACHE[2]
    endif
    if val(fcNR_PASTA) == val(lcNR_PASTA)
       lcRETORNO := lcTP_PASTA
    else
       if db_select({'TP_PASTA'},'pasta',,{'NR_PASTA = '+fcNR_PASTA}) == -1
          error_sys(db_error())
       endif
       laRESULT := db_fetchall()
       if len(laRESULT) == 1
          lcRETORNO := ''
       else
          lcRETORNO := laRESULT[2,1]
          // Atualizar o cache novamente
          WDataGlobal('TP_PASTA',(fcNR_PASTA+'|'+lcRETORNO))
       endif
    endif

return(lcRETORNO)


//-----------------------------------------------------------------------------------------------------
/*
* Function..: Verifica_relacionamento(fcNR_PASTA,fcTp_pasta)
* Objetivo..: Verificar se há pasta relacionadas
* ParÃ¢metros:
*    fcNR_PASTA.: Numero da Pasta
* Retorno...:
*   lcRel:=   'P'-PAI     'F'-FILHO
*/
function Verifica_relacionamento(fcNR_PASTA,fcTP_PASTA)

   local laRES         := {} as array
   local laPASTACONFIG := {} as array

   local lcRel                := '' as string
   local lcLITS_POSICAO_PARTE := '' as string
   local lcLITS_MASTER        := '' as string
   
   if db_select({'pasta_config.LITS_POSICAO_PARTE','pasta_config.LITS_POSICAO_MASTER'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) == -1 // pasta_config verifica LITS    
      error_sys(db_error())
      return(lcRel)
   endif
   laPASTACONFIG:= db_fetchrow()

   if len(lapastaconfig) > 0
      lcLITS_POSICAO_PARTE := laPASTACONFIG[1]
      lcLITS_MASTER := laPASTACONFIG[2]
   endif

   if lcLITS_POSICAO_PARTE = '' .or. lcLITS_MASTER = ''
      return(lcrel)
   endif
               
   if db_select({'NR_PASTA','NR_PASTA_FILHO','TP_PASTA_RELACIONAMENTO'},'pasta_relacionamento',,{'NR_PASTA='+fcNR_PASTA}) == -1
      error_sys(db_error())
   endif
   laRES := db_fetchall()

   if len(laRES) > 1
      for ii:=2 to len(laRes)
          if laRes[ii,3] = lcLITS_POSICAO_PARTE 
             lcRel := 'P'
          endif
      next ii
   else 
      if db_select({'NR_PASTA','NR_PASTA_FILHO','TP_PASTA_RELACIONAMENTO'},'pasta_relacionamento',,{'NR_PASTA_FILHO='+fcNR_PASTA}) == -1
         error_sys(db_error())
      endif
      laRES := db_fetchall()
      if len(laRES) > 1
         for ii:=2 to len(laRes)
             if laRes[ii,3] = lcLITS_POSICAO_PARTE .or. laRes[ii,3] = lcLITS_MASTER
                lcRel := 'F'
             endif
         next ii    
      endif   
   endif
      
Return(lcRel)

//---------------------------------------------------------------------------------------------------------------------
/*
* Function..: Gerar_Abas(faPARAMS,fcNR_PASTA,fnFilho)
* Objetivo..: Gerar as tabelas que pertencem a pasta criada
* Parâmetros:
*    fcNM_ABA.: Nome da ABA a ser criada
* Retorno...: nil
*/
function Gerar_Abas(faPARAMS,fcNR_PASTA,fnFilho)

   local lcOBJ_ID    := '' ,;
         lcWhere     := '' ,;
         lcNUR_PASTA := '' ,;
         lcTable     := '' as string
   
   local laRES    := {} as array

   local lnPOS  := 0 ,;
         lnfilho:= 0 ,;
         ii     := 0 as int
     /*
      * Formato do Array laALTERA:           pasta_outraspartes e pasta_relacionamento excluidas da lista
      * Primeira Linha com os cabeçalhos
      * 2.a Linha em diante os dados respectivos
      * Colunas:
      * 1) OBJ_ID        : id do objeto no html
      * 2) TABLE         : tabela a ser realizado o count(*)
      * 3) WHERE         : condição Where
      *
      */
      lcNUR_PASTA := fcNR_PASTA
      lnFilho     := fnFilho

   if len(faPARAMS) > 0

      laALTERA := {{'OBJ_ID',                         'TABLE',                     'WHERE' }}
      aadd(laALTERA,{'mnt_pst_contingencia_html',     'pasta_contingencia',        'NR_PASTA='+lcNUR_PASTA })
      aadd(laALTERA,{'pst_aditivo_contrato_html',     'pasta_contrato_aditivo',    'NR_PASTA='+lcNUR_PASTA })
      aadd(laALTERA,{'pst_anexo_contrato_html',       'pasta_contrato_anexo',      'NR_PASTA='+lcNUR_PASTA })
      aadd(laALTERA,{'psab_jurisprudencia_html',      'pasta_jurisprudencia',      'NR_PASTA='+lcNUR_PASTA })
      aadd(laALTERA,{'psab_div_responsabilidade_html','pasta_div_responsabilidade','NR_PASTA='+lcNUR_PASTA })
//      aadd(laALTERA,{'psab_corporativo_html',       'pasta_cip',                 'NR_PASTA='+lcNUR_PASTA+' and WFIELD="CIP_GERENTE"'})
//      aadd(laALTERA,{'mnt_pst_partes_html',         'pasta_outraspartes',        'NR_PASTA='+lcNUR_PASTA })
//      aadd(laALTERA,{'mnt_ext_andamento_html',      'pasta_andamento',           'NR_PASTA='+lcNUR_PASTA+' and FL_ANDAMENTO_EXTERNO = "S"  and (FL_ANDAMENTO_CANCELADO <> "S" or FL_ANDAMENTO_CANCELADO is null)'})
//      aadd(laALTERA,{'mnt_canc_andamento_html',     'pasta_andamento',           'NR_PASTA='+lcNUR_PASTA+' and FL_ANDAMENTO_CANCELADO="S"'})
//      aadd(laALTERA,{'psab_despesa_html',           'mvt_despesa',               'NR_PASTA='+lcNUR_PASTA })

      for ii := 1 to len(faPARAMS)
         lcOBJ_ID := faPARAMS[ii]
         lnPOS := ascan(laALTERA, { |x| x[1]== lcOBJ_ID })
         if lnPOS > 0 
            lcTable:=laALTERA[lnPOS,2]
            lcWhere:=laALTERA[lnPOS,3]
            sincroniza_pasta(lcNUR_PASTA,lnFilho,lcTABLE,lcWhere)  
         endif
      next ii
 endif
return(nil)

//---------------------------------------------------------------------------------------------------------------------
/*
* Function..: sincroniza_pasta()
* Objetivo..: rotina padrao para criar uma tabela a partir de outra
*   fcNR_PASTA: Numero da pasta
*   fcTP_PASTA: Tipo de pasta
*   fcCIP_PARTE 
*   fcNR_AUTOPROC
* Retorno...: nil
*/
function sincroniza_pasta(fcNR_PASTA,fnNR_POSICAO_FILHO,fcTABLE,fcWHERE)

  local ii := 0 as int
  
  local  laFIELDS     := {} ,;
         laSAVE       := {} ,;
         laPUT        := {} ,;
         laSAVE_AUX   := {} ,;
         laFIELDS_AUX := {} as array

  local llReturn :=(.f.) as logical

  local lcTbale := '' as string
  local lnAndamento := 0 ,;
        lnPenhora   := 0 ,;
        lnControle  := 0 ,;
        lnAuto      := 0 as int
 
  lcTable := fcTable
  
         laFIELDS := structtable(WSet("DB_ACTIVE"),fcTABLE,1,'N')
         if db_select(laFIELDS,fcTABLE,,{fcWHERE}) == -1
            error_sys(db_error())
            return(nil)
         endif
         laPUT := db_fetchall()
         if len(laPUT) > 1 
            for ii := 1 to len(laFIELDS)
                aadd(laFIELDS_AUX,laFIELDS[ii])     // joga nome dos campos para a tabela aux
            next ii
            aadd(laSAVE,laFIELDS_AUX)
            for ii := 2 to len(laPUT)
                for cc := 1 to len(laFIELDS_AUX) 
                    If laPut[1,cc] == 'NR_ANDAMENTO' 
                       lnAndamento:= laPUT[ii,cc]
                    endif   
                    If laPut[1,cc] == 'NR_AUTOPROC'
                       lnAuto:= laPUT[ii,cc]
                    endif   
                    If laPut[1,cc] == 'NR_PENHORA'
                       lnPenhora:= laPUT[ii,cc]
                    endif   
                    If laPut[1,cc] == 'NR_CONTROLE'
                       lnControle:= laPUT[ii,cc]
                    endif   
                    llReturn:=campo_autoinc(lcTABLE,laPUT[1,cc])
                    if  llReturn 
                        laPUT[ii,cc] := '0'
                    endif 
                    if laPUT[1,cc]  == 'NR_PASTA'             // movendo o conteudo 
                       laPUT[ii,cc] := str(fnNR_POSICAO_FILHO)
                    elseif laPUT[1,cc]  == 'WPKEY_NUM'             // movendo o conteudo 
                           laPUT[ii,cc] := str(fnNR_POSICAO_FILHO)
                    elseif laPUT[1,cc]  == 'NR_RELACAO_ANDAMENTO'             // movendo o conteudo 
                       laPUT[ii,cc] := str(lnAndamento)
                    elseif laPUT[1,cc]  == 'NR_AUTO_RELACAO'             // movendo o conteudo 
                       laPUT[ii,cc] := str(lnAuto)
                    elseif laPUT[1,cc]  == 'NR_PENHORA_RELACAO'             // movendo o conteudo 
                       laPUT[ii,cc] := str(lnPenhora)
                    elseif laPUT[1,cc]  == 'NR_GARANTIA_RELACAO'             // movendo o conteudo 
                       laPUT[ii,cc] := str(lnControle)
                    endif 
                    aadd(laSAVE_AUX,laPUT[ii,cc])
                    
                next cc 
                aadd(laSAVE, laSAVE_AUX)  
               
                if db_insert(laSAVE,fcTABLE,) == -1
                   error_sys(db_error())
                endif  
                
                laSAVE:= {}           
                aadd(laSAVE,laFIELDS_AUX)
                laSAVE_AUX:= {}           
            next ii  
         endif 
Return(nil)

//---------------------------------------------------------------------------------------------------------------------
/*
* Function..: campo_autoinc()
* Objetivo..: rotina verificar se o campo é auto incremento e move T ou F
*   faPut: nome do campo para verificar
*   fcTable - Tabela para vrificação
* Retorno...: llRet = .t. or .f.
*/
function campo_autoinc(fcTABLE,faPut)

  local ii := 0 as int
  
  local  laWtable := {} as array
  local  lcAutoInc := '' as string
  local  llRet := (.f.) as logical
  local  lcTable := '' as string
  
  lctabel := fctable 
         lcWhere:='WTABLE ='+DLAP+lcTable+DLAP+'and WFIELDAUTOINC ='+DLAP+faPut+DLAP+'and PROJECT ='+DLAP+'gr5'+DLAP
         if db_select({'WTABLE','WFIELDAUTOINC'},'wtable',,{lcWhere}) == -1
//            error_sys(db_error())
            return(llret)
          endif 
         laWTable := db_fetchrow()
         if len(laWtable) > 0 .and. laWtable[2] <> ''
            lcAutoInc:=laWtable[2]
            llRet:=(.t.)
         endif
Return(llRet)               

//---------------------------------------------------------------------------------------------------------------------
/*
* Function..: Ver_ABA(fcTP_PASTA, fcProgram)
* Objetivo..: Verificar se a ABA filho pode ser alterada
* Parâmetros:
*    fcTp_PASTA.: Tipo de pasta
*    fcProgram  : Nome do programa para verificar
* Retorno...: nil
*/
function Ver_Aba(fcTP_PASTA, fcProgram)

   local laPASTACONFIG        := {} ,;
         laRES                := {} ,;
         laABAS               := {} ,;
         laVAL_ABAS           := {} as array

   local llRet :=(.f.) as logical
//-----------------------------------------------------------------------------------------------
//                      Lista de ABas que nao podem ser alteradas

   if db_select({'LITS_ABAS_NAOCOMUM'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) < 0
      error_sys(db_error())
   endif
   laPastaConfig := db_fetchrow()
   if !empty(laPastaConfig[1])
      laRES := str2array(laPastaConfig[1],',')
      for ii := 1 to len(laRES)
           aadd(laVAL_ABAS,laRes[ii])
      next ii
   endif
    
//---------------------------------------------------------------------------------------------------------------------
//                           Abas que não Grava nas pastas-abas respectivas

   if ascan(laVAL_ABAS,fcprogram) <= 0                           // Não achou replica ascan <= 0 ! achou >0
      llRet:=(.t.)    // se .t. não posso fazer alteraçoes ´so atraves do pai
   endif
Return(llRet)

//-----------------------------------------------------------------------------------------------
/*
* Function..: Montar_filho(fcNR_PASTA, fcTP_pasta)
* Objetivo..: Montar os fihos que pertencem ao pai
* Parâmetros:
*    fcNR_PASTA.: Numero da pasta
* Retorno...: nil
*/
function Montar_filhos(fcNR_PASTA, fcTP_Pasta)

   local laFilho   := {} ,;
         laPASTACONFIG := {} ,;
         laRes     := {} as array

   local lcLITS_POSICAO_PARTE:= '' as string
   local lcLITS_MASTER := ' ' as string
   
   if db_select({'pasta_config.LITS_POSICAO_PARTE','pasta_config.LITS_POSICAO_MASTER'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) == -1 // pasta_config verifica LITS    
      error_sys(db_error())
      return(lafilho)
   endif
   laPASTACONFIG:= db_fetchrow()

   if len(lapastaconfig) > 0
      lcLITS_POSICAO_PARTE := laPASTACONFIG[1]
      lcLITS_MASTER := laPASTACONFIG[2]
   endif

    if db_select({'NR_PASTA','NR_PASTA_FILHO','TP_PASTA_RELACIONAMENTO'},'pasta_relacionamento',,{'NR_PASTA='+fcNR_PASTA}) == -1
        error_sys(db_error())
    endif
    laRES := db_fetchall()

    if len(laRES) > 1
       for ii := 2 to len(laRES)
           if laRes[ii,3] = lcLITS_POSICAO_PARTE 
              aadd(laFILHO,laRES[ii,2])
           endif
       next ii
   endif     
return(laFilho)  

****
* Function xbp2
* Sonia Perdigão - 17/2/2009 10:02:29
* Consistência na exclusão contra a tabela pastas - checagem das tabelas operacionais
* Sonia Perdigão - 18/2/2009 16:39:55
* Retirar aspas simples e duplas de campo caracter evitando erros de query
* **************************
function xbp2(pcTABLE,paJOIN,paWHERE,paORDERBY,pcSORT,paGROUPBY,paLIMIT,pcDBNAME,pnPROG_TYPE,pcTARGET_SRC,pcPROG_SRC,paONCLICK,paBTN_GRID,;
             pcPROGRAM,pcTARGET_MOD,paFLD_JAVA,paQUICK_SCH,paFLDS_HIDDEN,paFLDS_INPUT,paFLDS_GRID,paFLDS_DB,paBTN_LST,paBTN_MNT)

   local laRESULT      := {} ,;
         laFIELDS      := {} as array
   
   local lcACTION      := upper(WGet('ACTIONBP','C')) ,;
         lcWHERE       := '' ,;
         lcBUTTON      := '' ,;
         lcONCLICK     := upper(WGet('CLICK','C')) ,;
         lcVL_FIELD    := '' ,;
         lcCODE        := '' ,;
         lcDELETE      := '' ,;
         lcQUICK_SCH   := upper(alltrim(WGet('QUICK_SEARCH','C'))) ,;
         lcWHERE_QUICK := '' ,;
         lcFLDFILT1    := WGet('FILTER_FIELD1','C') ,;
         lcFLDFILT2    := WGet('FILTER_FIELD2','C') ,;
         lcFLDFILT3    := WGet('FILTER_FIELD3','C') ,;
         lcVL_FILT1    := WGet('FILTER_CONTENT1','C') ,;
         lcVL_FILT2    := WGet('FILTER_CONTENT2','C') ,;
         lcVL_FILT3    := WGet('FILTER_CONTENT3','C') ,;
         lcORDER_FIELD := WGet('ORDER_FIELD','C') ,;
         lcTYPE        := '' as string

   local ii          := 0 ,;
         iiB         := 0 ,;
         lnGOTO_PAGE := WGet('GOTO_PAGE','N'),;
         lnLIMIT1    := 0 ,;
         lnLIMIT2    := 0 ,;
         lnROWS_PAGE := 0 ,;
         lnNR_PAGES  := 0 ,;
         lnPAGE_INI  := 0 ,;
         lnPAGE_FIN  := 0 as int

   local llADD_COL := .F. ,;
         llERRO    := .F. as logical

   //Untyped variables
   local lnCOL_BTN     //Pode receber NIL ao invés de um inteiro

   local luVL_FIELD, luVALUE_DEF

   private lcFORMOPENER  := alltrim(WGet('FORMOPENER','C')) ,;
           lcJAVAFIELDS  := alltrim(WGet('JAVAFIELDS','C')) ,;
           lcSHOW_MENU   := upper(alltrim(WGet('SHOW_MENU','C')))

   private laLABELS    := {} ,;
           laSAVE      := {} ,;
           laSAVE_AUX  := {} ,;
           laCLONE_RES := {} ,;
           laSTRUCT    := {} ,;
           laWICDO     := {} ,;
           laPAR_BTN   := {} ,;
           laDT_STR    := {'VARCHAR','CHAR','TINYTEXT','TEXT','MEDIUMTEXT','LONGTEXT','DATETIME','TIMESTAMP','TIME','YEAR'},;
           laDT_DEC    := {'FLOAT','DOUBLE','DOUBLE PRECISION','REAL','DECIMAL','NUMERIC'},;
           laDT_INT    := {'TINYINT','SMALLINT','MEDIUMINT','INT','INTEGER','BIGINT'},;
           laCOUNT     := {} ,;
           laPAGES     := {} ,;
           laVALUE_SCH := {}

   private iiC    := 0 ,;
           lnLINE := 0


//wout('')
//? 'Tipo Programa:',pnPROG_TYPE
//? 'Ação.........:',lcACTION

   //Altera o action do form build_program, chamando o LST origem
   if valtype(pcPROG_SRC) != 'U' .or. !empty(pcPROG_SRC)
      WPut('FORM_ACTION',wic_action('wicaction_'+pcTARGET_SRC+'/'+pcPROG_SRC))
   endif
   WSet('_USER_INTERFACE','build_program')

   WPut('TITLE','')  //precisa terminar wmd_program!!!

   // Validação de parametros -----------------------------------------------------------------------------------------------
   if valtype(pnPROG_TYPE) == 'U' .or. !(pnPROG_TYPE >= 1 .and. pnPROG_TYPE <= 4)
      walert('xbp: Invalid program type!')
      return(.f.)
   endif

   if (valtype(paBTN_GRID) != 'U' .or. !empty(paBTN_GRID)) .and.  (valtype(pcPROGRAM) == 'U' .or. empty(pcPROGRAM))
      walert('xbp: Defined buttons, but the target program was not defined!')
      return(.f.)
   endif

   /*
   if (valtype(paFLDS_INPUT) != 'U' .or. !empty(paFLDS_INPUT)) .and. (pnPROG_TYPE==1 .or. pnPROG_TYPE==2)
      walert('xbp: Input fields not defined!')
      return(.f.)
   else
      if len(paFLDS_INPUT[1]) > 6
         walert('xbp: Invalid length array!')
         return(.f.)
      elseif len(paFLDS_INPUT[1]) < 6
         for ii := 1 to len(paFLDS_INPUT)
             for iiC := len(paFLDS_INPUT[ii]) to 6

             next iiC
         next ii
      endif
   endif
   */

   if valtype(pcTABLE) == 'U' .or. empty(pcTABLE)
      walert('xbp: Table not defined!')
      return(.f.)
   endif

   if pnPROG_TYPE == 3 .and. (valtype(paFLD_JAVA) == 'U' .or. empty(paFLD_JAVA))
      putERROR('xbp: Javascript parameters not defined')
      return(.f.)
   endif
   // Validação de parametros -----------------------------------------------------------------------------------------------

   if valtype(paFLDS_DB) == 'U' .or. empty(paFLDS_DB)
      paFLDS_DB := structtable(WSet("DB_ACTIVE"),pcTABLE,1,'A') //Campos
   endif
   laFIELDS    := structtable(WSet("DB_ACTIVE"),pcTABLE,1,'A')  // Campos
   laLABELS    := structtable(WSet("DB_ACTIVE"),pcTABLE,11,'A') // Labels
   laSTRUCT    := structtable(WSet("DB_ACTIVE"),pcTABLE,,'A')   // Estrutura completa da tabela
   paWHERE     := iif(valtype(paWHERE) == 'U',{},paWHERE)
   paORDERBY   := iif((valtype(paORDERBY) == 'U' .or. valtype(paORDERBY)==NIL),{},paORDERBY)
   pcSORT      := iif(valtype(pcSORT) == 'U','A',pcSORT)
   lnGOTO_PAGE := iif(lnGOTO_PAGE <= 0,1,lnGOTO_PAGE)
   lcSHOW_MENU := iif(empty(lcSHOW_MENU),'Y',lcSHOW_MENU)

   for ii := 1 to len(laFIELDS)
       laFIELDS[ii] := pcTABLE+'.'+laFIELDS[ii]
   next ii

   if len(laSTRUCT) > 0

      //Exibe menus apenas para opções 1,2,4 e quando o flag SHOW_MENU for Y
      if pnPROG_TYPE != 3 .and. lcSHOW_MENU == 'Y'
         WPut('ifMENU',.T.)
      endif

      //Se for chamada à manutenção listagems/manutenção, cria os campos na UI
      if pnPROG_TYPE == 1 .or. pnPROG_TYPE == 2 .or. !empty(lcACTION)
         if pnPROG_TYPE == 2
            lcACTION := iif(empty(lcACTION),'NEW',lcACTION)
         endif

         if at(lcACTION,'NEW ALTER') > 0  .or. (lcACTION == 'DELETE' .and. pnPROG_TYPE == 2)
            create_form2(pcTARGET_MOD,pcPROGRAM,paFLDS_HIDDEN,paFLDS_INPUT,laSTRUCT,pnPROG_TYPE,paBTN_MNT,lcACTION)
         endif

         /*Tratamento dos paramentros recebidos da URL para a formação da condição WHERE
         * O evento OnClick do grid foi tratado por L-Linha e B-Botao pois o array de parâmetros do click na linha
         * tem o formato diferente do array de parâmetros do click em botões
         */

         /* Retorno da função structtable()
         *  1  {{'WFIELD'      ,'CD_SERVICO'       },;
         *  2   {'WTYPE'       ,'SMALLINT'         },;
         *  3   {'WSIZE'       ,4                  },;
         *  4   {'WFLOAT'      ,0                  },;
         *  5   {'WPICTURE'    ,'9.999'            },;
         *  6   {'WDEFAULT'    ,''                 },;
         *  7   {'WNOTNULL'    ,'Y'                },;
         *  8   {'WZEROFILL'   ,'Y'                },;
         *  9   {'LABEL_SCREEN','Cód. Serviço'     },;
         * 10   {'LABEL_REPORT','Cód. Serviço'     },;
         * 11   {'NM_HELP'     ,''                 },;
         * 12   {'WEXTRA'      ,'Código do serviço'}}
         *
         *      {{"CD_CARGO","NM_CARGO"},;
         *      {{"CD_CARGO","SMALLINT","3","0","999","Y","Y","","Y","Y","Cód. Cargo","Cód. Cargo"},;
         *       {"NM_CARGO","VARCHAR","30","0","","","","","Y","","Cargo","Cargo"}},;
         *      {"PRIMARY","CD_CARGO"},
         *      {"cargo","Cargo","Cargos"}}
         */

         // L - Click na linha do grid
         // D - Click no botão excluir
         // F - Click no botão salvar
         if lcONCLICK == 'L' .or. lcONCLICK == 'D' .or. lcONCLICK == 'F'
            for iiC := 1 to len(paONCLICK)
                if upper(paONCLICK[iiC,1]) != 'ACTION' .and. valtype(paONCLICK[iiC,3]) != 'U'
                   if paONCLICK[iiC,3] == '*'
                      lnLINE := ascan(laSTRUCT[2],{|x| x[1]==paONCLICK[iiC,1]})
                      if lnLINE > 0
                         if iiC > 1
                            lcWHERE += ' and '
                         endif
                         do case
                            case ascan(laDT_STR,upper(alltrim(laSTRUCT[2][lnLINE,2]))) > 0       //Tipos string
                                 lcVL_FIELD := strtran(WGet(paONCLICK[iiC,1],'C'),CHR(34),'')
//                                 lcVL_FIELD := strtran(WGet(paONCLICK[iiC,1],'C'),CHR(39),'')
                                 lcVL_FIELD := strtran(lcVL_FIELD,CHR(39),'')
                                 lcVL_FIELD := DLAP+alltrim(lcVL_FIELD)+DLAP
********* alteração efetuada para não permitir a digitação de aspas simples e duplas pelo usuário
//                                 lcVL_FIELD := DLAP+alltrim(WGet(paONCLICK[iiC,1],'C'))+DLAP
                            case ascan(laDT_DEC,upper(alltrim(laSTRUCT[2][lnLINE,2]))) > 0 .or.;
                                 ascan(laDT_INT,upper(alltrim(laSTRUCT[2][lnLINE,2]))) > 0       //Tipos float e int
                                 lcVL_FIELD := alltrim(WGet(paONCLICK[iiC,1],'C'))
                            case ascan(laDT_DATE,upper(alltrim(laSTRUCT[2][lnLINE,2]))) > 0      //Tipos Data
                                 lcVL_FIELD := alltrim(dtoc(WGet(paONCLICK[iiC,1],'D')))
                         endcase
                         lcWHERE += paONCLICK[iiC,1]+'='+lcVL_FIELD
                      else
                         puterror('xbp: ('+alltrim(str(procline()))+') - Field "'+paONCLICK[iiC,1]+'" not found')
                      endif
                   endif
                endif
            next iiC
         elseif lcONCLICK == 'B' //Click nos botões dentro da grid
            walert('Tratamento do click no botao dentro do grid ainda não implementado!')
            return(.f.)
         endif

         if lcACTION == 'NEW'
            if gbWAC_CREATE
               setfieldvalues2(paFLDS_INPUT) //Inicializa campos com valores default
            else
               if pnPROG_TYPE == 1
                  lcACTION := ''
                  puterror('xbp: ('+alltrim(str(procline()))+') - Sem permissão de criação')
                  walert('Sem permissão de criação')
               endif
            endif
         elseif lcACTION == 'ALTER'
            if gbWAC_READ
               if db_select(paFLDS_DB,pcTABLE,,{lcWHERE}) == -1
                  error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laRESULT := db_fetchrow()
               if len(laRESULT) > 0
                  lcCODE := ''
                  for iiC := 1 to len(paFLDS_DB)

                     //Enviando dados para o form
                     lnLINE := ascan(paFLDS_INPUT,{|x| x[1]==paFLDS_DB[iiC]})
                     if lnLINE > 0
                        if paFLDS_INPUT[lnLINE,1] != NIL .or. !empty(paFLDS_INPUT[lnLINE,1])
                           luVALUE_DEF := iif(paFLDS_INPUT[lnLINE,5] != NIL,paFLDS_INPUT[lnLINE,5],DLMT+''+DLMT)

                           // Inicializa com valores default os objetos do tipo checkbox e combobox
                           if paFLDS_INPUT[lnLINE,2] == 1 .or. paFLDS_INPUT[lnLINE,2] == 2
                              WPut(paFLDS_DB[iiC]+'_OPT',eval({|| &luVALUE_DEF}))
                              if paFLDS_INPUT[lnLINE,2] == 2
                                 WPut(paFLDS_DB[iiC],eval({|| &luVALUE_DEF}))
                              endif
                           endif
                           WPut(paFLDS_DB[iiC],laRESULT[ascan(paFLDS_DB,paFLDS_INPUT[lnLINE,1])])
                        endif
                     endif

                     //Enviando dados para URL do botao Excluir
                     lnLINE1 := ascan(paONCLICK,{|x| x[1]==paFLDS_DB[iiC]})
                     if lnLINE1 > 0
                        if paONCLICK[lnLINE1,3] == '*'
                           if iiC > 1
                              lcCODE   += '&'
                              lcDELETE += ' ][ '
                           endif
                           lcCODE += paFLDS_DB[iiC]+'='
                           luVL_FIELD := laRESULT[ascan(paFLDS_DB,paONCLICK[lnLINE1,1])]
                           do case
                              case valtype(luVL_FIELD) == 'C'
                                   lcCODE   += alltrim(luVL_FIELD)
                                   lcDELETE += alltrim(luVL_FIELD)
                              case valtype(luVL_FIELD) == 'N'
                                   lcCODE   += alltrim(str(luVL_FIELD))
                                   lcDELETE += alltrim(str(luVL_FIELD))
                              case valtype(luVL_FIELD) == 'D'
                                   lcCODE   += alltrim(dtoc(luVL_FIELD))
                                   lcDELETE += alltrim(dtoc(luVL_FIELD))
                           endcase
                        endif
                     endif
                  next iiC
                  if !empty(lcCODE)
                     WPut('SCRIPT_DELETE','onclick="javascript:if (excluir('+DLAP+'['+lcDELETE+']'+DLAP+')) '+;
                                          'document.location='+DLAP+wic_action('wicaction_'+pcTARGET_SRC+'/'+pcPROG_SRC)+;
                                          '?ACTIONBP=DELETE&CLICK=D&SHOW_MENU='+lcSHOW_MENU+'&FORMOPENER='+lcFORMOPENER+;
                                          '&JAVAFIELDS='+lcJAVAFIELDS+'&'+lcCODE+DLAP+';"')
//                     lacompara1 := {rtrim(lcdelete)}
//                     lacompara := {substr(lccode,1,(len(rtrim(lccode))- len(rtrim(lcdelete)) - 1))}
                  endif
               endif
            else
               lcACTION := ''
               puterror('xbp: ('+alltrim(str(procline()))+') - Sem permissão de criação')
               walert('Sem permissão para leitura/alteração')
            endif
         elseif lcACTION == 'SAVE' .and. gbWAC_WRITE
//            wout(debug2(paflds_input),,200)
//            wout(debug2(paFLDS_DB),,200)
//            wout(debug2(pctable),,200)
//            wout(debug2(lastruct),,200)
            for iiC := 1 to len(paFLDS_INPUT) //Validação de campos obrigatórios
                if paFLDS_INPUT[iiC,1] != NIL .or. !empty(paFLDS_INPUT[iiC,1])    //Linha vazia ?
                   if paFLDS_INPUT[iiC,3] != 'Y' .and. paFLDS_INPUT[iiC,4] == 'Y' //Campo Read/Write e obrigatorio ?
                      if empty(alltrim(WGet(paFLDS_INPUT[iiC,1],'C'))) .or. alltrim(WGet(paFLDS_INPUT[iiC,1],'C')) == '0'
                         walert('O campo '+DLMT+;
                                laLABELS[ascan(laFIELDS,iif(at('.',paFLDS_INPUT[iiC,1])==0,;
                                                            pcTABLE+'.'+paFLDS_INPUT[iiC,1],;
                                                            paFLDS_INPUT[iiC,1]))]+DLMT+' não pode ser deixado em branco!')
                         create_form2(pcTARGET_MOD,pcPROGRAM,paFLDS_HIDDEN,paFLDS_INPUT,laSTRUCT,pnPROG_TYPE,paBTN_MNT)
                         get2put()
                         setfieldvalues2(paFLDS_INPUT)
                         llERRO := .T.
                         exit
                      endif
                   endif
                endif
            next iiC

            if !llERRO //Gravação
               for iiC := 1 to len(paFLDS_INPUT)
                   if paFLDS_INPUT[iiC,1] != NIL
                      aadd(laSAVE_AUX,paFLDS_INPUT[iiC,1])
                   endif
               next iiC
               aadd(laSAVE,laSAVE_AUX)
               laSAVE_AUX := {}
               for iiC := 1 to len(paFLDS_INPUT)
                   if paFLDS_INPUT[iiC,1] != NIL
                   
* 18/2/2009 16:39:27 - Sonia Perdigão                   
                      x1 := wget(paFLDS_INPUT[iiC,1])
                      x1 := strtran(x1,chr(39),'')
                      x1 := strtran(x1,chr(34),'')

                      *** Rufino  11/06/2015 14:01:18
                      if valtype(x1) == 'C'

**                         walert('oi')
                         x1 := html2str(x1)

                      endif
                      ***


                      aadd(laSAVE_AUX,x1)
*                      aadd(laSAVE_AUX,paFLDS_INPUT[iiC,1])
                   endif

               next iiC
               aadd(laSAVE,laSAVE_AUX)
               if db_replace(laSAVE,pcTABLE,{lcWHERE}) == -1
                  error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
               endif

               if pnPROG_TYPE == 2
                  create_form2(pcTARGET_MOD,pcPROGRAM,paFLDS_HIDDEN,paFLDS_INPUT,laSTRUCT,pnPROG_TYPE,paBTN_MNT) //Cria/Recria form de manutenção
                  setfieldvalues2(paFLDS_INPUT)  //Reinicializa campos com valores default
               endif

               mkjsreturn(lcFORMOPENER,lcJAVAFIELDS,pcTABLE,laSAVE) //Cria JS retornando os dados gravados ao form opener

               lcACTION := '' //Limpa a ação para forçar a construção do lst logo abaixo
            endif
         elseif lcACTION == 'DELETE' .and. gbWAC_DELETE
            if pcTABLE != 'ocorrencia_pedido'
               if db_select({'count(*)'},'pasta',,{lcWHERE}) == -1
                  error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laCOUNT := db_fetchrow()
               if laCOUNT[1] > 0 
                  walert('Existem pastas relacionadas a este conteudo.\n     Registro nao pode ser excluido!')
               else         
                  if db_delete(pcTABLE,lcWHERE) == -1
                     lnERROR_DB := at('violates foreign key',db_error())
                     if lnERROR_DB > 0
                        walert('Ainda existem informações cadastradas relacionadas a este Item')
                     else   
                        error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
                     endif   
                  endif
               endif
            else
               //Para testar se a tabela tem foreign key
               if db_delete(pcTABLE,lcWHERE) == -1
                  lnERROR_DB := at('violates foreign key',db_error())
                  if lnERROR_DB > 0
                     walert('Ainda existem informações cadastradas relacionadas a este Item')
                  else   
                     error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
                  endif   
               endif
            endif       
            if pnPROG_TYPE == 2
               create_form2(pcTARGET_MOD,pcPROGRAM,paFLDS_HIDDEN,paFLDS_INPUT,laSTRUCT,pnPROG_TYPE,paBTN_MNT) //Cria/Recria form de manutenção
               setfieldvalues2(paFLDS_INPUT) //Reinicializa campos com valores default
            endif
            lcACTION := '' //Limpa a ação para forçar a construção do lst logo abaixo
         elseif lcACTION == 'EXECSEARCH' //Botao localizar do MNT
            for iiC := 1 to len(paFLDS_INPUT)
                //Os campos TEXT são ignorados pois em BDs como sybase,postgresql a pesquisa em campos BLOB/text não é permitida
                if at(wmd_fieldtype(paFLDS_INPUT[iiC,1]),'TINYTEXT TEXT MEDIUMTEXT LONGTEXT') <= 0 .and. paFLDS_INPUT[iiC,1] != NIL
                   luVL_FIELD  := alltrim(WGet(paFLDS_INPUT[iiC,1],'C'))
                   luVALUE_DEF := paFLDS_INPUT[iiC,5]
                   if luVALUE_DEF != NIL
                      luVALUE_DEF := eval({|| &luVALUE_DEF})
                      do case
                         case valtype(luVALUE_DEF) == 'I' .or. valtype(luVALUE_DEF) == 'N'
                              luVALUE_DEF := alltrim(str(luVALUE_DEF))
                         case valtype(luVALUE_DEF) == 'D'
                              luVALUE_DEF := dtoc(luVALUE_DEF)
                         case valtype(luVALUE_DEF) == 'A'
                              luVALUE_DEF := ''
                      endcase
                   else
                      luVALUE_DEF := ''
                   endif

                   //Pula campo autoincrement, campos vazios, campos do tipo TEXT e campos que possuem conteúdo igual ao valor default
                   //O autoincrement é ignorado para evitar que a palavra 'New' seja inserida no where
                   if luVL_FIELD != 'New' .and. !empty(luVL_FIELD) .and. luVL_FIELD != '0' .and. luVL_FIELD != '/  /' .and.;
                      luVALUE_DEF != luVL_FIELD
                      do case
                         case wmd_wfieldtype(paFLDS_INPUT[iiC,1]) == 'C'
                              laVALUE_SCH := str2array(luVL_FIELD,chr(32))
                              lcWHERE := '('
                              for iiB := 1 to len(laVALUE_SCH)
                                  if iiB >= 2
                                     lcWHERE += ' and '
                                  endif
// Sonia Perdigão - 2/15/2011 5:07:38 PM - com a função UPPER não está localizando os registros
//                                  lcWHERE += 'upper('+paFLDS_INPUT[iiC,1]+')'+' like '+DLAP+'%'+upper(laVALUE_SCH[iiB])+'%'+DLAP
                                  lcWHERE += paFLDS_INPUT[iiC,1]+' like '+DLAP+'%'+laVALUE_SCH[iiB]+'%'+DLAP
                              next iiB
                              lcWHERE += ')'
                              aadd(paWHERE,lcWHERE)
                         case wmd_wfieldtype(paFLDS_INPUT[iiC,1]) == 'N'
                              aadd(paWHERE,paFLDS_INPUT[iiC,1]+'='+alltrim(luVL_FIELD))
                         case wmd_wfieldtype(paFLDS_INPUT[iiC,1]) == 'D'
                              aadd(paWHERE,paFLDS_INPUT[iiC,1]+'='+DLAP+dtos(ctod(luVL_FIELD))+DLAP)
                         otherwise
                              loop
                      endcase
                   endif
                endif
            next iiC
            if pnPROG_TYPE == 2
               create_form2(pcTARGET_MOD,pcPROGRAM,paFLDS_HIDDEN,paFLDS_INPUT,laSTRUCT,pnPROG_TYPE,paBTN_MNT) //Cria/Recria form de manutenção
               get2put()
               setfieldvalues2(paFLDS_INPUT) //Reinicializa campos com valores default
            endif
            lcACTION := '' //Limpa a ação para forçar a construção do lst logo abaixo
         //elseif lcACTION == 'EXECLIST' //Botao localizar do LST
         //   lcACTION := '' //Limpa a ação para forçar a construção do lst logo abaixo
         endif

         //Reenvia os parametros de construção do script JS para retorno dos dados ao form opener
         if !empty(lcFORMOPENER) .and. !empty(lcJAVAFIELDS) .and. lcACTION != 'SAVE'
            WPut('FORMOPENER',lcFORMOPENER)
            WPut('JAVAFIELDS',lcJAVAFIELDS)
            WPut('SHOW_MENU',lcSHOW_MENU)
         endif
      endif

      if ((pnPROG_TYPE == 1 .and. empty(lcACTION)) .or. lcACTION == 'EXECLIST') .or. (pnPROG_TYPE >= 2 .and. pnPROG_TYPE <= 4)
         WPut('ifLST_FORM',.T.)                     //Exibe formulário de pesquisa
         if pnPROG_TYPE == 1 .or. pnPROG_TYPE == 3 .or. pnPROG_TYPE == 4  //Exibe opções de pesquisa
            WPut('ifSEARCH_OPTIONS',.T.)
         endif

         /*
         * Caso o tipo do programa seja 4-Listagem apenas, a ação será ACTION pois os programas chamados pelos
         * links do grid, tratam o nome ACTION. Quando o tipo for diferente de 4, o nome do campo será ACTIONBP, pois este
         * nome é reservado ao BP
         */
         lcCODE := wic_action('wicaction_'+pcTARGET_MOD+'/'+pcPROGRAM+'?'+;
                              iif((pnPROG_TYPE==3 .or. pnPROG_TYPE==4),'ACTION','ACTIONBP')+'=NEW')

         //Cria parametros para construção do JS para retorno dos dados ao form opener, caso algum cadastro seja
         //chamado em um popup
         if pnPROG_TYPE == 3
            lcCODE += '&SHOW_MENU=N&FORMOPENER='+paFLD_JAVA[1]+'&JAVAFIELDS='
            for iiC := 1 to len(paFLD_JAVA[2])
                if iiC > 1
                   lcCODE += '|'
                endif
                lcCODE += paFLD_JAVA[2][iiC,1]+','+paFLD_JAVA[2][iiC,2]
            next iiC
         endif
         WPut('NEW_RECORD_LST',lcCODE) //URL/action do botao novo

         if valtype(paBTN_LST) != 'U' .or. !empty(paBTN_LST) //Botões extras
            laWICDO := {{'BTN_NAME','BTN_LABEL','BTN_ALT','BTN_ACTION'}}
            for ii := 1 to len(paBTN_LST)
                aadd(laWICDO,{paBTN_LST[ii,1],paBTN_LST[ii,2],paBTN_LST[ii,3],paBTN_LST[ii,4]})
            next ii
            WPut('LST_BTN',laWICDO)
         endif

         create_hiddens(paFLDS_HIDDEN)

         if lcACTION == 'EXECLIST' .or. pnPROG_TYPE <> 3

            // Pesquisa Rápida ----------------------------------------------------------------------------------------------------
            if !empty(lcQUICK_SCH) .and. empty(lcVL_FILT1) .and. empty(lcVL_FILT2) .and. empty(lcVL_FILT3)
               WPut('QUICK_SEARCH',lcQUICK_SCH)
               laVALUE_SCH := str2array(lcQUICK_SCH,chr(32))
               if len(laVALUE_SCH) > 0
                  if valtype(paQUICK_SCH) == 'U' .or. empty(paQUICK_SCH)
                     paQUICK_SCH := aclone(paFLDS_GRID)
                  endif
                  for ii := 1 to len(paQUICK_SCH)
                      lcTYPE := iif(at('.',paQUICK_SCH[ii]) > 0,;
                                    wmd_wfieldtype(substr(paQUICK_SCH[ii],at('.',paQUICK_SCH[ii])+1)),;
                                    wmd_wfieldtype(paQUICK_SCH[ii]))
                      if lcTYPE == 'C'
                         if ii >= 2
                            lcWHERE_QUICK += ' or '
                         endif
                         lcWHERE_QUICK += '('
                         for iiC := 1 to len(laVALUE_SCH)
                             if iiC >= 2
                                lcWHERE_QUICK += ' and '
                             endif
                             lcWHERE_QUICK += 'upper('+paQUICK_SCH[ii]+')'+' like '+DLAP+'%'+upper(laVALUE_SCH[iiC])+'%'+DLAP
                         next iiC
                         lcWHERE_QUICK += ')'
                      elseif lcTYPE == 'I' .or. lcTYPE == 'N'
                         lcWHERE_QUICK += '('
                         for iiC := 1 to len(laVALUE_SCH)
                             if iiC >= 2
                                	lcWHERE_QUICK += ' or '
                             endif
                             if val(laVALUE_SCH[iiC]) == 0
                                lcWHERE_QUICK += paQUICK_SCH[ii]+' = 0'
                             else
                                lcWHERE_QUICK += paQUICK_SCH[ii]+' = '+laVALUE_SCH[iiC]
                             endif
                         next iiC
                         lcWHERE_QUICK += ')'
                      endif
                  next ii
                  aadd(paWHERE,lcWHERE_QUICK)
               endif
            endif
            //---------------------------------------------------------------------------------------------------------------------


            // QUANDO lcORDER_FIELD FOR VAZIO, TRATAR PARA EVITAR ORDENAÇÃO EM CAMPOS DO TIPO TEXT OU BLOB (IMAGEM)

            //if empty(lcORDER_FIELD)
            //   lcORDER_FIELD := laLABELS[1]
            //endif

            if !empty(lcVL_FILT1)
               aadd(paWHERE,mkwherelst({{laFIELDS[ascan(laLABELS,lcFLDFILT1)],lcVL_FILT1}}))
               
            endif
            if !empty(lcVL_FILT2)
               aadd(paWHERE,mkwherelst({{laFIELDS[ascan(laLABELS,lcFLDFILT2)],lcVL_FILT2}}))
               
            endif
            if !empty(lcVL_FILT3)
               aadd(paWHERE,mkwherelst({{laFIELDS[ascan(laLABELS,lcFLDFILT3)],lcVL_FILT3}}))
               
            endif
            if !empty(lcORDER_FIELD)
               aadd(paORDERBY,laFIELDS[ascan(laLABELS,lcORDER_FIELD)])
            endif

            /*
            ? 'order by----------------------'
            for x := 1 to len(paORDERBY)
                ? paORDERBY[x]
            next x

            ? 'Where----------------------'
            for x := 1 to len(paWHERE)
                ? paWHERE[x]
            next x

            ? 'Join-----------------------'
            for x := 1 to len(paJOIN)
                ? paJOIN[x,1],paJOIN[x,2],paJOIN[x,3]
            next x
            */

            //Contagem de registros e paginação
            if db_select({'count(*)'},pcTABLE,paJOIN,paWHERE,,pcSORT,paGROUPBY,,pcDBNAME) == -1
               error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
            endif
//            wout('')
            
            laCOUNT := db_fetchrow()
            if laCOUNT[1] > 0 .and. valtype(paLIMIT) == 'U'

               //wout('')

               lnMAX_PAGES := iif(val(WSet('MAX_PAGES'))==0,10,val(WSet('MAX_PAGES'))) // Quantidade de páginas
               lnROWS_PAGE := iif(val(WSet('ROWS_PAGE'))==0,10,val(WSet('ROWS_PAGE'))) // Quantidade de linhas por página
               if lnROWS_PAGE > laCOUNT[1]
                  lnROWS_PAGE := laCOUNT[1]
               endif
               lnNR_PAGES  := laCOUNT[1]/lnROWS_PAGE


               //? 'Nr Registros..:',laCOUNT[1]
               //? 'Maximo de Pág.:',lnMAX_PAGES
               //? 'Linhas por Pag:',lnROWS_PAGE
               //? 'Nr de Pág (a).:',lnNR_PAGES
               //? 'Modulo........:',laCOUNT[1] % lnROWS_PAGE


               if (laCOUNT[1] % lnROWS_PAGE) > 0
                  lnNR_PAGES += 1
               endif
               //lnNR_PAGES := iif(lnNR_PAGES < lnMAX_PAGES,lnNR_PAGES,lnMAX_PAGES)

               //? 'Nr de Pág (b).:',lnNR_PAGES

               lnMAX_PAGES := iif(lnNR_PAGES < lnMAX_PAGES,lnNR_PAGES,lnMAX_PAGES)
               if lnGOTO_PAGE == 1
                  lnPAGE_INI := 1                           // Página inicial
                  lnPAGE_FIN := lnMAX_PAGES                 // Página final
               else
                  if alltrim(WGet('MORE')) == 'Y'              // Visualizar as próximas 10 páginas, se possível
                     lnPAGE_INI := lnGOTO_PAGE
                     lnPAGE_FIN := lnMAX_PAGES+(lnGOTO_PAGE-1)
                     if lnPAGE_FIN > lnNR_PAGES
                        lnPAGE_FIN := lnNR_PAGES
                     endif
                  elseif alltrim(WGet('LESS')) == 'Y'          // Visualizar as 10 páginas anteriores, se possível
                     lnPAGE_INI := lnGOTO_PAGE-lnMAX_PAGES+1
                     lnPAGE_FIN := lnGOTO_PAGE
                  else
                     lnPAGE_INI := WGet('FIRST_PAGE','N')
                     lnPAGE_FIN := WGet('LAST_PAGE','N')
                  endif
               endif

               //? 'Pág inicial...:',lnPAGE_INI
               //? 'Pág final.....:',lnPAGE_FIN

               lcCODE := ''
               aadd(laPAGES,{'PROGRAM_CALL','NR_PAGE'})
               for ii := lnPAGE_INI to lnPAGE_FIN
                   lcCODE := 'wicaction_'+pcTARGET_SRC+'/'+pcPROG_SRC+'?GOTO_PAGE='+alltrim(str(ii))
                   lcCODE += '&FIRST_PAGE='+alltrim(str(lnPAGE_INI))+'&LAST_PAGE='+alltrim(str(lnPAGE_FIN))
                   if ii == lnPAGE_INI
                      lcCODE += '&LESS=Y'
                   endif
                   if ii == lnPAGE_FIN .and. lnPAGE_FIN < lnNR_PAGES
                      lcCODE += '&MORE=Y'
                   endif
                   lcCODE += '&SHOW_MENU='+lcSHOW_MENU+'&FORMOPENER='+lcFORMOPENER+'&JAVAFIELDS='+lcJAVAFIELDS

                   //lcCODE := wic_action('wicaction_'+pcTARGET_SRC+'/'+pcPROG_SRC+'?GOTO_PAGE='+alltrim(str(ii)))+;
                   //                     '&FIRST_PAGE='+alltrim(str(lnPAGE_INI))+'&LAST_PAGE='+alltrim(str(lnPAGE_FIN))+;
                   //                     '&SHOW_MENU='+lcSHOW_MENU+'&FORMOPENER='+lcFORMOPENER+'&JAVAFIELDS='+lcJAVAFIELDS

                   lcCODE := wic_action(lcCODE)
                   //Adiciona campos hidden a URL de paginação, caso eles sejam passados
                   if valtype(paFLDS_HIDDEN) != 'U' .or. !empty(paFLDS_HIDDEN)
                      for iiC := 1 to len(paFLDS_HIDDEN)
                          if at('ACTION',paFLDS_HIDDEN[iiC,1]) <= 0
                             lcCODE += '&'+paFLDS_HIDDEN[iiC,1]+'='+iif(paFLDS_HIDDEN[iiC,2] == nil,'',paFLDS_HIDDEN[iiC,2])
                          endif
                      next iiC
                   endif

                   if pnPROG_TYPE == 1 .or. pnPROG_TYPE == 3 .or. pnPROG_TYPE == 4 //Listagem/Form,Search,Listagem
                      //Adiciona à paginação, os filtros digitados e os campos selecionados para busca e ordernação

                      //Pesquisa avançada -----------------------------------------------------------------------------------------
                      if empty(lcQUICK_SCH)  //Se não for feita pesquisa rápida, gera URL com campos da pesquisa avançada
                         if !empty(lcFLDFILT1)
                            lcCODE += '&FILTER_FIELD1='+lcFLDFILT1
                         endif
                         if !empty(lcVL_FILT1)
                            lcCODE += '&FILTER_CONTENT1='+lcVL_FILT1
                         endif

                         if !empty(lcFLDFILT2)
                            lcCODE += '&FILTER_FIELD2='+lcFLDFILT2
                         endif
                         if !empty(lcVL_FILT2)
                            lcCODE += '&FILTER_CONTENT2='+lcVL_FILT2
                         endif

                         if !empty(lcFLDFILT3)
                            lcCODE += '&FILTER_FIELD3='+lcFLDFILT3
                         endif
                         if !empty(lcVL_FILT3)
                            lcCODE += '&FILTER_CONTENT3='+lcVL_FILT3
                         endif
                      endif
                      //Pesquisa avançada -----------------------------------------------------------------------------------------

                      if !empty(lcORDER_FIELD) //Campo usado na classificação
                         lcCODE += '&ORDER_FIELD='+lcORDER_FIELD
                      endif
                      if !empty(lcQUICK_SCH)   //Conteúdo a pesquisa usando quick search
                         lcCODE += '&QUICK_SEARCH='+lcQUICK_SCH
                      endif
                      lcCODE += '&ACTIONBP=EXECLIST'
                   else
                      if upper(WGet('ACTIONBP','C')) == 'EXECSEARCH'
                         /*
                         * Altera o action para forçar a execução da pesquisa no MNT e adiciona os campos do form na URL (com exceção do MEMO)
                         * para evitar que a busca do usuário seja perdida
                         */
                         lcCODE += '&ACTIONBP=EXECSEARCH'
                         for iiC := 1 to len(paFLDS_INPUT)

                             //Os campos TEXT são ignorados pois em BDs como sybase,postgresql, a pesquisa em campos BLOB/text não é permitida
                             if at(wmd_fieldtype(paFLDS_INPUT[iiC,1]),'TINYTEXT TEXT MEDIUMTEXT LONGTEXT') <= 0 .and. paFLDS_INPUT[iiC,1] != NIL
                                luVL_FIELD  := alltrim(WGet(paFLDS_INPUT[iiC,1],'C'))
                                luVALUE_DEF := paFLDS_INPUT[iiC,5]
                                if luVALUE_DEF != NIL
                                   luVALUE_DEF := eval({|| &luVALUE_DEF})
                                   do case
                                      case valtype(luVALUE_DEF) == 'I' .or. valtype(luVALUE_DEF) == 'N'
                                           luVALUE_DEF := alltrim(str(luVALUE_DEF))
                                      case valtype(luVALUE_DEF) == 'D'
                                           luVALUE_DEF := dtoc(luVALUE_DEF)
                                      case valtype(luVALUE_DEF) == 'A'
                                           luVALUE_DEF := ''
                                   endcase
                                else
                                   luVALUE_DEF := ''
                                endif

                                /*
                                * Pula campo autoincrement, campos vazios e campos do tipo TEXT
                                * O autoincrement é ignorado para evitar que a palavra 'New' seja inserida no where
                                */
                                if luVL_FIELD != 'New' .and. !empty(luVL_FIELD) .and. luVL_FIELD != '0' .and. luVL_FIELD != '/  /' .and.;
                                   luVALUE_DEF != luVL_FIELD
                                   lcCODE += '&'+paFLDS_INPUT[iiC,1]+'='+luVL_FIELD
                                endif
                             endif
                         next iiC
                      else
                         lcCODE += '&ACTIONBP='
                      endif
                   endif
                   aadd(laPAGES,{lcCODE,alltrim(str(ii))})
               next ii
               WPut('ifRESULT',.T.)
               WPut('PAGES',laPAGES)

               //? 'Ir para pag (a):',lnGOTO_PAGE


               lnLIMIT1 := iif(lnGOTO_PAGE == 1,0,((lnGOTO_PAGE*lnROWS_PAGE)-1)-(lnROWS_PAGE-1))
               lnLIMIT2 := lnROWS_PAGE
               paLIMIT  := {lnLIMIT1,lnLIMIT2}


               //? 'Ir para pag (b):',lnGOTO_PAGE
               //? 'Limit 1........:',paLIMIT[1]
               //? 'Limit 2........:',paLIMIT[2]
               //?
               //? ((lnGOTO_PAGE*lnROWS_PAGE)-1)-(lnROWS_PAGE-1)
               //? (lnGOTO_PAGE*lnROWS_PAGE)-1
               //? lnROWS_PAGE-1

            elseif laCOUNT[1] == 0 .and. valtype(paLIMIT) == 'U'
               WPut('ifEMPTY_RESULTSET',.T.)
            endif

            if db_select(paFLDS_DB,pcTABLE,paJOIN,paWHERE,paORDERBY,pcSORT,paGROUPBY,paLIMIT,pcDBNAME) == -1
               error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
            endif
            laRESULT  := db_fetchall()
            if len(laRESULT) > 0

               //Resumo da pesquisa
               lcCODE := alltrim(str(lnLIMIT1+1))+'-'
               if ((len(laRESULT)-1) < (lnLIMIT2-lnLIMIT1))
                  lcCODE += alltrim(str(len(laRESULT)-1))
               elseif lnGOTO_PAGE == lnNR_PAGES
                  lcCODE += alltrim(str(laCOUNT[1]))
               else
                  lcCODE += alltrim(str(lnLIMIT1+lnROWS_PAGE))
               endif
               lcCODE += ' de '+alltrim(str(laCOUNT[1]))
               if laCOUNT[1] > 1
                  lcCODE := ' Resultados '+lcCODE+' registros'
               else
                  lcCODE := ' Resultado '+lcCODE+' registro'
               endif
               WPut('RESUME_RESULTSET',lcCODE)

               laCLONE_RES := aclone(laRESULT)

               //Separa do result set, os campos que devem aparecer no grid. Esta separação é feita de acordo com paFLDS_GRID, ou seja
               //os campos que deverão ser mostrados no grid
               laTMP := {}
               for iiC := 1 to len(paFLDS_GRID)
                   if ascan(paFLDS_DB,paFLDS_GRID[iiC]) > 0
                      for iiB := 1 to len(laRESULT)
                          if llADD_COL
                             aadd(laTMP[iiB],laRESULT[iiB,ascan(paFLDS_DB,paFLDS_GRID[iiC])])
                          else
                             aadd(laTMP,{laRESULT[iiB,ascan(paFLDS_DB,paFLDS_GRID[iiC])]})
                             if iiB == len(laRESULT)
                                llADD_COL := .T.
                             endif
                          endif
                      next iiB
                   endif
               next iiC
               laRESULT := aclone(laTMP)

               /*
               * Criação do lst abaixo dos campos de edição
               * Se o array paBTN_GRID for enviado, cria os botoes para as respectivas colunas
               */
               if (valtype(paBTN_GRID) != 'U' .or. !empty(paBTN_GRID)) .or. (valtype(paFLD_JAVA) != 'U' .or. !empty(paFLD_JAVA))
                  if valtype(paBTN_GRID) == 'U'
                     paBTN_GRID := {}
                  endif
                  for ii := 2 to len(laRESULT)
                      if ii == 2
                         asize(laRESULT[1],len(laRESULT[1])+len(paBTN_GRID)+iif(pnPROG_TYPE==3,1,0))
                      endif
                      asize(laRESULT[ii],len(laRESULT[ii])+len(paBTN_GRID)+iif(pnPROG_TYPE==3,1,0))

                      // Insercao do botao JS [Selecionar]
                      if pnPROG_TYPE == 3 //Search mode
                         if ii == 2
                            ains(laRESULT[1],1)
                            laRESULT[1,1] := '[Selecionar]'
                         endif
                         ains(laRESULT[ii],1)
                         laRESULT[ii,1] := format_java2(laCLONE_RES,ii,paFLD_JAVA,1) //Adiciona JS para o botao [Selecionar]
                      endif

                      for iiB := 1 to len(paBTN_GRID)
                          laPAR_BTN := paBTN_GRID[iiB,2] //Array de parametros para URL do botao
                          lnCOL_BTN := paBTN_GRID[iiB,3] //Coluna em que o botao será criado

                          /* Validacao do posicionamento dos botões
                          *  Caso o pnPROG_TYPE seja 3, empurra os demais botoes uma posicao adiante pois
                          *  inicialmente foi inserido o botao JS [Selecionar]
                          */
                          if lnCOL_BTN == NIL .or. lnCOL_BTN == 0
                             lnCOL_BTN := iif(pnPROG_TYPE==3,2,1)
                          elseif pnPROG_TYPE == 3
                             lnCOL_BTN += 1
                          endif

                          //Insere o titulo da coluna do botao
                          if ii == 2
                             ains(laRESULT[1],lnCOL_BTN)
                             laRESULT[1,lnCOL_BTN] := '['+paBTN_GRID[iiB,1]+']'
                          endif

                          //Label e URL do botao
                          ains(laRESULT[ii],lnCOL_BTN)
                          if paBTN_GRID[iiB,4] == NIL .or. empty(paBTN_GRID[iiB,4])
                             paBTN_GRID[iiB,4] := pcTARGET_MOD
                          endif
                          if paBTN_GRID[iiB,5] == NIL .or. empty(paBTN_GRID[iiB,5])
                             paBTN_GRID[iiB,5] := pcPROGRAM
                          endif
                          lcBUTTON := '['+paBTN_GRID[iiB,1]+']'+wic_action('wicaction_'+paBTN_GRID[iiB,4]+'/'+paBTN_GRID[iiB,5])+'?CLICK=B&'
                          for iiC := 1 to len(laPAR_BTN)
                              if iiC > 1
                                 lcBUTTON += '&'
                              endif
                              if laPAR_BTN[iiC,1] == 'ACTION' .and. pnPROG_TYPE != 4
                                 lcBUTTON += laPAR_BTN[iiC,1]+'BP='
                              else
                                 lcBUTTON += laPAR_BTN[iiC,1]+'='
                              endif
                              if empty(laPAR_BTN[iiC,2])
                                 lcBUTTON += ret_value2(laCLONE_RES,ii,laPAR_BTN[iiC,1]) //Converte dados para caracter
                              else
                                 lcBUTTON += laPAR_BTN[iiC,2]
                              endif
                          next iiC
                          laRESULT[ii,lnCOL_BTN] := lcBUTTON
                      next iiB
                  next ii
               endif

               /*
               * Parametros para linha clicável
               * Se paONCLICK for enviado, cria o evento onClick no HTML
               */
               if (valtype(paONCLICK) != 'U' .or. !empty(paONCLICK)) .or. (valtype(paFLD_JAVA) != 'U' .or. !empty(paFLD_JAVA))
                  for ii := 2 to len(laRESULT)
                      if ii == 2
                         aadd(laRESULT[1],'(row)')
                      endif
                      if pnPROG_TYPE == 1 .or. pnPROG_TYPE == 2 .or. pnPROG_TYPE == 4 //Listagem ou Manutenção/Listagem
                         if valtype(paONCLICK) != 'U' .or. !empty(paONCLICK) //Se paONCLICK for enviado, cria o evento onClick no HTML
                            lcONCLICK := '(row)'+wic_action('wicaction_'+pcTARGET_MOD+'/'+pcPROGRAM)+'?CLICK=L&'
                            for iiC := 1 to len(paONCLICK)
                                if iiC > 1
                                   lcONCLICK += '&'
                                endif
                                if paONCLICK[iiC,1] == 'ACTION' .and. pnPROG_TYPE != 4
                                   lcONCLICK += paONCLICK[iiC,1]+'BP='
                                else
                                   lcONCLICK += paONCLICK[iiC,1]+'='
                                endif
                                if empty(paONCLICK[iiC,2])
                                   lcONCLICK += ret_value2(laCLONE_RES,ii,paONCLICK[iiC,1]) //Converte dados para caracter
                                else
                                   lcONCLICK += paONCLICK[iiC,2]
                                endif
                            next iiC
                            if !empty(lcFORMOPENER) .and. !empty(lcJAVAFIELDS)
                               lcONCLICK += '&SHOW_MENU='+lcSHOW_MENU+'&FORMOPENER='+lcFORMOPENER+'&JAVAFIELDS='+lcJAVAFIELDS
                            endif
                            aadd(laRESULT[ii],lcONCLICK)
                         endif
                      else //Search Mode
                         if valtype(paFLD_JAVA) != 'U' .or. !empty(paFLD_JAVA)
                           aadd(laRESULT[ii],format_java2(laCLONE_RES,ii,paFLD_JAVA,2)) //Adiciona JS para a linha clicável
                         endif
                      endif
                  next ii
               endif
               WPut('ifLST_GRID',.T.)
               WPut('LST_GRID',grid_create(laRESULT))
            endif
         endif

         //Gravação da ultima pesquisa feita pelo usuário
         if !empty(lcVL_FILT1) .or. !empty(lcVL_FILT2) .or. !empty(lcVL_FILT3)
            saveWEnv(pcPROG_SRC,{'FILTER_FIELD1',;
                                 'FILTER_FIELD2',;
                                 'FILTER_FIELD3',;
                                 'FILTER_CONTENT1',;
                                 'FILTER_CONTENT2',;
                                 'FILTER_CONTENT3',;
                                 'ORDER_FIELD'})

            WPut('FILTER_FIELD1',lcFLDFILT1)
            WPut('FILTER_FIELD2',lcFLDFILT2)
            WPut('FILTER_FIELD3',lcFLDFILT3)

            WPut('FILTER_CONTENT1',lcVL_FILT1)
            WPut('FILTER_CONTENT2',lcVL_FILT2)
            WPut('FILTER_CONTENT3',lcVL_FILT3)

            WPut('ORDER_FIELD.option',laLABELS)
            WPut('ORDER_FIELD',lcORDER_FIELD)
         else
            readWEnv(pcPROG_SRC)
         endif
         for ii := 1 to 3
             WPut('FILTER_FIELD'+alltrim(str(ii))+'.option',laLABELS)
         next
         WPut('ORDER_FIELD.option',laLABELS)
      endif
   else
      walert('xbp: Table "'+pcTABLE+'" not found')
      return(.f.)
   endif
return(.t.)

/*
* Function..: create_form2(fcTARGET_MOD,fcPROGRAM,faFLDS_HIDDEN,faFLDS_INPUT,faSTRUCT,fnPROG_TYPE,faBTN_MNT,fcACTION)
* Objetivo..:
* Parâmetros:
*    fcTARGET_MOD.: Módulo do programa chamado pelos links/botoes
*    fcPROGRAM....: Programa que os links/botoes do grid deverao chamar
*    faFLDS_HIDDEN: Campos ocultos, tipo hidden
*    faFLDS_INPUT.: Array com os campos que serão exibidos na área de manutenção/entrada de dados
*    faSTRUCT.....: Estrutura completa das tabelas participantes do lst/mnt
*    fnPROG_TYPE..: Tipo do programa
*    faBTN_MNT....: Lista de botoes extras
*    fcACTION.....: Acão solicitada
* Retorno...: Nenhum
*/
function create_form2(fcTARGET_MOD,fcPROGRAM,faFLDS_HIDDEN,faFLDS_INPUT,faSTRUCT,fnPROG_TYPE,faBTN_MNT,fcACTION)

  local lcHTML := '' as string

  local ii          := 0 ,;
        lnSIZE      := 0 ,;
        lnMAXLEN    := 0 ,;
        lnTD        := 1 ,;
        lnNRTD_HTML := 0 as int


/*
//Auto Search
onchange="sch_auto('mntform',  //Nome do form que chama a search
                   this,       //Nome do objeto

                   //Lista de campos usados no db_select()
                   'pfpj.CIP,
                    pfpj.PFPJ,
                    pfpj.CD_GRP_ECONOMICO,
                    grupo_economico.NM_GRP_ECONOMICO',

                   'pfpj',                                 //Tabela alvo
                   '2,grupo_economico,grupo_economico.CD_GRP_ECONOMICO=pfpj.CD_GRP_ECONOMICO', //Join, se for passar mais de um, quebrar com |
                   'CIP='+DLAP+this.value+DLAP,              //Valor do digitado no campo
                   'CIP_EMPRESA,CIP|CIP_EMPRESA_PFPJ,PFPJ')" //Campos a serem retornados

//Popup
onclick="sch_pop('sch.pfpj.html',                                     //Programa a executar
                 ['PFPJ_TABLE_FIELD=pasta.CIP_EMPRESA','aaa','bbb'])" //Parametros diversos usados na search
*/

   // Caso seja enviado o ACTION, o tratamento das permissões é feito, isto apenas para os tipos de programas
   // 1-Listagem/Form para Manutenção e 2-Ambos (Listagem e Formulário no mesmo layout)
   if valtype(fcACTION) != 'U'
      if fnPROG_TYPE == 1
         if (fcACTION == 'NEW' .and. !gbWAC_CREATE) .or. (fcACTION == 'ALTER' .and. !gbWAC_READ)
            return            //Cancela a execução da rotina, dando o efeito de retorno ao lst
         endif
      elseif fnPROG_TYPE == 2
         if fcACTION == 'NEW' .and. !gbWAC_CREATE                                      // Provoca erro caso não tenha permissão de criação
            puterror('create_form2: ('+alltrim(str(procline()))+') - Sem permissão de criação')
            error_sys('Access Control - Sem permissão de criação')
         elseif fcACTION == 'ALTER' .and. !gbWAC_READ                                  // O aviso de alteração negada é dado no bloco
            setfieldvalues2(faFLDS_INPUT)                                                    // ALTER (acima)
         endif
      endif
   endif

   lnNRTD_HTML := iif(val(WSet('NRTD_HTML'))==0,1,val(WSet('NRTD_HTML'))) // Quantidade de TDs (colunas)
   WPut('ifMNT_FORM',.T.)                                                 // Exibe HTML do form de manutenção
   WPut('ifBTN_SAVE',iif(gbWAC_WRITE,.T.,.F.))                            // Exibe botão SAVE apenas quando há permissão de alteração
   WPut('ifBTN_DELETE',iif(gbWAC_DELETE,.T.,.F.))                         // Exibe botão DELETE apenas quando há permissão de exclusão
   if fnPROG_TYPE == 1
      WPut('ifRETURN_TO_LIST',.T.)
      WPut('RETURN_TO_LIST',wic_action('wicaction_'+fcTARGET_MOD+'/'+fcPROGRAM+;
                                       iif(!empty(lcFORMOPENER) .and. !empty(lcJAVAFIELDS),'?SHOW_MENU='+lcSHOW_MENU,'')))
   elseif fnPROG_TYPE == 2
      WPut('ifEXECSEARCH',.T.)
   endif
   if valtype(faBTN_MNT) != 'U' .or. !empty(faBTN_MNT) //Botões extras
      laWICDO := {{'BTN_NAME','BTN_LABEL','BTN_ALT','BTN_ACTION'}}
      for ii := 1 to len(faBTN_MNT)
          aadd(laWICDO,{faBTN_MNT[ii,1],faBTN_MNT[ii,2],faBTN_MNT[ii,3],faBTN_MNT[ii,4]})
      next ii
      WPut('MNT_BTN',laWICDO)
   endif
   create_hiddens(faFLDS_HIDDEN)

   //Campos para entrada de dados
   lcHTML += CRLF+'      <tr>'+CRLF
   for iiC := 1 to len(faFLDS_INPUT)
       if faFLDS_INPUT[iiC,1] != NIL .or. !empty(faFLDS_INPUT[iiC,1])
          lnLINE := ascan(faSTRUCT[2],{|x| x[1]==upper(alltrim(faFLDS_INPUT[iiC,1]))})
          if faSTRUCT[2][lnLINE,2] == 'DATE'
             lnSIZE   := 12
             lnMAXLEN := 10
          elseif ascan(laDT_STR,upper(alltrim(faSTRUCT[2][lnLINE,2]))) > 0     //Tipos string
             lnSIZE   := faSTRUCT[2][lnLINE,3]
             lnMAXLEN := lnSIZE
          elseif ascan(laDT_DEC,upper(alltrim(faSTRUCT[2][lnLINE,2])))  > 0    //Tipos numéricos com ponto flutuante
             lnSIZE   := faSTRUCT[2][lnLINE,3]+faSTRUCT[2][lnLINE,4]
             lnMAXLEN := lnSIZE+1                                              //Tam total + um para o ponto decimal (.)
          elseif ascan(laDT_INT,upper(alltrim(faSTRUCT[2][lnLINE,2]))) > 0     //Tipos inteiro
             lnSIZE   := faSTRUCT[2][lnLINE,3]
             lnMAXLEN := lnSIZE
          endif
          lcHTML += '         <td>wiclabel.'+faFLDS_INPUT[iiC,1]+wnbsp(2)+'</td>'+CRLF //Label do campo
          lcHTML += '         <td>'+CRLF
          if faFLDS_INPUT[iiC,2] != NIL .or. !empty(faFLDS_INPUT[iiC,2])        //Tipo de objeto
             do case
                case faFLDS_INPUT[iiC,2] == 0  //text
                     lcHTML += '           <input type="text" name="'+faFLDS_INPUT[iiC,1]
                     lcHTML += '" wicinput size="'+alltrim(str(lnSIZE))+'" maxlength="'+alltrim(str(lnMAXLEN))+'"'
                     if (faFLDS_INPUT[iiC,3] != NIL .or. !empty(faFLDS_INPUT[iiC,3])) .and. faFLDS_INPUT[iiC,3] == 'Y'
                        lcHTML += ' class="winputreadonly" readonly'
                     else
                        lcHTML += ' class="winput"'
                     endif
                     lcHTML += '>'+CRLF
                case faFLDS_INPUT[iiC,2] == 1 //combobox
                     lcHTML += '           <select name="'+faFLDS_INPUT[iiC,1]+'" wicinput class="winput">'+CRLF
                     lcHTML += '           </select>'+CRLF
                case faFLDS_INPUT[iiC,2] == 2 //checkbox
                     lcHTML += '           <input type="checkbox" name="'+faFLDS_INPUT[iiC,1]+'" wicinput'
                     if (faFLDS_INPUT[iiC,3] != NIL .or. !empty(faFLDS_INPUT[iiC,3])) .and. faFLDS_INPUT[iiC,3] == 'Y'
                        lcHTML += ' class="winputreadonly" readonly'
                     else
                        lcHTML += ' class="winput"'
                     endif
                     lcHTML += '>'+CRLF
                case faFLDS_INPUT[iiC,2] == 3 //radiobutton

                case faFLDS_INPUT[iiC,2] == 4 //textarea
                     lcHTML += '           <textarea name="'+faFLDS_INPUT[iiC,1]+'" rows="4" cols="50"'
                     if (faFLDS_INPUT[iiC,3] != NIL .or. !empty(faFLDS_INPUT[iiC,3])) .and. faFLDS_INPUT[iiC,3] == 'Y'
                        lcHTML += ' class="winputreadonly" readonly'
                     else
                        lcHTML += ' class="winput"'
                     endif
                     lcHTML += '><wicfield name="'+faFLDS_INPUT[iiC,1]+'"></textarea>'+CRLF
             endcase
          endif
          lcHTML += '         '+wnbsp(2)+'</td>'//+CRLF
       else
          lcHTML += '         <td colspan="2"></td>'+CRLF
       endif

       if lnTD == lnNRTD_HTML
          lcHTML += '      </tr>'+CRLF
          lcHTML += '      <tr>'+CRLF
          lnTD   := 1
       else
          lnTD++
       endif
   next iiC
   lcHTML += '      </tr><br>'+CRLF
   WPut('INPUT_FIELDS',lcHTML)

   for iiC := 1 to len(faFLDS_INPUT) //Marca os campos obrigatorios
       if faFLDS_INPUT[iiC,1] != NIL .or. !empty(faFLDS_INPUT[iiC,1])    //Linha vazia ?
          if faFLDS_INPUT[iiC,3] != 'Y' .and. faFLDS_INPUT[iiC,4] == 'Y' //Campo Read/Write e obrigatorio ?
             WPut(faFLDS_INPUT[iiC,1]+'.label.style.color','#FF0000')
             WPut(faFLDS_INPUT[iiC,1]+'.label.style.font-weight','bold')
          endif
       endif
   next iiC
return(nil)
/*
* Function..: setfieldvalues2(faFLDS_INPUT)
* Objetivo..: Inicializar campos com valores default
* Parâmetros:
*    faFLDS_INPUT: Array no formato de paFLDS_INPUT
* Retorno...: nenhum
*/
function setfieldvalues2(faFLDS_INPUT)
   local lcVALUE_DEF := '' as string

   for iiC := 1 to len(faFLDS_INPUT)
       if faFLDS_INPUT[iiC,5] != NIL .or. !empty(faFLDS_INPUT[iiC,5])
          lcVALUE_DEF := faFLDS_INPUT[iiC,5]
          if faFLDS_INPUT[iiC,2] == 1 .or. faFLDS_INPUT[iiC,2] == 2
             WPut(faFLDS_INPUT[iiC,1]+'_OPT',eval({|| &lcVALUE_DEF}))
             if faFLDS_INPUT[iiC,2] == 2
                WPut(faFLDS_INPUT[iiC,1],eval({|| &lcVALUE_DEF}))
             endif
          else
             WPut(faFLDS_INPUT[iiC,1],eval({|| &lcVALUE_DEF}))
          endif
       endif
   next iiC
return(nil)

/*
* Function..: ret_value2(faRESULT,fnINDEX,fcFIELD)
* Objetivo..: Converter tipo de dados D,N,I para C
* Parâmetros:
*    faRESULT: Array alvo da pesquisa
*    fnINDEX.: Linha a pesquisar no array
*    fcFILED.: Campo a pesquisar no array
* Retorno...: Informação convertida para o tipo C
*             String vazia em caso de tipo de dados desconhecido
*/
function ret_value2(faRESULT,fnINDEX,fcFIELD)
   local lcRET_VALUE := '' as string

   //Untyped variables
   local luVALUE

   if ascan(faRESULT[1],fcFIELD) <= 0
      lcRET_VALUE := ''
      putERROR('ret_value: Field '+DLMT+fcFIELD+DLMT+' not found in result set')
   else
      luVALUE := faRESULT[fnINDEX,db_fetchncol(faRESULT,fcFIELD)]
      if valtype(luVALUE) == 'N' .or. valtype(luVALUE) == 'I'
         lcRET_VALUE += alltrim(str(luVALUE))
      elseif valtype(luVALUE) == 'D'
         lcRET_VALUE += dtoc(luVALUE)
      elseif valtype(luVALUE) == 'C' .or. valtype(luVALUE) == 'M'
         lcRET_VALUE += alltrim(luVALUE)
      else
         putERROR('ret_value: Unknown data type')
      endif
   endif
return(lcRET_VALUE)

/*
* Function..: format_java2(faRESULT,fnINDEX,faJAVA_PARAMS,fnOBJ_TYPE)
* Objetivo..: Criar javascript para linhas clicáveis e botão selecionar
* Parâmetros:
*    faRESULT.....: Array alvo da pesquisa
*    fnINDEX......: Linha a pesquisar no array
*    faJAVA_PARAMS: Parametros para formacao do javascript
*    fnOBJ_TYPE...: Tipo do objeto final
*                   1 - Botao
*                   2 - Linha clicavel
* Retorno...: String contendo o Javascript
*/
function format_java2(faRESULT,fnINDEX,faJAVA_PARAMS,fnOBJ_TYPE)
   local lcONCLICK := '' ,;
         lcVALUE   := '' as string

   local iiC := 0 as int

   if fnOBJ_TYPE == 1
      lcONCLICK := '[Selecionar]' //Botao
   else
      lcONCLICK := '(row)'        //Linha clicável
   endif
   lcONCLICK +='javascript:'
   for iiC := 1 to len(faJAVA_PARAMS[2])
       lcONCLICK += 'if(typeof(opener.document.'
       lcONCLICK += faJAVA_PARAMS[1]+'.'+faJAVA_PARAMS[2][iiC,1]+')=='+DLAP+'object'+DLAP+')'
       lcONCLICK += '{opener.document.'+faJAVA_PARAMS[1]+'.'+faJAVA_PARAMS[2][iiC,1]+'.value='
       lcONCLICK += DLAP+esc2db(ret_value2(faRESULT,fnINDEX,faJAVA_PARAMS[2][iiC,2]))+DLAP+';}'
   next iiC
   lcONCLICK += 'self.close()'
return(lcONCLICK)

//--------------------------------------------------------------------------------------------------
/*
* Function..: checa_tabela()
* Objetivo..: Verifica se as há registros incluidos nas tabelas envolvidas no lits
* Parâmetros:
*   fcNR_PASTA: Numero da pasta
*   fcTP_PASTA: Tipo de pasta
* Retorno...: nil
*/
function Checa_tabela(fnNR_PASTA,fcTP_PASTA,fcRelac) 

      local    laCheca       := {} ,;
               laVal_Abas    := {} ,;
               laRes         := {} ,;
               laResult         := {} ,;
               laPastaConfig := {} as array

      local    lcWHERE     := '' as string
      local    llRETURN    := .f. as logical

      lcWHERE       := 'NR_PASTA = '+str(fnNR_PASTA)
      
      laCheca := { 'pasta_andamento',;
                   'pasta_auto',;
                   'pasta_contingencia',;
                   'pasta_contrato_aditivo',;
                   'pasta_contrato_anexo',;
                   'pasta_div_responsabilidade',;
                   'pasta_garantia',;
                   'pasta_jurisprudencia',;
                   'pasta_penhora',;
                   'pasta'}

      laCheca1 := { 'mnt_pst_andamento_html',;
                   'psab_auto_html',;
                   'mnt_pst_contingencia_html',;
                   'pst_aditivo_contrato_html',;
                   'pst_anexo_contrato_html',;
                   'psab_div_responsabilidade_html',;
                   'psab_garantia_html',;
                   'psab_jurisprudencia_html',;
                   'pst_penhora_html',;
                   'pst_execucao_html'}

//--------    Campos/ABAS nao replicados - recuperados da tabela.campo pasta_config.

         if db_select({'LITS_ABAS_NAOCOMUM'},'pasta_config',,{'TP_PASTA='+DLAP+fcTP_PASTA+DLAP}) = -1
            error_sys(db_error())
         endif
         laPastaConfig := db_fetchrow()
         if !empty(laPastaConfig[1])
            laRES := str2array(laPastaConfig[1],',')
            for ii := 1 to len(laRES)
                aadd(laVAL_ABAS,laRES[ii])
            next ii
            for ii :=1 to len(laCheca)
                if ascan(laVal_Abas,laCheca1[ii]) > 0    // achou no scan > 0
                         //------- Rotina que checa se existe conteudoo nos campos especificos  
                   if laCheca1[ii] = 'pst_execucao_html'
                      if db_select({'VL_RE','VL_AUTOR','VL_HOMOLOGADO','VL_PROVISAO','VL_PROVISAO2','VL_PERITO','VL_RECLAMADA','VL_RECLAMANTE','VL_TT_PROVISAO'},'pasta',,{'NR_PASTA='+str(fnNR_PASTA)}) == -1
                         error_sys(db_error())
                      endif
                      laRESULT := db_fetchrow()
                      for nn:=1 to len(laResult)
                          if laRESULT[nn] > 0
                              walert('Existem pastas relacionadas a este conteúdo.\n     Registro não pode ser alterado/excluído')
                              llreturn:=.t.
                              return(llreturn)
                          else            
                            return(llreturn)
                          endif  
                      next nn
                   endif   
                         //------- Rotina que checa se existe conteudoo nas pastas  

                   if db_select({'count(*)'},laCheca[ii],,{lcWHERE}) == -1
                      error_sys('xbp: ('+alltrim(str(procline()))+') - '+db_error())
                   endif
                   laCOUNT := db_fetchrow()
                   if laCOUNT[1] > 0 
                      walert('Existem pastas relacionadas a este conteúdo.\n     Registro não pode ser alterado/excluído')
                      llreturn:=.t.
                      return(llreturn)
                   endif
                endif
            next ii       
         else
            llreturn:=.f.
         endif          
return(llreturn)

/*
* Function..: loadcboxorder_build(fcTABLE,fcFIELD,flFIRST_EMPTY,fcORDER)
* Objetivo..: Carregar dados em objetos combobox
* Sonia Perdigão - 17/2/2009 10:00:55
* Parâmetros:
*    fcTABLE......: Tabela alvo
*    fcFIELD......: Campo alvo
*    flFIRST_EMPTY: Adicionar ou não um item em branco no começo da lista. Parametro lógico e opcional
*    fcORDER......: Order by Opcional
* Retorno...: Vetor com os registro encontrados em fcTABLE
*
*/
function loadcboxorder_build(fcTABLE,fcFIELD,flFIRST_EMPTY,fcORDER)
   local laRES    := {} ,;
         laRETURN := {} as array

   local ii := 0 as int

   flFIRST_EMPTY := iif(valtype(flFIRST_EMPTY) == 'U',.F.,flFIRST_EMPTY)
   if valtype(fcTABLE) == 'U' .or. empty(fcTABLE)
      walert('loadcbox_build: Table not defined')
      return(.f.)
   endif
   if valtype(fcFIELD) == 'U' .or. empty(fcFIELD)
      walert('loadcbox_build: Field not defined')
      return(.f.)
   endif

   if db_select({fcFIELD},fcTABLE,,,fcORDER) == -1
      walert('loadcbox_build: '+db_error())
      return(.f.)
   endif
   laRES := db_fetchall()
   if flFIRST_EMPTY           // Adiciona uma linha vazia no inicio do combo, caso seja solicitado
      aadd(laRETURN,'')
   endif
   for ii := 2 to len(laRES)
       aadd(laRETURN,laRES[ii,1])
   next ii
return(laRETURN)


/*
* Data.Criação.: 22.03.2007 - Glauber
* Function.....: wac_tp_pasta(fcTP_PASTA)
* Objetivo.....: Verificar as permissões para um tipo de pasta e redefine as variáveis globais de controle de
*                acesso.
*
* Parâmetros...:
*    fcTP_PASTA: Tipo da pasta
* Retorno......: Nenhum
*/

function wac_tp_pasta(fcTP_PASTA)

   local laPERMS  := {},;
         laFIELDS := {} as array

   #define fcWPERM_EXEC  3 // Permissão de execução
   #define fcWPERM_READ  4 // Permissão de leitura
   #define fcWPERM_WRITE 5 // Permissão de escrita
   #define fcWPERM_CREATE 6 // Permissão de inserção
   #define fcWPERM_DELETE 7 // Permissão de exclusão

   laFIELDS := {'WGID','WPROGRAM','WPERM_EXEC','WPERM_READ','WPERM_WRITE','WPERM_CREATE','WPERM_DELETE'}

   if Wset('WFL_MASTER') == 'Y' .or. empty(alltrim(fcTP_PASTA))
      return
   endif

   if db_select(laFIELDS,'acgroup_program',,{'WGID='+str(Wset('WGID'))+ ' and WPROGRAM = '+DLAP+fcTP_PASTA+DLAP}) = -1
      error_sys(db_error())
   endif
   laPERMS := db_fetchall()

   if len(laPERMS) == 1
      return
      //error_sys('Access Control: Sem permissão para execução.')
   else
      if laPERMS[2,fcWPERM_EXEC] !=  'Y' // Permissão de Execução
         error_sys('Access Control: Sem permissão para execução.')
      endif
      gbWAC_CREATE := iif(laPERMS[2,fcWPERM_CREATE] == 'Y',.T.,.F.)
      gbWAC_READ   := iif(laPERMS[2,fcWPERM_READ] == 'Y',.T.,.F.)
      gbWAC_WRITE  := iif(laPERMS[2,fcWPERM_WRITE] == 'Y',.T.,.F.)
      gbWAC_DELETE := iif(laPERMS[2,fcWPERM_DELETE] == 'Y',.T.,.F.)
   endif

return




/*
*  
* Function..: RetFeriado(pdData)
* Objetivo..: Retorna se uma data e feriado.
* Parâmetros:
*   pdData  : Data a ser pesquisada
* Retorno...: retorna .t. se a data e um feriado, caso contrario retorna .f.
* 
*
*/

Function RetFeriado(pdData)

    local llRetorno := .f. 
    local laResult  := {} as array

    if db_select({'COUNT(*) AS QTDE'},'wfferiados',,{'dt_feriado='+DLAP+dtos(pdData)+DLAP}) ==-1
       error_sys('RetFeriado:'+db_error())
    endif
    laResult  := db_fetchrow()
    llRetorno := (laResult[1] > 0) 
    return(llRetorno)

/*
*  
* Function..: WfDiaUtil(pdData)
* Objetivo..: Retorna a primeira data util a partir da data recebida em pdData.
* Parâmetros:
*   pdData  : Data a ser pesquisada
* Retorno...: Data util
* 
*
*/
Function WfDiaUtil(pdData)

    local ldRetorno := Date() as date
    ldRetorno := pdData

    while (dow(ldRetorno) == 1 .or. dow(ldRetorno) == 7) .or. RetFeriado(ldRetorno)
          ldRetorno := ldRetorno -1
    enddo
    return(ldRetorno)             


/*
*  
* Function..: WfDiaUtilQtd(pdData,pnDias)
* Objetivo..: Retorna a data util a partir da data recebida em pdData e a quantidade de dias informado em pnDias.
* Parâmetros:
*   pdData  : Data a ser pesquisada
*   pnDias  : Quantidade de dias 
*   pnOper  : 0 subtrai os dias, 1 adiciona os dias 
* Retorno...: Data util
* 
*
*/
Function WfDiaUtilQtd(pdData, pnDias, pnOper)

    local ldRetorno := Date() 
    local lnDias := 0 as numeric
    ldRetorno := pdData

    while lnDias < pnDias
          if (dow(ldRetorno) == 1 .or. dow(ldRetorno) == 7) .or. RetFeriado(ldRetorno)
             if pnOper == 0
                ldRetorno := ldRetorno - 1
             else
                ldRetorno := ldRetorno + 1
             endif
          else
             ++lnDias
             if pnOper == 0
                ldRetorno := ldRetorno - 1
             else
                ldRetorno := ldRetorno + 1
             endif 
          endif
    enddo
    return(ldRetorno)             



/*
* Function..: GetUrl()
* Objetivo..: Retorna os primeiros caracteres da url
* Parâmetros:
*
* Retorno...: string com os dados da url
*/

Function GetUrl()

  local lcRETORNO := '' as string
  local laREQ   := {} as array

  laREQ := WebGetEnvir()
  
  if (at("HTTPS",laREQ[4,2])>0) // Server Protocol
   lcRETORNO += "https://"
  else
   lcRETORNO += "http://"
  endif
  lcRETORNO += laREQ[2,2] // Server Name
  lcRETORNO += laREQ[9,2] // Script Name

  return(lcRETORNO)


/*
* Data......: 25/08/2010 - Glauber
* Function..: parser2str(<expC1>,<expA1>)
* Objetivo..: Processa o parser em expC1 com base nos dados de expA1.
* Parâmetros:
*    expC1: String a processado o parser.
*    expA1: Array com os dados no formato laRESULT
* Retorno...: Retorna uma string com os dados processados
*
*
*/

Function parser2str(pcConteudo,paResult)

     local xx := 0 as int
     local lcResult := '',;
           lcTmp    := '' as String
     lcResult := pcConteudo
     if len(pcConteudo) > 0 .and. len(paResult) > 1
        for xx := 1 to len(paResult[1])
            lcTMP := '[' + paResult[1,xx] + ']'
            lcResult := StrTran(lcResult,lcTMP,paResult[2,xx])
        next xx
     endif
return (lcResult)





/*
* Data......: 25/08/2010 - Glauber
* Function..: mkgedgrid(fcWTABLE, faValues)
* Objetivo..: Verificar a existencia de configurções GED para uma determinada tabela e criar o link para o ícone do GED
* Parâmetros:
*   fcWTABLE: Nome da tabela
*   faValues: Vetor com os valores para WFIELD1,WFIELD2..WFIELD5
* Retorno...: Nenhum
*/
function mkgedgrid(fcWTABLE,faValues)
   local lcPARAMS  := '' ,;
         lcHTML    := '' ,;
         lcCONTENT := '' as string

   local laFIELDS := {} ,;
         laRESULT := {} as array

   local ii := 0 as int

   if valtype(fcWTABLE) == 'U' .or. empty(fcWTABLE)
      puterror('mkgedico: Tabela não definida')
      return(nil)
   endif

   laFIELDS := {'WTABLE','CD_BUSINESS','WFIELD1','WFIELD2','WFIELD3','WFIELD4','WFIELD5'}
   if db_select(laFIELDS,'gdrelacionamento',,{'WTABLE='+DLAP+fcWTABLE+DLAP}) == -1
      puterror('mkgedico: ('+alltrim(str(procline()))+') '+db_error())
      return(nil)
   endif
   laRESULT := db_fetchrow()
   if len(laRESULT) > 0
      if !empty(laRESULT[2]) .and. !empty(laRESULT[3])
         lcPARAMS += 'WTABLE='+fcWTABLE
         lcPARAMS += '&CD_BUSINESS='+alltrim(laRESULT[2])
         for ii := 1 to 5
             if !empty(laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))])
                //lcCONTENT := alltrim(getwput(laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))],'C')) // Recupera dados da UI
                lcCONTENT := faValues[ii]
                if !empty(lcCONTENT)
                   lcPARAMS += '&WFIELD'+alltrim(str(ii))+'='+lcCONTENT
                else
                   lcPARAMS += '&WFIELD'+alltrim(str(ii))+'=RELATIONEMPTY.'+laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))]
                endif
             endif
         next ii

         lcPARAMS := wic_action('wicaction_workflow/ged.mgr.html')+'?'+lcPARAMS
         lcHTML += '<script language="javascript">'+CRLF
         lcHTML += '   wWIDTH = document.body.clientWidth;'+CRLF
         lcHTML += '   /*'+CRLF
         lcHTML += '   * function winged()'+CRLF
         lcHTML += '   * Abre iframe com programa de visualização de Documentos'+CRLF
         lcHTML += '   * Parametros:'+CRLF
         lcHTML += '   * wACTION - open | close -> Abre/fecha iframe.'+CRLF
         lcHTML += '   * wURL - > Parametros a ser passado ao programa no formato URL GET. Ex: WTABLE=pasta&REFERENCIA1=10'+CRLF
         lcHTML += '   * objevent -> Parametr estático, deve-se sempre passar o objeto [event]'+CRLF
         lcHTML += '   */'+CRLF
         lcHTML += '   function winged(wACTION,wURL,objevent) {'+CRLF
         lcHTML += '      if (wWIDTH > 800) {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.width = 950;'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.height = 520;'+CRLF
         lcHTML += '         var LGWIDTH = 900;'+CRLF
         lcHTML += '   	  }'+CRLF
         lcHTML += '   	  else {'+CRLF
         lcHTML += '   	    document.getElementById('+DLAP+'divged'+DLAP+').style.width = 700;'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.height = 300;'+CRLF
         lcHTML += '   	    var LGWIDTH = 710;'+CRLF
         lcHTML += '   	  }'+CRLF
         lcHTML += '      if (typeof(objevent) == '+DLAP+'object'+DLAP+') {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.left = objevent.clientX - LGWIDTH;'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.top = (document.body.scrollTop + objevent.clientY)-30;'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '      if (wACTION == '+DLAP+'open'+DLAP+') {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.visibility = '+DLAP+'visible'+DLAP+';'+CRLF
         lcHTML += '         parent.iframeged.location.href = '+DLAP+lcPARAMS+DLAP+';'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '      else {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.visibility = '+DLAP+'hidden'+DLAP+';'+CRLF
         lcHTML += '         parent.iframeged.location.href = '+DLAP+'about:blank'+DLAP+';'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '   }'+CRLF
         lcHTML += '   function set_pos() {'+CRLF
         lcHTML += '      document.getElementById('+DLAP+'btged'+DLAP+').style.top = document.body.scrollTop + 60 ;'+CRLF
         lcHTML += '      setTimeout('+DLAP+'set_pos()'+DLAP+',100);'+CRLF
         lcHTML += '   }'+CRLF
         lcHTML += '   window.onload = set_pos;'+CRLF
         lcHTML += '</script>'+CRLF
         lcHTML += '<div id="btged" style="cursor:pointer;position:absolute;z-index:1000;width:66px;height:62px;background-repeat:none;"'+CRLF
         lcHTML += '     onclick="winged('+DLAP+'open'+DLAP+','+DLAP+lcPARAMS+DLAP+',event)"></div>'+CRLF
         lcHTML += '<script language="javascript">'+CRLF
         lcHTML += '   document.getElementById('+DLAP+'btged'+DLAP+').style.left = (wWIDTH - 100);'+CRLF
         lcHTML += '   document.getElementById('+DLAP+'btged'+DLAP+').style.top = document.body.scrollTop + 60;'+CRLF
         lcHTML += '   document.getElementById('+DLAP+'btged'+DLAP+').style.visibility = '+DLAP+'visible'+DLAP+' ;'+CRLF
         lcHTML += '</script>'+CRLF
         lcHTML += '<div id="divged" style="overflow:hidden; position:absolute;z-index:2000;width:700px;visibility:hidden;border:1px solid #000000;background-color:#FFFFFF;">'+CRLF
         lcHTML += '   <div align="right" style="background-color:#408095;height:20px;padding:2px;"><input type="button" '
         lcHTML += 'style="background-color:#408095;font-family:Verdana, Arial, Helvetica, sans-serif; font-size:10; '
         lcHTML += 'color:#FFFFFF; border:1px solid #FFFFFF; height:16px;" value="x" onclick="winged('+DLAP+'close'+DLAP+')"></div>'+CRLF
         lcHTML += '   <iframe name="iframeged" frameborder="0" width="100%" height="100%"></iframe>'+CRLF
         lcHTML += '</div>'+CRLF
      endif
      wput('GED_ICO',lcHTML) // Tag localizada na UI da aplicação - mnt.pasta.html
   endif
return(lcPARAMS)
//return(lcHTML)

// ********************************** Glauber 02/09/2010 Customizações Unimed **********************************


/*
* Data......: 02/09/2010 - Glauber
* Function..: TrataErroWS(pcCONTEUDO)
* Objetivo..: Verifica o conteúdo do xml a procura de erros.
* Parâmetros:
* pcCONTEUDO: Conteúdo do arquivo
* Retorno...: String com a descrição do erro
*/

Function TrataErroWS(pcCONTEUDO)

local lcRet := '',;
      lcTMP := '' as String

if at('Exception',pcCONTEUDO) > 0
    lcRet := 'Problemas com o layout do arquivo xml.'
elseif at('erro cd_retorno',pcCONTEUDO) > 0
    lcTMP := Substr(pcCONTEUDO,at('nm_retorno="',pcCONTEUDO) +12,len(pcCONTEUDO))
    lcTMP := Substr(lcTMP,1,at('" ></erro>',lcTMP)-1)
    
    lcRet := Substr(pcCONTEUDO,at('cd_retorno="',pcCONTEUDO) +12,1) + '-' +;
             lcTMP
endif

if ! empty(lcRet)
   // Grava o log
   // Gravo o id_servico como 9 para identificar que houve erro na operação, também
   // armazeno o conteúdo do xml de retorno no campo retorno.
   if db_insert({{'NR_PASTA','NR_SINISTRO','ID_INTEGRACAO','ID_SERVICO','DT_OPERACAO','HR_OPERACAO','RETORNO'},;
                 {Wget('NR_PASTA'),Wget('NR_SINISTRO'),Wget('ID_INTEGRACAO'),9,date(),time(),pcCONTEUDO}},'isjunimedservlog') == -1
      error_sys(db_error())
   endif
endif
return (lcRet)


/*
* Data......: 26/08/2010 - Glauber
* Function..: RetornaConfWS()
* Objetivo..: Valida a configuração do webservice e retorna um array com os dados para montar o xml.
* Parâmetros:
* Retorno...: Retorna um array com os dados para montar o xml de consumo, em caso de erro retorna o array vazio
*/

function RetornaConfWS()

    local laCONF       := {},;
          laFIELDSCONF := {},;
          laRES        := {},;
          laRESULT     := {} as Array
    local lcWHERE      := '',;
          lcCONSULTA   := '',;
          lcFLEGA      := '',;
          lcQuery      := '' as String
    local llErro       := .f.
    // Valida o Preenchimento do número de sinistro e código do ramo
/*
    if empty(WGet('NR_SINISTRO')) .or. empty(WGet('CD_RAMO'))
       WAlert('O número do Sinistro e Código do Ramo é de preenchimento obrigatório para efetuar a consulta.')
       llErro := .t.
    endif
*/
    // Valida a configuração dos serviços preenchimento dos campos de configuração
    if ! llErro
       laFIELDSCONF := {'isjunimedservconf.ID_SOLICITA_DADOS',;
                        'isjunimedservconf.ID_MARCA_DESMARCA',;
                        'isjunimedservconf.ID_DESMARCA',;
                        'isjunimedservconf.ID_RAMO_EVIDA',;
                        'isjunimedservconf.ID_RAMO_TOP',;
                        'isjunimedservconf.PEDIDO_PROCESSO',;
                        'isjunimedservconf.TEMPOESPERA'}
       if db_select(laFIELDSCONF,'isjunimedservconf') = -1
           error_sys(db_error())
       endif
       laCONF := db_fetchall()
       if len(laCONF) == 1
          WAlert('Configuração do webservice não encontrada.')
          llErro := .t.
       else
          lcWHERE := 'ID_SERVICO IN('
          for ii := 1 to len(laCONF[1])
              if valtype(laCONF[2,ii]) == 'N'
                 if laCONF[2,ii] == 0
                    WAlert('O campo ' +lblfscreen(laCONF[1,ii]) + ' não foi configurado corretamente no webservice.')
                    llErro := .t.
                 endif
                 if (laCONF[1,ii] == 'ID_SOLICITA_DADOS') 
                    lcWHERE += str(laCONF[2,ii]) + ','
                 elseif (laCONF[1,ii] == 'ID_MARCA_DESMARCA') 
                    lcWHERE += str(laCONF[2,ii]) +')'
                 elseif (laCONF[1,ii] == 'ID_DESMARCA') 
                    lcWHERE += str(laCONF[2,ii]) +')'                    
                 endif
              elseif valtype(laCONF[2,ii]) == 'C' .or. valtype(laCONF[2,ii]) == 'D'
                     if empty(laCONF[2,ii]) .or. laCONF[2,ii] == '  /  /    '
                        WAlert('O campo ' +lblfscreen(laCONF[1,ii]) + ' não foi configurado corretamente no webservice.')
                        llErro := .t.
                     endif
              endif              
          next ii
       endif

       // Valida a configuração dos serviços, conteúdo dos campo para ser gerado o xml
       if ! llErro
          if WSET('DRV_GR5') == 'PGS'
             lcQuery := "select ID_SERVICO,SERVICO from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,1])) +;
                        " union " +;
                        "select ID_SERVICO,SERVICO,NOME_WS from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,2])) +;
                        " union " +;
                        "select ID_SERVICO,SERVICO,NOME_WS from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,2]))                        
          else
             lcQuery := "select ID_SERVICO,convert(varchar(4000),SERVICO) as SERVICO,NOME_WS from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,1])) +;
                        " union " +;
                        "select ID_SERVICO,convert(varchar(4000),SERVICO) as SERVICO,NOME_WS from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,2])) +;
                        " union " +;
                        "select ID_SERVICO,convert(varchar(4000),SERVICO) as SERVICO,NOME_WS from isjunimedservicos where ID_SERVICO = " + alltrim(str(laCONF[2,3]))                        
          endif
          laFIELDSCONF := {'ID_SERVICO','SERVICO','NOME_WS'}
          if db_query(lcQuery) = -1
             error_sys(db_error())
          endif
          laRES := db_fetchall()

          if len(laRES) == 1
             WAlert('Tabela de serviços do webservice vazia.')
             llErro := .t.
          Endif
          if ! llErro
             for ii := 2 to len(laRES)
                 if empty(laRES[ii,2]) .OR. empty(laRES[ii,3])
                    WAlert('O serviço de código ' +alltrim(str(laRES[ii,1])) + ' não foi configurado corretamente no webservice.')
                    llErro := .t.
                 endif
             next ii
          endif
       endif
       // Monta o array de retorno com os dados para solicitação dos servicos
       if ! llErro          
          laRESULT := {{'CONSULTA','FLEG','ID_RAMO_VIDA','ID_RAMO_TOP','PEDIDO_PROCESSO','TEMPOESPERA','NOME_WS','DESMARCA'},;
                       {lower(laRES[2,2]),lower(laRES[3,2]),laCONF[2,3],laCONF[2,4],laCONF[2,5],laCONF[2,6],laRES[2,3],lower(laRES[4,2])}}
       endif
    endif
return(laRESULT)

/*
* Data......: 26/08/2010 - Glauber
* Function..: GravaArquivo(pcArquivo,pcConteudo)
* Objetivo..: Gravar o arquivo xml que será enviado para o programa de consumo xml
* Parâmetros:
*  pcArquivo: Nome do arquivo a ser gravado incluindo o path
*  pcConteudo: Conteudo a ser gravado
* Retorno...: Nada em caso de erro tanto na criação do arquivo como conteúdo é chamado a função error_sys
*/

Function GravaArquivo(pcArquivo,pcConteudo)

   Local lnHandle := 0 as int


   lnHandle := fcreate(pcArquivo,644)
   if ferror() != 0
      error_sys('Erro na criação do arquivo:'+pcArquivo + '. Código do erro:' + str(ferror()))
   else
      fwrite(lnHandle,pcConteudo)
      if ferror() != 0
         error_sys('Erro na gravação do conteúdo do arquivo:'+pcArquivo + '. Código do erro:' + str(ferror()))
      endif
      fclose(lnHandle)
   endif   
return
/*
* Data......: 31/08/2010 - Glauber
* Function..: GetFileContent(pcFile)
* Objetivo..: Abre o arquivo informado em pcFile, efetuando a leitura do mesmo retornando uma string com seu conteúdo. 
* Parâmetros:
*  pcFile   : Nome do arquivo a ser processado
* Retorno...: String com o conteudo do arquivo
*/
Function GetFileContent(pcFile)

   local lnHandle   := 0,;
         lnTam      := 0  as int
   local lcBuffer   := '' as string

   if ! file(pcFile)
      return ''
   endif

   lnHandle := fopen(pcFile,0)
   if lnHandle < 0 .or. ferror() > 0
      error_sys('Erro ao abrir o arquivo:' + pcFile + '.Codigo do erro:' + str(ferror()))
      return('')
   endif
   // Posiciona o ponteiro do arquivo no final do mesmo a fim de obter o tamanho do arquivo para fazer a devida alocação de memória para leitura
   lnTam := Fseek(lnHandle,0,2)
   // Aloca a memória, este procedimento é obrigatório, pois senão alocar o espaço do buffer o conteúdo retornado por fread é o tamanho da variável de memória.
   lcBuffer := space(lnTam)
   // Posiciona novamente no começo do arquivo para efetivar a leitura
   Fseek(lnHandle,0,0)
   // Fazendo a leitura do conteúdo
   Fread(lnHandle,@lcBuffer,lnTam)
   // Fechando o arquivo
   Fclose(lnHandle)
           
   return(lcBuffer)



/*
* Glauber - 05/01/2010 
*
* Function  : AbasPerfil(pcTP_PASTA, paCAMPOS)
* Objetivo  : Verifica se existem campos com label redefinida por tipo de pasta e tipo de perfil.
*             Caso exista alimenta a data global com o label desejado para que o conteúdo seja
*             visualizado na tela.
*             
* Parâmetros:
*             pcTP_PASTA : String com o tipo da pasta.
*             paCAMPO    : Vetor simples com o nome dos campos.
*
* Retorno:    Nada
*             
*/   

Function AbasPerfil(pcTP_PASTA, paCAMPOS)

   local lcWHERE     := '',;
         lcGROUP     := '' as String
   local lnindCAMPOS := 0,;
         lnindRES    := 0,;
         ii          := 0,;
         xx          := 0  as int
   local laRESULT    := {},;
         laCAMPOS    := {},;
         laPASTAS    := {},;
         laGROUP     := {}  as array
  
   if pcTP_PASTA == nil .or. empty(pcTP_PASTA) .or. paCAMPOS == nil .or. len(paCAMPOS) == 0
      return
   endif
   laCAMPOS := aclone(paCAMPOS)
//   lcWHERE := '(tp_pasta = ' +DLAP + pcTP_PASTA + DLAP +' and wgid = ' + str(WSet('WGID')) + ') and wfield in('


   lcGROUP := GetGroupName(WSet('WGID'))

   lcWHERE := '(pastas like ' +DLAP +'%' +pcTP_PASTA +'%'+ DLAP +' and GROUPS like ' +DLAP+'%' +alltrim(lcGROUP)+'%'+DLAP + ') and wfield in('
// debug2(lcwhere,,200)
   // Glauber 06/01/2011
   // Caso os campos venham no formato tabela.campo, remover o tabela.

   for lnindCAMPOS := 1 to len(laCAMPOS)
       // Caso seja informado o tabela.campo, remover o tabela.
       if at('.',laCAMPOS[lnindCAMPOS]) > 0
          laCAMPOS[lnindCAMPOS] := substr(laCAMPOS[lnindCAMPOS],at('.',laCAMPOS[lnindCAMPOS]) + 1,len(laCAMPOS[lnindCAMPOS]))
       endif
       // Caso seja informado o tabela.campo as campo, remover o tabela.campo as
       if at(' as ',laCAMPOS[lnindCAMPOS]) > 0
          laCAMPOS[lnindCAMPOS] := substr(laCAMPOS[lnindCAMPOS],at(' as ',laCAMPOS[lnindCAMPOS]) + 5,len(laCAMPOS[lnindCAMPOS]))
       endif
   next lnindCAMPOS
//   DEBUG2(LACAMPOS,,200)
   lcWHERE2 := 'wfield.WFIELD in('
   for lnindCAMPOS := 1 to len(paCAMPOS)
       lcWHERE  += DLAP + paCAMPOS[lnindCAMPOS] + DLAP
       lcWHERE2 += DLAP + paCAMPOS[lnindCAMPOS] + DLAP
       if lnindCAMPOS < len(paCAMPOS)
          lcWHERE += ','
          lcWHERE2 += ','
       endif
   next lnindCAMPOS

   lcWHERE2 += ')'
//DEBUG2(LCWHERE,,200)
//DEBUG2(LCWHERE2,,200)
// Glauber 04/03/2011
// Comentei a linha abaixo, pois sempre deve ser pego o valor padrão do campo na wfield e caso exista a redefinição por perfil, vai ser atribuido por ela.
//   lcWHERE2 += ' and acfieldredef.WGID = ' + str(WSet('WGID'))

   //
   // Glauber 10/01/2011
   // Primeiro eu faço o select na wfield para alimentar a dataglobal, pelo motivo que o campo sempre fica redefinido
   // quando é encontrado um registro na wfield_perfil. Com isto eu volto o catálogo em seu estado original, para logo
   // abaixo verificar se o campo deve ser redefinido de acordo com o tipo de pasta e perfil de usuário.
   //
   // Glauber 02/02/2010
   // Quando o campo esta definido para ser oculto no gerenciamento de perfis, não deve ser alimentado
   // com os dados da wfield.
   //

   // Glauber 04/03/2011
   // Primeiramente pesquisar no catálogo interno do wictrix (wfield)

   if db_select({'distinct(wfield.WFIELD)',;
                 'wfield.LABEL_SCREEN',;
                 'acfieldredef.WFIELD_VIEW'},;
                 'wfield',;
                 {{2,'acfieldredef','acfieldredef.WFIELD = wfield.WFIELD'}},;
                 {lcWHERE2}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
//   wout('Campos na wfield:'+lcWHERE2)
//   debug2(laRESULT,,20)
   for lnindRES := 2 to len(laRESULT)
       if alltrim(laRESULT[lnindRES,3]) <> ''
          WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'S|&'+laRESULT[lnindRES,2]+'|&|&S|&|&|&|&')
       endif
   next lnindRES
   // Por último verificar se na tabela wfield_perfil contém a redefinição por tipo de pasta
   for lnindCAMPOS := 1 to len(laCAMPOS)
       lcWHERE += DLAP + laCAMPOS[lnindCAMPOS] + DLAP
       if lnindCAMPOS < len(laCAMPOS)
          lcWHERE += ','
       endif
   next lnindCAMPOS
   lcWHERE += ')'
   // sonia perdigao - 2/3/2012 11:44:34 AM
// alteracao para corrigir a exibiçao dos campos ocultos que estavam apagando o conteudo anterior das colunas
   if db_select({'WFIELD','LABEL_SCREEN','WHIDDEN','WLABEL_VIEW','WLABEL_COLOR','WFIELD_RO','WFIELD_COLOR','WFIELD_BGCOLOR','PASTAS','GROUPS'},'wfield_perfil',,{lcWHERE},{'WFIELD'}) == -1
//   if db_select({'WFIELD','LABEL_SCREEN','WHIDDEN'},'wfield_perfil',,{lcWHERE}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()


//wout('Campos na wfield_perfil:'+lcWHERE)
//debug2(laRESULT,,20)

   for lnindRES := 2 to len(laRESULT)

       // Glauber 09/2015 - Verificar se o tipo de pasta e o wgid são exatos porque utilzou-se like no select.

       laPASTAS := Str2Array(laRESULT[lnindRES,db_fetchncol(laRESULT,'PASTAS')],',')
       laGROUP  := Str2Array(laRESULT[lnindRES,db_fetchncol(laRESULT,'GROUPS')],',')


       for ii := 1 TO LEN(laPASTAS)

           for xx := 1 to len(laGROUP)

               if alltrim(laPASTAS[ii]) == pcTP_PASTA .and. alltrim(laGROUP[xx]) == alltrim(lcGROUP)

                   if laRESULT[lnindRES,3] <> 'S'
                        if laRESULT[lnindRES,6] <> 'S'
                           WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'N|&'+laRESULT[lnindRES,2]+'|&'+laRESULT[lnindRES,5]+'|&N|&N|&|&'+laRESULT[lnindRES,7]+'|&'+laRESULT[lnindRES,8])
                        else
                           WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'N|&'+laRESULT[lnindRES,2]+'|&'+laRESULT[lnindRES,5]+'|&N|&S|&|&'+laRESULT[lnindRES,7]+'|&'+laRESULT[lnindRES,8])
                        endif
                   else
                        if laRESULT[lnindRES,6] <> 'S'
                           WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'S|&'+laRESULT[lnindRES,2]+'|&'+laRESULT[lnindRES,5]+'|&S|&N|&|&'+laRESULT[lnindRES,7]+'|&'+laRESULT[lnindRES,8])
                        else
                           WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'S|&'+laRESULT[lnindRES,2]+'|&'+laRESULT[lnindRES,5]+'|&S|&S|&|&'+laRESULT[lnindRES,7]+'|&'+laRESULT[lnindRES,8])
                        endif

            /*
            Definiçao: _FIELDREDEF_AFASTAMENTO_FIM==>S|&TESTE AFASTAMENTO|&CC33FF|&S|&S|&|&|&
            Definiçao: _FIELDREDEF_          CARGO==>S|&CARGO TESTE      |&      |&S|&S|&|&|&
            Definiçao: _FIELDREDEF_TP_CONTRATO    ==>S|&TIPO CONTRATO TESTE|&|&S|&S|&|&|&
            Definiçao: _FIELDREDEF_ULTIMO_SALARIO==>S|&ULTIMO SALARIO TESTE|&|&S|&S|&|&|&

            */

                   endif
               endif
           next xx
       next ii
   next lnindRES

return   


/*
* Glauber  
*
* Function  : GetGroupName(pnGroup)
* Objetivo  : Retorna o nome do grupo.
*
*
* Parâmetros:
*
*  pnGroup..: Código do grupo
*
* Retorno:    Nome do grupo
*
*/

Function GetGroupName(pnGroup)


   local laRES := {} as Array
   local lcRET := '' as String
   
   if pnGroup > 0

   if db_select({'WGROUP'},'acgroup',,{'WGID='+alltrim(pnGroup)}) == -1
      error_sys(db_error())
   endif
   laRESULT := db_fetchall()
   
   if len(laRESULT) > 1
      lcRET := laRESULT[2,1]
   endif

   endif


return lcRET



/*
* Glauber  
*
* Function  : GeraFiltroNovoPerfil()
* Objetivo  : Gerar a carga inicial na tabela wfield_perfil de acordo com o conteúdo da tabela acfield_redef.
*             Esta função é utilizada somente no tasks.
*             
* Parâmetros:
*
* Retorno:    Nada
*             
*/   

Function GeraFiltroNovoPerfil()

   local laTP_PASTAS := {},;
         laFILTRO_PASTAS := {},;
         laREDEFS := {},;
         laTMP    := {},;
         laRESULT := {},;
         laSAVE   := {} as array
   local lnindREDEFS := 0,;
         lnindTP_PASTAS := 0,;
         lnindFILTRO := 0 as int
   local lcWFIELD := '',;
         lcTP_PASTA := ''
   local lnWGID      := 0       
   

   // Selecionar todos os tipos de pasta no pasta_config
         
   if db_select({'TP_PASTA'},'pasta_config') == -1
      error_sys(db_error())
   endif
   laTP_PASTAS := db_fetchall()

   // Selecionar campos redefinidos
   
   if db_select({'acfieldredef.WGID',;
                 'acfieldredef.WFIELD',;
                 'acfieldredef.WLABEL_VIEW',;
                 'acfieldredef.WFIELD_VIEW',;
                 'acfieldredef.WLABEL_CONTENT',;
                 'acgroup_filter.WTABLE',;
                 'acgroup_filter.FUCONTENT'},'acfieldredef',{{2,'acgroup_filter','acgroup_filter.WGID = acfieldredef.WGID'}},,{'acfieldredef.WGID','acfieldredef.WFIELD'}) == -1
      error_sys(db_error())
   endif
   laREDEFS := db_fetchall()
//   wout('laREDEFS')
//   debug2(laREDEFS,,20)
   for lnindREDEFS := 2 to len(laREDEFS)
       // Registros que contenham o campo WLABEL_VIEW E WFIELD_VIEW COMO 'S' e o conteúdo da coluna WLABEL_CONTENT vazio devem ser despresados
       if laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')] == 'S' .and. laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WFIELD_VIEW')] == 'S' .and. empty(alltrim(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_CONTENT')]))
       else  
          laSAVE := {{'WGID','TP_PASTA','WFIELD','WHIDDEN','LABEL_SCREEN'}}
          // Caso exista filtro de visualização de pasta para o grupo de usuário em questão, deve ser inserido apenas os tipos de pastas definido no filtro
          if (lower(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WTABLE')]) == 'pasta' .or. lower(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WTABLE')]) == 'pasta_config') .and. ;
              ! empty(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'FUCONTENT')])
              laFILTRO_PASTAS := str2array(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'FUCONTENT')],",")
              //wout('Filtro das pastas')
              //debug2(laFILTRO_PASTAS,,20)
              for lnindFILTRO := 1 to len(laFILTRO_PASTAS)
                  laTMP := {laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WGID')],;
                            laFILTRO_PASTAS[lnindFILTRO],;
                            laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WFIELD')],;
                            iif(empty(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')]) .or. laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')] == 'N','N','S'),;
                            laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_CONTENT')]}
                  // Verificar se ja não existe o registro pois na tabela acfield_redef, pois existe caso que o mesmo campo esta definido para a tabela pasta e pasta_config          
                  lnWGID     := laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WGID')]
                  lcWFIELD   := alltrim(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WFIELD')])
                  lcTP_PASTA := alltrim(laFILTRO_PASTAS[lnindFILTRO])             
                  if db_select({'count(*)'},'wfield_perfil',,{'WGID='+alltrim(lnWGID)+ ' and TP_PASTA = ' + DLAP + lcTP_PASTA + DLAP + ' and WFIELD = ' + DLAP + lcWFIELD + DLAP}) == -1
                     error_sys(db_error())
                  endif
                  laRESULT := db_fetchall()
                  if laRESULT[2,1] == 0            
                     aadd(laSAVE,laTMP)
                  endif   
                //  wout('laTMP')
                //  debug2(laTMP,,20)
              next lnindFILTRO
          else // não existe filtro por tipo de pastas, processar de acordo com o pasta_config
              for lnindTP_PASTAS := 2 to len(laTP_PASTAS)
                  //                            iif(empty(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')]) .or. laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')] == 'N','S','N'),;
                  laTMP := {laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WGID')],;
                           laTP_PASTAS[lnindTP_PASTAS,1],;
                           laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WFIELD')],;
                           iif(empty(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')]) .or. laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_VIEW')] == 'N','N','S'),;
                           laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WLABEL_CONTENT')]}
                  // Verificar se ja não existe o registro pois na tabela acfield_redef, pois existe caso que o mesmo campo esta definido para a tabela pasta e pasta_config          
                  lnWGID     := laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WGID')]
                  lcWFIELD   := alltrim(laREDEFS[lnindREDEFS,db_fetchncol(laREDEFS,'WFIELD')])
                  lcTP_PASTA := alltrim(laTP_PASTAS[lnindTP_PASTAS,1])             
                  if db_select({'count(*)'},'wfield_perfil',,{'WGID='+alltrim(lnWGID)+ ' and TP_PASTA = ' + DLAP + lcTP_PASTA + DLAP + ' and WFIELD = ' + DLAP + lcWFIELD + DLAP}) == -1
                     error_sys(db_error())
                  endif
                  laRESULT := db_fetchall()
                  if laRESULT[2,1] == 0            
                     aadd(laSAVE,laTMP)
                  endif   
              //    wout('laTMP')
              //    debug2(laTMP,,20)
              next lnindTP_PASTAS            
          endif
          if len(laSAVE) > 1
             if db_insert(laSAVE,'wfield_perfil') == -1
                error_sys(db_error())
            endif          
          endif
       endif   
//       wout('laSAVE')
//       debug2(laSAVE,,20)
   next lnindREDEFS     
   
return


/*
* Function..: AddMonth()
* Objetivo..: Retorna dia fixa para vencimentos futuros
* Parâmetros: data inicial e qtde de meses a serem somados
*
* Retorno...: data futura
* Glauber
* 30/6/2011 17:22:24
? '1:'
?? AddMonth(date(),1)
?? AddMonth(date(),48)
*/
Function AddMonth(pData, pMeses)

local lnDia := day(pData),;
      lnMes := month(pData),;
      lnAno := year(pData),;
      x     := 0,;
      y     := 0 as int
local ldValida

set date british
set date format to 'dd/mm/yyyy'

      for x := 1 to pMeses
          if lnMes >= 12
             ++lnAno
             lnMes := 1
          else
             ++lnMes
          endif
          lnDia := day(pData)
          ldValida := ctod(strzero(lnDia,2) + '/' + strzero(lnMes,2) +'/' +strzero(lnAno,4))
          while ! DateValid(ldValida) .and. (y < 1000)
                --lnDia
                ldValida := ctod(strzero(lnDia,2) + '/' + strzero(lnMes,2) +'/' +strzero(lnAno,4))
                ++y
          enddo
      next x

return(dtoc(ldValida))

/*
* Function..: IsBiSexto()
* Objetivo..: Verifica se o ano é bissexto
* Parâmetros: 
*
* Retorno...: true or false
* Glauber
* 30/6/2011 17:22:24
*/

Function IsBiSexto(pYear)

local lnResult, lnResto

lnResult := pYear / 4
lnResto := lnResult - int(lnResult)

return(iif(lnResto<>0,.f.,.t.))


/*
* Data da Criação: 27/09/2011 - Glauber Vicente Duma
* Observação.....: Customização para banco Alfa
* Function.......: GetFilterDespesa()
* Objetivo.......: Retorna o filtro de despesa para compor o where das telas
*                  de despesa revisão e despesa aprovação.
* Parâmetros.....:
*                  <pcEtapa>    Tipo do Filtro ( Revisão / Aprovação)
*
* Retorno........: String contendo o filtro
*
*/
Function GetFilterDespesa(pcEtapa)

   local lcResult := '' as String
   local laResult := {} as Array

   if db_select({'FILTRO'},'filtro_aux_despesas',,{'WUID='+alltrim(WSet('WUID')) + ' and ETAPA = ' + DLAP + pcETAPA + DLAP}) == -1
      error_sys(db_error())
   endif
   laRESULT:= db_fetchall()
   if len(laRESULT) > 1
      lcResult := strtran(laRESULT[2,1],"`","'")
   endif

return(lcResult)


/*
* Data......: 19/12/2012 - Glauber - customização Unimed
* Function..: PodeAlterarPasta(pnNR_PASTA)
* Objetivo..: Verifica se usuário logado é o advogado interno da pasta, retornando .t. caso seja.
* Parâmetros:
*  pnNR_PASTA: Número da Pasta
* Retorno...: .t. se a pasta pode ser alterara.
*/

Function PodeAlterarPasta(pnNR_PASTA)

   local llretorno   := .f.
   local laRESULT := {},;
         laFIELDS := {},;
         laJOIN   := {} as array


   laFIELDS := {'pasta.NR_PASTA',;
                'acuser.LOGIN',;
                'pasta.FL_PASTA',;
                'pasta_cip.CIP'}

   laJOIN := {{2,'pasta_cip',"(pasta.NR_PASTA = pasta_cip.NR_PASTA and pasta_cip.WFIELD = 'CIP_ADVOGADO_INTERNO')"},;
              {2,'acuser',"((acuser.CIP = pasta_cip.CIP))"}}
   if db_select(laFIELDS,'pasta',laJOIN,{"pasta.NR_PASTA = " + STR(pnNR_PASTA) }) ==-1
      error_sys('PodeAlterarPasta:'+db_error())
   endif
   laResult  := db_fetchall()

   // Caso a pasta esteja encerrada, a mesma pode ser alterada somente se o usuário logado for o advogado interno da pasta.

   if len(laResult) > 1
      if (lower(laRESULT[2,3]) != 'encerrada')
          llretorno := .t.
      else
         if (lower(laRESULT[2,2]) == lower(WSet('LOGIN')))
            llretorno := .t.
         endif
      endif
   else // Caso não retorne o registro, significa que o advogado interno ainda não foi incluido, então é liberado para alterações.
      llretorno := .t.
   endif


   return llretorno


/*
* Data......: 20/12/2012 - Glauber - customização Unimed
* Function..: Pasta2LayoutPasta(pnNR_PASTA)
* Objetivo..: Retorna o layout de uma determinada pasta
* Parâmetros:
*  pnNR_PASTA: Número da Pasta
* Retorno...: layout da pasta
*/

Function Pasta2LayoutPasta(pnNR_PASTA)

   local retorno  := '' as String
   local laRESULT := {},;
         laFIELDS := {},;
         laJOIN   := {} as array


   laFIELDS := {'layout_pasta'}

   laJOIN := {{0,'pasta',"(pasta.TP_PASTA = pasta_config.TP_PASTA)"}}
   if db_select(laFIELDS,'pasta_config',laJOIN,{"pasta.NR_PASTA = " + STR(pnNR_PASTA) }) ==-1
      error_sys('Pasta2LayoutPasta:'+db_error())
   endif
   laResult  := db_fetchall()

   if len(laRESULT) > 1
      retorno := laRESULT[2,1]
   endif
   return retorno



/*
* Data da Criação: 13/06/2012 - Glauber Vicente Duma
*                  18/12/2014 - Glauber - Adição do campo FL_CRITICO e autalização do pasta_andamento_last
*                  18/08/2015 - Adição dos campos LOGIN, FL_ANDAMENTO, NR_PASTA_RECURSO, NR_ANDAMENTO_RELACAO, VINCULO, NR_ANDAMENTO_VINCULADO, NR_CONTRATO_ADITIVO,NR_CONTRATO_ANEXO,HORAS_TRABALHADAS,NR_ATO,HR_CADASTRO,DT_PRAZO
* Observação.....: Nova funcionalidade Workflow
* Function.......: WfNovoAndamento()
* Objetivo.......: Inserir um andamento na tabela pasta_andamento com base nos parâmetros recebido.
*
* Parâmetros.....:
*   pNR_PASTA       Número da pasta
*   pAUTOPROC       Auto
*   pTP_ANDAMENTO   Tipo do andamento
*   pDT_ANDAMENTO   Data do andamento
*   pANDAMENTO      Descrição do andamento
*   pLOGIN_RESP     Login responsável
*   pDT_CADASTRO    Data de cadastro
*   pFL_PUBLICO     Público
*   pFL_CRITICO     Critico
*
* Retorno........: nenhum.
*
*/



function WfNovoAndamento(pNR_PASTA, pAUTOPROC, pTP_ANDAMENTO, pDT_ANDAMENTO, pANDAMENTO, pLOGIN_RESP, pDT_CADASTRO, pFL_PUBLICO, pFL_CRITICO, pLOGIN, pFL_ANDAMENTO, pNR_PASTA_RECURSO, pNR_ANDAMENTO_RELACAO, pVINCULO, pNRANDVINC, pNR_CONTRATO_ADITIVO, pNRCONTANEXO, pHORAS_TRABALHADAS, pNR_ATO, pHR_CADASTRO, pDT_PRAZO)
/*
   local laSAVE := {{'NR_PASTA',;
                     'NR_AUTOPROC',;
                     'TP_ANDAMENTO',;
                     'DT_ANDAMENTO',;
                     'ANDAMENTO',;
                     'LOGIN_RESP',;
                     'DT_CADASTRO',;
                     'FL_PUBLICO',;
                     'FL_CRITICO',;
                     'FL_ANDAMENTO_EXTERNO',;
                     'FL_ANDAMENTO_CANCELADO'},;
                     {iif(valtype(pNR_PASTA) == 'C',val(pNR_PASTA), pNR_PASTA),;
                      iif(valtype(pAUTOPROC) == 'C',val(pAUTOPROC), pAUTOPROC),;
                      pTP_ANDAMENTO,;
                      pDT_ANDAMENTO,;
                      pANDAMENTO,;
                      pLOGIN_RESP,;
                      pDT_CADASTRO,;
                      pFL_PUBLICO,;
                      pFL_CRITICO,;
                      'N',;
                      'N'}}
*/

// LOGIN, FL_ANDAMENTO, NR_PASTA_RECURSO, NR_ANDAMENTO_RELACAO, VINCULO, NR_ANDAMENTO_VINCULADO, NR_CONTRATO_ADITIVO,NR_CONTRATO_ANEXO,HORAS_TRABALHADAS,NR_ATO,HR_CADASTRO,DT_PRAZO

// pLOGIN:Login,pFL_ANDAMENTO:Andamento para cliente,pNR_PASTA_RECURSO:Nr Pasta Recurso,pNR_ANDAMENTO_RELACAO:Andamento Relacionado,pVINCULO:Vínculo,pNRANDVINC:Andamento Vinculado,pNR_CONTRATO_ADITIVO:Número Aditivo,pNRCONTANEXO:Número Anexo,pHORAS_TRABALHADAS:Horas Trabalhadas,pNR_ATO:Número Ato,pHR_CADASTRO:Hora de Cadastro,pDT_PRAZO:Prazo

   local laSAVE := {{'NR_PASTA',;
                     'NR_AUTOPROC',;
                     'TP_ANDAMENTO',;
                     'DT_ANDAMENTO',;
                     'ANDAMENTO',;
                     'LOGIN_RESP',;
                     'DT_CADASTRO',;
                     'FL_PUBLICO',;
                     'FL_CRITICO',;
                     'FL_ANDAMENTO_EXTERNO',;
                     'FL_ANDAMENTO_CANCELADO',;
                     'LOGIN',;
                     'FL_ANDAMENTO',;
                     'NR_PASTA_RECURSO',;
                     'NR_ANDAMENTO_RELACAO',;
                     'VINCULO',;
                     'NR_ANDAMENTO_VINCULADO',;
                     'NR_CONTRATO_ADITIVO',;
                     'NR_CONTRATO_ANEXO',;
                     'HORAS_TRABALHADAS',;
                     'NR_ATO',;
                     'HR_CADASTRO',;
                     'DT_PRAZO'},;
                     {iif(valtype(pNR_PASTA) == 'C',val(pNR_PASTA), pNR_PASTA),;
                      iif(valtype(pAUTOPROC) == 'C',val(pAUTOPROC), pAUTOPROC),;
                      pTP_ANDAMENTO,;
                      pDT_ANDAMENTO,;
                      pANDAMENTO,;
                      pLOGIN_RESP,;
                      pDT_CADASTRO,;
                      pFL_PUBLICO,;
                      pFL_CRITICO,;
                      'N',;
                      'N',;
                      pLOGIN,;
                      pFL_ANDAMENTO,;
                      pNR_PASTA_RECURSO,;
                      pNR_ANDAMENTO_RELACAO,;
                      pVINCULO,;
                      pNRANDVINC,;
                      pNR_CONTRATO_ADITIVO,;
                      pNRCONTANEXO,;
                      pHORAS_TRABALHADAS,;
                      pNR_ATO,;
                      pHR_CADASTRO,;
                      pDT_PRAZO}}


   local lnPos := 0 as int

   if valtype(pNR_PASTA) == 'C'
      pNR_PASTA := val(pNR_PASTA)
   endif

   // Caso não seja informado o valor para NR_CONTRATO_ADITIVO, remover da lista de campos para não atrapalhar a rotina de aprovação feita pelo Rufus.

   if empty(alltrim(pNR_CONTRATO_ADITIVO))
      lnPos := ascan(laSAVE[1],'NR_CONTRATO_ADITIVO')
      if lnPos > 0
          adel(laSAVE[1],lnPOS)
          adel(laSAVE[2],lnPOS)
          asize(laSAVE[1],len(laSAVE[1])-1)
          asize(laSAVE[2],len(laSAVE[2])-1)
      endif
   endif

   // Caso não seja informado o valor para NR_CONTRATO_ANEXO, remover da lista de campos para não atrapalhar a rotina de aprovação feita pelo Rufus.

   if empty(alltrim(pNRCONTANEXO))
      lnPos := ascan(laSAVE[1],'NR_CONTRATO_ANEXO')
      if lnPos > 0
          adel(laSAVE[1],lnPOS)
          adel(laSAVE[2],lnPOS)
          asize(laSAVE[1],len(laSAVE[1])-1)
          asize(laSAVE[2],len(laSAVE[2])-1)
      endif
   endif


   if pNR_PASTA > 0

       if db_insert(laSAVE,'pasta_andamento') = -1
          error_sys(db_error())
       endif


       if db_select({'NR_PASTA','ANDAMENTO','DT_ANDAMENTO','TP_ANDAMENTO','HR_CADASTRO'},'pasta_andamento',,{'NR_PASTA='+alltrim(pNR_PASTA)},{'NR_ANDAMENTO'},'D',,{1}) = -1
          error_sys(db_error())
       endif
       laSAVE := db_fetchall()
       if len(laSAVE) > 1
          if db_replace(laSAVE,'pasta_andamento_last',{'NR_PASTA='+alltrim(pNR_PASTA)}) = -1
             error_sys(db_error())
          endif
       endif
   endif


return

/*
* Function..: array2json(faVALUES)
* Objetivo..: Converter um vetor, um matriz comum ou uma matriz aninhada para uma string JSon,
* Parâmetros:
*    faVALUES: Vetor/matriz a ser convertida
*
* Retorno....: String no formato:
*     [["FIELD1"      ,"FIELD2"      ,"FIELD3"      ,"FIELD4"     ],
*      ["VALUE_FIELD1","VALUE_FIELD2","VALUE_FIELD3","VALUE_FIELD4"]]
*/
function array2json(faVALUES)
   local lcRESULT := '' as string

   local ii     := 0 ,;
         lnOPEN := 0 as int

   lcRESULT += '['
   ++lnOPEN

   if valtype(faVALUES) == 'A'
      for ii := 1 to len(faVALUES)
         if valtype(faVALUES[ii]) == 'A'
            lcRESULT += array2json(faVALUES[ii])+','
         else
            if valtype(faVALUES[ii]) == 'C'
               lcRESULT += '"'+faVALUES[ii]+'"'
            elseif valtype(faVALUES[ii]) == 'N'
               lcRESULT += '"'+alltrim(str(faVALUES[ii]))+'"'
            elseif valtype(faVALUES[ii]) == 'D'
               lcRESULT += '"'+dtoc(faVALUES[ii])+'"'
            elseif valtype(faVALUES) == 'B'
               lcRESULT += '"'+faVALUES[ii]+'"'
            endif
            lcRESULT += ','
         endif
      next ii
   else
      if valtype(faVALUES) == 'C'
         lcRESULT += '"'+faVALUES+'"'
      elseif valtype(faVALUES) == 'N'
         lcRESULT += '"'+alltrim(str(faVALUES))+'"'
      elseif valtype(faVALUES) == 'D'
         lcRESULT += '"'+dtoc(faVALUES)+'"'
      elseif valtype(faVALUES) == 'B'
         lcRESULT += '"'+faVALUES+'"'
      endif
      lcRESULT += ','
   endif

   for ii := 1 to lnOPEN
       lcRESULT += ']'
   next ii

   lcRESULT := strtran(lcRESULT,",]","]")
return(lcRESULT)


/*
* Data da Criação: 03/07/2012 - Glauber Vicente Duma
* Observação.....: Nova funcionalidade Workflow
* Function.......: WfSendGedEmail()
* Objetivo.......: Enviar todos os geds presente na tabela wf_ged_email por email.
*
* Parâmetros.....:
*   nenhum
*
* Retorno........: nenhum.
*
*/


FUNCTION WfSendGedEmail()


   local laRESULT := {} as Array
   local lnii    := 0 as int


   local laFIELDS := {'wf_ged_email.nr_controle',;
                      'wf_ged_email.nr_ctrged',;
                      'wf_ged_email.nr_ctrgedfile',;
                      'wf_ged_email.login',;
                      'pfpj.PFPJ',;
                      'pfpj.EMAIL',;
                      'gedfile.gdfilename',;
                      'gedfile.login_insert',;
                      'ged.tp_documento',;
                      'ged.referencia1',; // NR_PASTA
                      'ged.gdcomment',;
                      'ged.gdkeyword'}
   local laJOIN   := {{0,'acuser','wf_ged_email.login = acuser.login'},;
                      {0,'pfpj','pfpj.cip = acuser.cip'},;
                      {0,'gedfile','wf_ged_email.nr_ctrged = gedfile.nr_ctrged and wf_ged_email.nr_ctrgedfile = gedfile.nr_ctrgedfile'},;
                      {0,'ged','wf_ged_email.nr_ctrged=ged.NR_CTRGED'}}

   local lcCONT   := '',;
         lcOrigem := 'apoio@insocorp.com.br',;
         lcLayXml := '',;
         lcErro   := '',;
         lcCaminhoApp := '',;
         lcAssunto := '',;
         lcConteudo := '',;
         lcConfMail := '',;
         lcGEDID    := '',;
         lcGED      := '',;
         lcGEDFILE  := '',;
         lcGEDVERS  := '',;
         lcFILEIN   := '',;
         lcFILEOUT  := '',;
         lcRAND     := '',;
         lcCommand  := '',;
         lcBeuffer  := ''  as String

   if db_select(laFIELDS,'wf_ged_email',laJOIN,{"wf_ged_email.status is null or wf_ged_email.status = ''" }) == -1
      error_sys(db_error())
   endif
   laRESULT:= db_fetchall()

   lcCaminhoApp:= WSet('ISJMAILAPP') // Caminho com o nome da aplicação de envio de email
//   lcAssunto   := WSet('WFGEDMAILASSUNTO')
//   lcConteudo  := WSet('WFGEDMAILCONTEUDO')
   lcConfMail  := WSet('WFGEDMAILCONF')

   for lnii := 2 to len(laRESULT)

       lcGEDID   := strzero(laRESULT[lnii,2],9)
       wout('Enviando arquivo do ged:'+lcGEDID)
       lcGED     := substr(lcGEDID,1,9)
       lcGEDFILE := substr(strzero(laRESULT[lnii,3],9),4,9)
       lcGEDVERS := substr(strzero(laRESULT[lnii,3],9),7,3)

       // Glauber 06/07/2012
       // Tratar o nome do arquivo removendo os caracteres em branco, pois encontri problemas no linux.
       //
       laRESULT[lnii,7] := strtran(laRESULT[lnii,7],' ','_')
       laRESULT[lnii,7] := lat2char(substr(laRESULT[lnii,7],1, rat('.',laRESULT[lnii,7]))) +substr(laRESULT[lnii,7],rat('.',laRESULT[lnii,7]))
       lcFILEIN  := gedstructfile(val(lcGED),val(lcGEDFILE),val(lcGEDVERS))
       lcFILEOUT := WSet('WTEMP') + '/' + Wset('LOGIN')+laRESULT[lnii,7]
       lcFILETMP := lcFILEOUT
       lcAssunto := WSet('WFGEDMAILASSUNTO')
       lcConteudo:= WSet('WFGEDMAILCONTEUDO')

       copy file (lcFILEIN) to (lcFILEOUT)

       lcLayXml := '<DESTINATARIO>' + laRESULT[lnii,6] + '</DESTINATARIO>' + chr(13)+;
                   '<REMETENTE>' + WSet('WFGEDMAILREMETENTE') + '</REMETENTE>'+chr(13) +;
                   '<ASSUNTO>'+ lcAssunto + '</ASSUNTO>' +chr(13)+;
                   '<CONTEUDO>' + lcConteudo + '</CONTEUDO>' +chr(13)+;
                   '<ANEXO>' + lcFILEOUT + '</ANEXO>'

       // Executar um parser para trocar os conteúdos entre "[]"

       for xx := 1 to len(laRESULT[1])
           lcLayXml := strtran(lcLayXml,("["+laRESULT[1,xx] + "]"),laRESULT[lnii,xx])
       next xx

       // Gerar os arquivos de email
//  função   inexistente no sql wic_random
//       lcRand   := ''
//       alltrim(wic_random())
       lcRand   := alltrim(wic_random())

       lcFILEIN := WSet('WTEMP') + '/' + 'ISJTASK_'+lcRand + '.xml'
       lcFILEOUT := WSet('WTEMP') + '/' + 'ISJTASK_'+lcRand + '.RET'

       // Envio
       lcCommand := lcCaminhoApp + ' ' + lcFileIn + ' ' + lcConfMail
       lnArqIn := fcreate(lcFileIn,0)
       lnERROR := ferror()
       if lnERROR == 0
          fwrite(lnArqIn,lcLayXml)
          fclose(lnArqIn)
       else
          lcErro := 'Erro ao gerar o arquivo de envio de email: '+alltrim(str(lnERROR))
       endif

       ! (lcCommand)

       // Processar o Retorno do envio

       lnArqOut := fopen(lcFileOut)
       if lnArqOut < 0 .or. ferror() > 0
    	    lcErro := 'Erro ao abrir o arquivo de retorno do email: '+alltrim(str(ferror()))
       endif
       lnSize    := fseek(lnArqOut,0,2)
       lcBuffer  := space(lnSize)
       fseek(lnArqOut,0,0)
       fread(lnArqOut,@lcBuffer,lnSize)
       fclose(lnArqOut)
       // Processar o retorno e gerar o log
       // <STATUS>OK</STATUS>
       lcBuffer := strtran(lcBuffer,'<STATUS>','')
       lcBuffer := strtran(lcBuffer,'</STATUS>','')
       laSAVE := {{'DT_ENVIO','HR_ENVIO','STATUS'}}

       if ! empty(lcErro)
          lcBuffer += '  '+ lcErro
       endif

       aadd(laSAVE,{date(),time(),lcBuffer})

       if db_update(laSAVE,'wf_ged_email',{'wf_ged_email.NR_CONTROLE = ' + str(laRESULT[lnii,1])} ) == -1
          error_sys(db_error())
       endif

       // Remover os arquivos utilizado para envio e retorno
       if Upper(WSet('MAILDEBUG')) <> 'ENABLED'
          Ferase(lcFileIn)
          Ferase(lcFileOut)
          Ferase(lcFILETMP)
       endif

   next lnii

return

/*
* Data da Criação: 03/07/2012 - Glauber Vicente Duma
* Observação.....: Nova funcionalidade Workflow
* Function.......: WfZipFile()
* Objetivo.......: Cria um arquivo compactado.
*
* Parâmetros.....:
*   pcFileOrigem    Nome do arquivo de origem, incluindo o path completo
*   pcFileDestino   Nome do arquivo de destino, incluindo o path completo
*
* Retorno........: nenhum.
*
*/

function WfZipFile(pcFileOrigem, pcFileDestino)

    local lcBuffer := "",;
          lcCompac := ""  as String
    local lnTam    := 0,;
          lnHANDLE := 0,;
          lnRet    := 0,;
          lnERROR  := 0   as int

    if (! File(pcFileOrigem)) .or. (empty(pcFileDestino))
       return
    endif

    lnHANDLE := fopen(pcFileOrigem,0)
    if lnHANDLE < 1 .or. ferror() > 0
       error_sys('Função WfZipFile, erro: '+alltrim(str(ferror()))+' ao tentar abrir arquivo de origem.')
    else
       lnTAM     := fseek(lnHANDLE,0,2)
       lcBuffer  := space(lnTAM)
       fseek(lnHANDLE,0,0)
       fread(lnHANDLE,@lcBuffer,lnTAM)
       fclose(lnHANDLE)
    endif

    lnRet := wzip(lcBuffer,@lcCompac,6)

    if (lnRet != 0)
       error_sys('Função WfZipFile, erro na compactação dos dados: '+str(lnRet))
    endif

    lnHANDLE := fcreate(pcFileDestino,0)
    lnERROR := ferror()
    if lnERROR == 0
       fwrite(lnHANDLE,lcCompac)
       fclose(lnHANDLE)
    else
       error_sys('Função WfZipFile, erro na gravação do arquivo compactado: '+str(lnERROR))
    endif









/*
* ------------------=================================== Funções de apoio do Workflow ==================================-------------------
*/

/*
* Function..: newwfmktc(<faPARMS>)
* Objetivo..: Nova função para criar Tarefas ou Compromisso permitindo informar qual o tipo de andamento e tipo de documento ged que quando for
*             inserido ira permitir a baixa automática do compromisso ou tarefa gerado por esta função.
* Parâmetros:
*    faPARMS: Matriz bidimensional contendo os nomes de campos/parametros e seus respectivos valores
*    Formato:
*     Parametro---------        Tipo---   Formato de envio--------------------------------  Descrição-------------------------------------------
*     {{'NR_CONTROLE'         , [expN] }                                                    Número de Controle
*      {'TP_TC'               , [expC] }  [T]-Tarefa [C]-Compromisso                        Tipo de Agenda
*      {'TITULO'              , [expC] }                                                    Título
*      {'LOGIN_AGENDADO'      , [expC] }                                                    Agendado por
*      {'DT_AGENDADO'         , [expC] }  YYYYMMDD                                          Data de agendamento
*      {'HR_AGENDADO'         , [expC] }  HHMMSS                                            Hora de agendamento
*      {'FL_PARTICULAR'       , [expC] }  [S]-Sim [N]-Não                                   TC particular
*      {'FL_PRAZO'            , <expC> }  [S]-Sim [N]-Não                                   Flag de prazo
*      {'DT_PRAZO'            , [expC] }  YYYYMMDD                                          Data do prazo
*      {'HR_PRAZO'            , [expC] }  HHMMSS                                            Hora do prazo
*      {'FL_INICIO'           , <expC> }  [S]-Sim [N]-Não                                   Flag de inicio
*      {'DT_INICIO'           , [expC] }  YYYYMMDD                                          Data de inicio
*      {'HR_INICIO'           , [expC] }  HHMMSS                                            Hora de inicio
*      {'FL_HR_OCUPADO'       , [expC] }  [S]-Sim [N]-Não                                   Flag de hora ocupada
*      {'FL_FIM'              , <expC> }  [S]-Sim [N]-Não                                   Flag de hora ocupada
*      {'DT_FIM'              , [expC] }  YYYYMMDD                                          Data final no formato
*      {'HR_FIM'              , [expC] }  HHMMSS                                            Hora final no formato
*      {'FL_DIAINTEIRO'       , [expC] }  [S]-Sim [N]-Não                                   Dia inteiro
*      {'FL_FILA'             , <expC> }  [S]-Sim [N]-Não                                   Fila
*      {'FL_POPUPPART'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via popup
*      {'FL_EMAILPART'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via email
*      {'FL_SMSPART'          , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via sms
*      {'FL_NOTIFICA'         , <expC> }  [S]-Sim [N]-Não                                   Avisar na criação
*      {'FL_REJEITA'          , [expC] }  [S]-Sim [N]-Não                                   Permitir recusa
*      {'FL_REDIRECIONA'      , [expC] }  [S]-Sim [N]-Não                                   Permitir redirecionamento
*      {'FL_AUTENTICA'        , [expC] }  [S]-Sim [N]-Não                                   Exige autenticação
*      {'FL_POPUPRESP'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via popup
*      {'FL_EMAILRESP'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via email
*      {'FL_SMSRESP'          , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via sms
*      {'REFERENCIA'          , [expC] }                                                    Referencia a um item no sistema
*      {'REF_CHAVE'           , [expC] }                                                    Chave da referencia
*      {'NM_TC'               , [expC] }                                                    Descrição do compromisso
*      {'PRIORIDADE'          , [expC] }                                                    Prioridade
*      {'LOGIN_ALTERA'        , [expC] }                                                    Login da ultima alteração
*      {'DT_ALTERA'           , [expC] }  YYYYMMDD                                          Data da ultima alteração
*      {'HR_ALTERA'           , [expC] }  HHMMSS                                            Hora da ultima alteração
*      {'TC_CATEGORIA'        , [expC] }                                                    Categoria da tarefa/compromisso
*      {'PARTICIPANTES'       , <expA> }  {'marcos','eduardo','mahler@inso.com.br','julio'} Participantes, pode ser usuário, grupo ou contato.
*      {'LEMBRETES'           , <expA> }  {{'D',10},{'D',10},{'H',10},{'M',30},{'D',20}}    Lembretes
*      {'RESPONSAVEIS'        , <expA> }  {'mahler','bruno','master'}                       Responsáveis, pode ser usuário ou grupo
*      {'EMAIL_SENDER'        , <expC> }  marcos@inso.com.br                                Email do remetente. Será usado quando o gr5tasks
*      {'BAIXA_TP_ANDAMENTO'  , <expC> }  Audiência                                   Tipo do Andamento que habilita a baixa automática.
*      {'BAIXA_TP_DOCUMENTO'  , <expC> }  Doc01                                       Tipo de documento ged que habilita a baixa automática.
*      {'AGENDA_GOOGLE'       , <expC> }  [S]-Sim [N]-Não                             Indica se a tarefa ou compromisso vai ser agendado também na agenda do google.
*      {'AGENDA_LOCAL'        , <expC> }  Inso                                        Indica o local do compromisso na agenda do google.
* 																												  enviar uma mensagem
*
*    OBS.: O parametro PARTICIPANTE poderá ter dois formatos: vetor ou matriz bidimensional
*
*       Vetor.: DEVE ser informado apenas na inserção de uma tarefa ou compromisso. Ex: {'marcos','eduardo','mahler@inso.com.br','julio'}
*       Matriz: DEVE ser informado apenas na alteração de uma tarefa ou compromisso, pois nesta situação existem os dados do grid
*               detalhado, tais dados devem ser gravados na tabela de participantes [tc_participante]. O formato OBRIGTÓRIO é:
*               {{LOGIN_PART1,TC_STATUS1,PC_CONCLUIDO1},;
*                {LOGIN_PART2,TC_STATUS2,PC_CONCLUIDO2},;
*                {LOGIN_PART3,TC_STATUS3,PC_CONCLUIDO3},;
*                {   ...     ,   ...    ,     ...     },;
*                {LOGIN_PARTn,TC_STATUSn,PC_CONCLUIDOn}}
*
*               Onde:
*                  Col 1 - Login do usuário participante
*                  Col 2 - Status do compromisso
*                  Col 3 - Percentual de conclusão
*
* Retorno...: int
*   > 0: Número do compromisso inserido
*   = 0: em caso de falha
*
*/
function newwfmktc(faPARAM)
   local lcDATA        := '' ,;
         lcHORA        := '' ,;
         lcTSTP        := '' ,;
         lcDT_LEMBRETE := '' ,;
         lcHR_LEMBRETE := '' ,;
         lcDT_INI      := '' ,;
         lcHR_INI      := '' ,;
         lcDT_END      := '' ,;
         lcHR_END      := '' ,;
         lcPROJECT     := '' ,;
         lcALIAS       := '' ,;
         lcTBORIGN     := '' ,;
         lcRETURN_PATH := '' ,;
         lcMSG         := '' ,;
         lcMSG_ERRO     := '' as string

   local laPARAM      := {} ,;
         laFIELDS     := {} ,;
         laSAVE       := {} ,;
         laSAVE_AUX   := {} ,;
         laWHERE      := {} ,;
         laPART       := {} ,;
         laPART_ANT   := {} ,;
         laLEMBR      := {} ,;
         laRESP       := {} ,;
         laREF        := {} ,;
         laSENDER     := {} ,;
         laSEND_TO    := {} ,;
         laTEMP       := {} ,;
         laTEMP1      := {} ,;
         laVINCULO    := {} ,;
         laEMAILS_DIV := {} as array // Emails diversos/avulsos

   local ii   := 0 ,;
         iiL  := 0 ,;
         jj   := 0 ,;
         lnID := 0 as int

   local llFOUND := .F. ,;
         llINS   := .F. as logical


   local luTMP

   lcPROJECT := WSet('_PROJECT')
   WSet('_PROJECT','workflow')

   /* Descrição do array:
   *  Coluna 1 - Nome do campo/parâmetro
   *  Coluna 2 - Indica se é campo obrigatorio ou não - [Y/N]
   */
   laPARAM := {{'NR_CONTROLE'   ,'' },; // Número de Controle
               {'TP_TC'         ,'Y'},; // Tipo de Agenda [T]-Tarefa [C]-Compromisso
               {'TITULO'        ,'' },; // Título
               {'LOGIN_AGENDADO','' },; // Agendado por
               {'DT_AGENDADO'   ,'' },; // Data de agendamento no formato YYYYMMDD
               {'HR_AGENDADO'   ,'' },; // Hora de agendamento no formato HHMMSS
               {'FL_PARTICULAR' ,'' },; // Compromisso/Tarefa particular ? [S]-Sim [N]-Não
               {'FL_PRAZO'      ,'Y'},; // Flag de prazo [S]-Sim [N]-Não
               {'DT_PRAZO'      ,'' },; // Data do prazo no formato YYYYMMDD
               {'HR_PRAZO'      ,'' },; // Hora do prazo no formato HHMMSS
               {'FL_INICIO'     ,'Y'},; // Flag de inicio [S]-Sim [N]-Não
               {'DT_INICIO'     ,'' },; // Data de inicio no formato YYYYMMDD
               {'HR_INICIO'     ,'' },; // Hora de inicio no formato HHMMSS
               {'FL_HR_OCUPADO' ,'' },; // Flag de hora ocupada [S]-Sim [N]-Não
               {'FL_FIM'        ,'Y'},; // Flag de hora ocupada [S]-Sim [N]-Não
               {'DT_FIM'        ,'' },; // Data final no formato YYYYMMDD
               {'HR_FIM'        ,'' },; // Hora final no formato HHMMSS
               {'FL_DIAINTEIRO' ,'' },; // Flag de dia inteiro [S]-Sim [N]-Não
               {'FL_FILA'       ,'Y'},; // Flag de fila [S]-Sim [N]-Não
               {'FL_POPUPPART'  ,'' },; // Flag de aviso do participante via popup [S]-Sim [N]-Não
               {'FL_EMAILPART'  ,'' },; // Flag de aviso do participante via email [S]-Sim [N]-Não
               {'FL_SMSPART'    ,'' },; // Flag de aviso do participante via sms [S]-Sim [N]-Não
               {'FL_NOTIFICA'   ,'Y'},; // Flag de aviso na criação [S]-Sim [N]-Não
               {'FL_REJEITA'    ,'' },; // Flag de permissão de recusa [S]-Sim [N]-Não
               {'FL_REDIRECIONA','' },; // Flag de permissão de redirecionamento [S]-Sim [N]-Não
               {'FL_AUTENTICA'  ,'' },; // Flag de exigencia de autenticação [S]-Sim [N]-Não
               {'FL_POPUPRESP'  ,'' },; // Flag de aviso do responsável via popup [S]-Sim [N]-Não
               {'FL_EMAILRESP'  ,'' },; // Flag de aviso do responsável via email [S]-Sim [N]-Não
               {'FL_SMSRESP'    ,'' },; // Flag de aviso do responsável via sms [S]-Sim [N]-Não
               {'REFERENCIA'    ,'' },; // Referencia a um item no sistema
               {'REF_CHAVE'     ,'' },; // Chave da referencia
               {'NM_TC'         ,'' },; // Descrição do compromisso
               {'PRIORIDADE'    ,'' },; // Prioridade
               {'LOGIN_ALTERA'  ,'' },; // Login da ultima alteração
               {'DT_ALTERA'     ,'' },; // Data da ultima alteração no formato YYYYMMDD
               {'HR_ALTERA'     ,'' },; // Hora da ultima alteração no formato HHMMSS
               {'TC_CATEGORIA'  ,'' },; // Categoria da tarefa/compromisso
               {'PARTICIPANTES' ,'Y'},; // Participantes, pode ser usuário, grupo ou contato.
               {'LEMBRETES'     ,'Y'},; // Lembretes
               {'RESPONSAVEIS'  ,'Y'},; // Responsáveis, pode ser usuário ou grupo
               {'EMAIL_SENDER'  ,'' },;  // Email do remetente. Será usado quando o gr5tasks enviar uma mensagem
               {'BAIXA_TP_ANDAMENTO', ''},; // Tipo do Andamento que habilita a baixa automática.
               {'BAIXA_TP_DOCUMENTO', ''},; // Tipo de documento ged que habilita a baixa automática.
               {'AGENDA_GOOGLE', ''},;      // Indica se a tarefa ou compromisso vai ser agendado também na agenda do google.
               {'AGENDA_LOCAL', ''}} // Indica o local do compromisso na agenda do google.




   // Array para testes de inserção do compromisso ----------------------------------------------------------------------------------------
   /*
   faPARAM := {{'NR_CONTROLE'   ,'0'},;                 // Número de controle
               {'TP_TC'         ,'T'},;                 // Tipo de Agenda [T]-Tarefa [C]-Compromisso
               {'TITULO'        ,'Teste compromisso'},; // Título
               {'LOGIN_AGENDADO','marcos'},; // Agendado por
               {'DT_AGENDADO'   ,'20041027'},; // Data de agendamento no formato YYYYMMDD
               {'HR_AGENDADO'   ,'10:20'},; // Hora de agendamento no formato HHMMSS
               {'FL_PARTICULAR' ,'N'},; // Compromisso/Tarefa particular ? [S]-Sim [N]-Não
               {'FL_PRAZO'      ,'S'},; // Flag de prazo [S]-Sim [N]-Não
               {'DT_PRAZO'      ,'20041027'},; // Data do prazo no formato YYYYMMDD
               {'HR_PRAZO'      ,'10:30'},; // Hora do prazo no formato HHMMSS
               {'DT_INICIO'     ,'20041028'},; // Data de inicio no formato YYYYMMDD
               {'HR_INICIO'     ,'11:00'},; // Hora de inicio no formato HHMMSS
               {'FL_INICIO'     ,'S'},; // Flag de inicio [S]-Sim [N]-Não
               {'FL_HR_OCUPADO' ,'S'},; // flag de hora ocupada [S]-Sim [N]-Não
               {'FL_FIM'        ,'S'},; // flag de hora ocupada [S]-Sim [N]-Não
               {'DT_FIM'        ,''},; // Data final no formato YYYYMMDD
               {'HR_FIM'        ,''},; // Hora final no formato HHMMSS
               {'FL_DIAINTEIRO' ,''},; // Flag de dia inteiro [S]-Sim [N]-Não
               {'FL_FILA'       ,'S'},; // Flag de fila [S]-Sim [N]-Não
               {'FL_POPUPPART'  ,''},; // Flag de aviso do participante via popup [S]-Sim [N]-Não
               {'FL_EMAILPART'  ,''},; // Flag de aviso do participante via email [S]-Sim [N]-Não
               {'FL_SMSPART'    ,''},; // Flag de aviso do participante via sms [S]-Sim [N]-Não
               {'FL_NOTIFICA'   ,''},; // Flag de aviso na criação [S]-Sim [N]-Não
               {'FL_REJEITA'    ,''},; // Flag de permissão de recusa [S]-Sim [N]-Não
               {'FL_REDIRECIONA',''},; // Flag de permissão de redirecionamento [S]-Sim [N]-Não
               {'FL_AUTENTICA'  ,''},; // Flag de exigencia de autenticação [S]-Sim [N]-Não
               {'REFERENCIA'    ,''},; // Referencia a um item no sistema
               {'REF_CHAVE'     ,''},; // Chave da referencia
               {'NM_TC'         ,'Testando inserção automática de compromisso'},; // Descrição do compromisso
               {'PRIORIDADE'    ,10},; // Prioridade
               {'LOGIN_ALTERA'  ,'assis'},; // Login da ultima alteração
               {'DT_ALTERA'     ,'20041025'},; // Data da ultima alteração no formato YYYYMMDD
               {'HR_ALTERA'     ,'11:21'},; // Hora da ultima alteração no formato HHMMSS
               {'TC_CATEGORIA'  ,''},; // Categoria da tarefa/compromisso
               {'PARTICIPANTES' ,{'marcos','eduardo','mahler@inso.com.br','julio'}},; // Participantes, pode ser usuário, grupo ou contato
               {'LEMBRETES'     ,{{'D',10},{'D',10},{'H',10},{'M',30},{'D',20}}},;                  // Lembretes
               {'RESPONSAVEIS'  ,{'mahler','bruno','master'}}}  // Responsáveis, pode ser usuário ou grupo

               //{'FL_POPUPRESP'  ,''},; // Flag de aviso do responsável via popup [S]-Sim [N]-Não
               //{'FL_EMAILRESP'  ,''},; // Flag de aviso do responsável via email [S]-Sim [N]-Não
               //{'FL_SMSRESP'    ,''},; // Flag de aviso do responsável via sms [S]-Sim [N]-Não

   */


//wout()

   if param_pos(faPARAM,'TP_TC') > 0
      lcTP_TC := upper(alltrim(faPARAM[param_pos(faPARAM,'TP_TC'),2]))
   else
      error_sys('wfmktc('+alltrim(str(procline()))+') Parameter not defined: TP_TC')
      WSet('_PROJECT',lcPROJECT)
      return(0)
   endif

//? 'Tipo:',lcTP_TC
//? 'Excluido de faPARAM --------------------'

   // Elimina parametros não utilizados para o tipo de agenda enviado ---------------------------------------------------------------------
   laTEMP := aclone(faPARAM)
   for ii := 1 to len(laTEMP)
       if (lcTP_TC=='T' .and. at(laTEMP[ii,1],'FL_FIM DT_FIM HR_FIM') > 0) .or.;
          (lcTP_TC=='C' .and. at(laTEMP[ii,1],'FL_PRAZO DT_PRAZO HR_PRAZO FL_DIAINTEIRO FL_INICIO FL_FILA PRIORIDADE') > 0)
          putERROR('wfmktc: Parameter not used: '+faPARAM[ii,1])

//? 'Linha:',param_pos(faPARAM,laTEMP[ii,1]),'excluido:',laTEMP[ii,1]

          adel(faPARAM,param_pos(faPARAM,laTEMP[ii,1]))
          asize(faPARAM,len(faPARAM)-1)
       endif
   next ii

   //Validação de parâmetros obrigatórios
   //for ii := 1 to len(laPARAM)
   //    if laPARAM[ii,2] == 'Y' .and. param_pos(faPARAM,laPARAM[ii,1]) == 0
   //       error_sys('wfmktc('+alltrim(str(procline()))+') Parameter not defined: '+laPARAM[ii,1])
   //       return(0)
   //    endif
   //next ii

   laFIELDS := structtable(WSet("DB_ACTIVE"),'tarefa_compromisso',1,'N','workflow')


//? 'Excluido de laFIELDS --------------------'

   // Elimina campos não utilizados para o tipo de agenda enviado -------------------------------------------------------------------------
   laTEMP := aclone(laFIELDS)
   for ii := 1 to len(laTEMP)
       if lcTP_TC == 'C' .and. ;
          at(laTEMP[ii],'FL_PRAZO DT_PRAZO HR_PRAZO FL_DIAINTEIRO FL_INICIO FL_FILA PRIORIDADE') > 0
          adel(laFIELDS,ascan(laFIELDS,laTEMP[ii]))
          asize(laFIELDS,len(laFIELDS)-1)

//? 'Tipo:',lcTP_TC,'Linha:',ii,'excluido:',laTEMP[ii],len(laFIELDS),len(laTEMP)

       elseif lcTP_TC == 'T' .and. at(laTEMP[ii],'FL_FIM DT_FIM HR_FIM') > 0
          adel(laFIELDS,ascan(laFIELDS,laTEMP[ii]))
          asize(laFIELDS,len(laFIELDS)-1)

//? 'Tipo:',lcTP_TC,'Linha:',ii,'excluido:',laTEMP[ii],len(laFIELDS),len(laTEMP)

       endif
   next ii

   laTEMP := {}
   if param_pos(faPARAM,'NR_CONTROLE') > 0
      lnID := val(faPARAM[param_pos(faPARAM,'NR_CONTROLE'),2])
   else
      lnID := 0
   endif

   // Gravacao de [tarefa_compromisso] ----------------------------------------------------------------------------------------------------
   aadd(laSAVE,laFIELDS)
   for ii := 1 to len(laFIELDS)
       lnPOS   := param_pos(faPARAM,laFIELDS[ii])  //posicao do campo na matriz de parametros
       llFOUND := lnPOS > 0
       do case
          case laFIELDS[ii] == 'TP_TC'          //Tipo [T]-Tarefa [C]-Compromisso
             aadd(laSAVE_AUX,faPARAM[lnPOS,2])
          case laFIELDS[ii] == 'TITULO'         //Titulo
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],'Compromisso automático'))
          case laFIELDS[ii] == 'LOGIN_AGENDADO' //Agendado por
             aadd(laSAVE_AUX,lower(iif(llFOUND,faPARAM[lnPOS,2],WSet('LOGIN'))))
          case laFIELDS[ii] == 'DT_AGENDADO'    //Data do agendamento
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],dtos(date())))
          case laFIELDS[ii] == 'HR_AGENDADO'    //Hora do agendamento
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],substr(time(),1,5)))
          case laFIELDS[ii] == 'FL_PARTICULAR'  //Compromisso particular
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],'N'))
          case laFIELDS[ii] == 'DT_ALTERA' .or. laFIELDS[ii] == 'HR_ALTERA'
             if llFOUND
                if lnID > 0
                   aadd(laSAVE_AUX,iif(!empty(faPARAM[lnPOS,2]),faPARAM[lnPOS,2],iif(laFIELDS[ii] == 'DT_ALTERA',date(),time())))
                else
                   aadd(laSAVE_AUX,nil)
                endif
             else
                aadd(laSAVE_AUX,nil)
             endif
          otherwise
             if llFOUND
                aadd(laSAVE_AUX,faPARAM[lnPOS,2])
             else
                aadd(laSAVE_AUX,nil)
             endif
       endcase
   next ii
   aadd(laSAVE,laSAVE_AUX)

   db_begin()
   if db_replace(laSAVE,'tarefa_compromisso',{'NR_CONTROLE='+alltrim(str(lnID))}) == -1
      error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
      WSet('_PROJECT',lcPROJECT)
      return(0)
   endif

   if lnID == 0
      llINS := .T.
      lnID  := db_insert_id()
   endif

//debug2(faPARAM,,30)

   // Gravação de [tc_participante] -------------------------------------------------------------------------------------------------------
   if param_pos(faPARAM,'PARTICIPANTES') > 0
      // Glauber 08/2012
      // Verificar se o prâmetro participantes é string ou array e fazer o devido tratamento
      if valtype(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]) == "C"
         laPART := str2array(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2],",")
      else
         laPART := faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]
      endif
//debug2(laPART,,30)
      if len(laPART) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_participante',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laPART)

             // Se for alteração e status for 1, armazena os participantes para serem enviados a wfremovealert
             // e atualizados em tc_login_lembrete.FL_AVISO='S' para gerar novamente o aviso caso seja necessário
             if !llINS .and. laPART[ii,2] == '1'
                aadd(laTEMP,laPART[ii,1])
             endif

             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                       aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'LOGIN_PARTICIPANTE'
                       aadd(laSAVE_AUX,lower(iif(llINS,laPART[ii],laPART[ii,1])))
                    case laFIELDS[jj] == 'TC_STATUS'
                       if lcTP_TC == 'T'
                          if faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
                             if llINS
                                aadd(laSAVE_AUX,'F')             // Encaminhado para fila
                             else
                                aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'F'))
                             endif
                          else
                             if llINS
                                aadd(laSAVE_AUX,'1')          // Não Notificado
                             else
                                aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'1'))
                             endif
                          endif
                       else
                          if llINS
                             aadd(laSAVE_AUX,'1')          // Não notificado
                          else
                             aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'1'))
                          endif
                       endif
                    case laFIELDS[jj] == 'DT_CONCLUSAO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          if laPART[ii,2] == '5'
                             aadd(laSAVE_AUX,date())
                          else
                             aadd(laSAVE_AUX,nil)
                          endif
                       endif
                    case laFIELDS[jj] == 'HR_CONCLUSAO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          if laPART[ii,2] == '5'
                             aadd(laSAVE_AUX,time())
                          else
                             aadd(laSAVE_AUX,nil)
                          endif
                       endif
                    case laFIELDS[jj] == 'PC_CONCLUIDO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          aadd(laSAVE_AUX,iif(!empty(laPART[ii,3]) .or. laPART[ii,3] != 0,laPART[ii,3],nil))  // **ALTERACAO APENAS** -> Percentual informado pelo usuário (grid detalhado)
                       endif
                    otherwise
                       aadd(laSAVE_AUX,nil)
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+' and LOGIN_PARTICIPANTE='+DLAP+lower(iif(llINS,laPART[ii],laPART[ii,1]))+DLAP)
             laSAVE_AUX := {}
         next ii
         if db_replace(laSAVE,'tc_participante',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif

         if !llINS  // ** ALTERAÇÃO APENAS **

            // Remove avisos relacionados a TC e atualiza tc_login_lembrete.FL_AVISO='S' para gerar novamento os avisos caso necessário
            if len(laTEMP) > 0
               wfremovealert({param_fetch(faPARAM,'NR_CONTROLE',2)},laTEMP)
            else
               wfremovealert({param_fetch(faPARAM,'NR_CONTROLE',2)})
            endif

            // Adiciona usuários extras informados no grid detalhado na manuntenção de TCs
            laTEMP := {}
            for ii := 1 to len(laPART)
                aadd(laTEMP,laPART[ii,1])
            next ii
            laPART := aclone(laTEMP)
            laTEMP := {}
         endif
      endif
   endif

   // Gravação de [tc_lembrete] e [tc_login_lembrete] -------------------------------------------------------------------------------------
   if param_pos(faPARAM,'LEMBRETES') > 0

      //Se for tarefa para fila, gera aviso para responsáveis e para o criador (LOGIN_AGENDADO)
      if lcTP_TC == 'T' .and. faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
         laPART := faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]
//         WOUT('<BR><B>faPARAM')
//         DEBUG2(faPARAM,,50)
         aadd(laPART,lower(faPARAM[param_pos(faPARAM,'LOGIN_AGENDADO'),2]))
      endif


//               {'LEMBRETES'     ,{{'D',10},{'D',10},{'H',10},{'M',30},{'D',20}}},;                  // Lembretes
      // Glauber 08/2012
      // Preparar o array corretamente, pois o parâmetro vem no formato string

      if valtype(faPARAM[param_pos(faPARAM,'LEMBRETES'),2]) == "C"
         laTEMP := Str2Array(faPARAM[param_pos(faPARAM,'LEMBRETES'),2],";")
// debug2(laTEMP,,30)
         laSWP := {}
         for ii := 1 to len(laTEMP)
             if ! empty(laTEMP[ii])
                aadd(laSWP,{substr(laTEMP[ii],1,1), val(substr(laTEMP[ii],2,len(laTEMP[ii])))})
             endif
         next ii
// debug2(laSWP,,30)
         laLEMBR := aclone(laSWP)
      else
          laLEMBR := faPARAM[param_pos(faPARAM,'LEMBRETES'),2]
      endif


      if len(laLEMBR) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_lembrete',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laLEMBR)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                       aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'TP_LEMBRETE'
                       aadd(laSAVE_AUX,laLEMBR[ii,1])
                    case laFIELDS[jj] == 'QTD_LEMBRETE'
                       aadd(laSAVE_AUX,laLEMBR[ii,2])
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+;
                          ' and TP_LEMBRETE='+DLAP+laLEMBR[ii,1]+DLAP+;
                          ' and QTD_LEMBRETE='+alltrim(str(laLEMBR[ii,2])))
             laSAVE_AUX := {}
         next ii

// debug2(laWHERE,,60)
         if db_replace(laSAVE,'tc_lembrete',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif

         // Gravação dos lembretes [tc_login_lembrete] ------------------------------------------------------------------------------------
         if len(laPART) > 0
            if (valtype(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]) == "C")
               laPART_ANT := Str2Array(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2],",")
            else
               laPART_ANT := faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]
            endif

            // Quando for implementar a validação dos parametros recebidos, este bloco deve ser removido deste ponto e inserido
            // juntamente com o restante das validações
            if lcTP_TC == 'T'
               if param_pos(faPARAM,'FL_DIAINTEIRO') > 0
                  if empty(alltrim(param_fetch(faPARAM,'FL_DIAINTEIRO')))
                     faPARAM[param_pos(faPARAM,'FL_DIAINTEIRO'),2] := 'S'
                  endif
               else
                 aadd(faPARAM,{'FL_DIAINTEIRO','N'})
               endif
            endif
            // ----------------------------------------------------------------------------------------------------------------------------

            if !llINS //Alteração - apaga os avisos não estiverem OK
               if db_delete('tc_login_lembrete','NR_CONTROLE='+alltrim(str(lnID))+' and DT_OK is NULL') == -1
                  error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
                  WSet('_PROJECT',lcPROJECT)
                  return(0)
               endif
            endif

            laSAVE     := {}
            laSAVE_AUX := {}
            laWHERE    := {}
            laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_login_lembrete',1,'N','workflow')
            aadd(laSAVE,laFIELDS)
            for ii := 1 to len(laPART)
                for iiL := 1 to len(laLEMBR)
                    for jj := 1 to len(laFIELDS)
                        do case
                           case laFIELDS[jj] == 'NR_CONTROLE'
                              aadd(laSAVE_AUX,lnID)
                           case laFIELDS[jj] == 'LOGIN_PARTICIPANTE'
                              aadd(laSAVE_AUX,lower(laPART[ii]))
                           case laFIELDS[jj] == 'DT_LEMBRETE'
                              lcDT_LEMBRETE := calc_lembrete(faPARAM,laLEMBR[iiL,1],laLEMBR[iiL,2],'D')
                              aadd(laSAVE_AUX,lcDT_LEMBRETE)
                           case laFIELDS[jj] == 'HR_LEMBRETE'
                              if param_fetch(faPARAM,'FL_DIAINTEIRO') == 'N' .or. empty(alltrim(param_fetch(faPARAM,'FL_DIAINTEIRO')))
                                 lcHR_LEMBRETE := calc_lembrete(faPARAM,laLEMBR[iiL,1],laLEMBR[iiL,2],'T')
                              else
                                 lcHR_LEMBRETE := '000000'
                              endif
                              aadd(laSAVE_AUX,lcHR_LEMBRETE)
                           case laFIELDS[jj] == 'FL_SENDSMS' .or. laFIELDS[jj] == 'FL_SENDEMAIL'
                              aadd(laSAVE_AUX,'N')
                           case laFIELDS[jj] == 'FL_FILA'
                              if lcTP_TC == 'T' .and. faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
                                 aadd(laSAVE_AUX,'S')
                              else
                                 aadd(laSAVE_AUX,nil)
                              endif
                           case laFIELDS[jj] == 'FL_AVISO'
                              aadd(laSAVE_AUX,'N')
                           case laFIELDS[jj] == 'DT_OK'
                              if llINS
                                 aadd(laSAVE_AUX,nil)
                              else
                                 if laPART_ANT[ii,2] == '5'     // Se o status for igual a 5-Concluído, grava DT_OK para não gerar avisos
                                    aadd(laSAVE_AUX,date())
                                 else
                                    aadd(laSAVE_AUX,nil)
                                 endif
                              endif
                           case laFIELDS[jj] == 'HR_OK'
                              if llINS
                                 aadd(laSAVE_AUX,nil)
                              else
                                 if laPART_ANT[ii,2] == '5'    // Se o status for igual a 5-Concluído, grava HR_OK para não gerar avisos
                                    aadd(laSAVE_AUX,time())
                                 else
                                    aadd(laSAVE_AUX,nil)
                                 endif
                              endif
                           otherwise
                              aadd(laSAVE_AUX,nil)
                        endcase
                    next jj
                    aadd(laSAVE,laSAVE_AUX)
                    aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+;
                                 ' and LOGIN_PARTICIPANTE='+DLAP+lower(laPART[ii])+DLAP+;
                                 ' and DT_LEMBRETE='+DLAP+lcDT_LEMBRETE+DLAP+;
                                 ' and HR_LEMBRETE='+DLAP+lcHR_LEMBRETE+DLAP)
                    laSAVE_AUX := {}
                next iiL
            next ii
            if db_replace(laSAVE,'tc_login_lembrete',laWHERE) == -1
               error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
               WSet('_PROJECT',lcPROJECT)
               return(0)
            endif
         endif
      endif
   endif

   // Gravação de [tc_responsavel] --------------------------------------------------------------------------------------------------------
   if param_pos(faPARAM,'RESPONSAVEIS') > 0
      if Valtype(faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]) == "C"
         laRESP := Str2Array(faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2],",")
      else
         laRESP := faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]
      endif
      if len(laRESP) > 0

         // Alteração - apaga todos os responsáveis e reinsere
         if lnID != 0
            if db_delete('tc_responsavel','NR_CONTROLE='+alltrim(str(lnID))) ==   -1
               error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
               WSet('_PROJECT',lcPROJECT)
               return(0)
            endif
         endif

         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_responsavel',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laRESP)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                         aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'LOGIN_RESPONSAVEL'
                         aadd(laSAVE_AUX,lower(laRESP[ii]))
                    case laFIELDS[jj] == 'FL_AVISO'
                         aadd(laSAVE_AUX,'N')
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+' and LOGIN_RESPONSAVEL='+DLAP+lower(laRESP[ii])+DLAP)
             laSAVE_AUX := {}
         next ii

         if db_replace(laSAVE,'tc_responsavel',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif
      endif
   endif

   // Gravação de [tc_reftc] --------------------------------------------------------------------------------------------------------------
   if !empty(param_fetch(faPARAM,'REFERENCIA')) .and. !empty(param_fetch(faPARAM,'REF_CHAVE'))
      laREF := str2array(param_fetch(faPARAM,'REF_CHAVE'),',')
      if len(laREF) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := {'CHAVE_TC','REF_CHAR','REF_NUM'}
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laREF)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'CHAVE_TC'
                         aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'REF_CHAR'
                         //? 'REF_CHAR Tipo:',valtype(laREF[ii]),'Conv:',alltrim(str(laREF[ii])),'Valor:',laREF[ii]

                         luTMP := laREF[ii]
                         if valtype(luTMP) == 'N'
                            luTMP := alltrim(str(luTEMP))
                         elseif valtype(luTMP) == 'D'
                            luTMP := dtoc(luTEMP)
                         endif
                         aadd(laSAVE_AUX,laREF[ii])
                    case laFIELDS[jj] == 'REF_NUM'
                         //? 'REF_NUM Tipo:',valtype(laREF[ii]),'Conv:',val(laREF[ii]),'Valor:',laREF[ii]

                         luTMP := laREF[ii]
                         if valtype(luTMP) == 'C'
                            luTMP := val(luTMP)
                         elseif valtype(luTMP) == 'D'
                            luTMP := 0
                         endif
                         aadd(laSAVE_AUX,luTMP)
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'CHAVE_TC='+alltrim(str(lnID)))
             laSAVE_AUX := {}
         next ii
         if db_replace(laSAVE,'tc_reftc',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif
      endif
   endif
   db_commit()

   if param_fetch(faPARAM,'FL_NOTIFICA') == 'S'
      laVINCULO := wfgetpersonal()
      if len(laVINCULO) > 0
         lcTBORIGN := db_fetchcolvalue(laVINCULO,'WTABLE_ORIGIN',2)
         laFIELDS  := {'acuser.LOGIN'}
         for ii := 1 to len(laVINCULO[1])
             if at(laVINCULO[1,ii],'NR_CONTROLE WTABLE_ORIGIN WFIELD_WFREL WFIELD_APPREL') == 0 .and. !empty(laVINCULO[2,ii])
                aadd(laFIELDS,lcTBORIGN+'.'+laVINCULO[2,ii])
             endif
         next ii
// debug2(faPARAM,,30)
         if len(laPART) > 0
// Glauber 08/2012 - Estava dando erro
/*
            if lcTP_TC == 'T'
               lcDT_INI := param_fetch(faPARAM,'DT_INICIO')
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := param_fetch(faPARAM,'DT_PRAZO')
               lcHR_END := param_fetch(faPARAM,'HR_PRAZO')
            else
               lcDT_INI := param_fetch(faPARAM,'DT_INICIO')
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := param_fetch(faPARAM,'DT_FIM')
               lcHR_END := param_fetch(faPARAM,'HR_FIM')
            endif
*/
            if lcTP_TC == 'T'
               lcDT_INI := dtos(param_fetch(faPARAM,'DT_INICIO'))
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := dtos(param_fetch(faPARAM,'DT_PRAZO'))
               lcHR_END := param_fetch(faPARAM,'HR_PRAZO')
            else
               lcDT_INI := dtos(param_fetch(faPARAM,'DT_INICIO'))
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := dtos(param_fetch(faPARAM,'DT_FIM'))
               lcHR_END := param_fetch(faPARAM,'HR_FIM')
            endif

            lcTITLE := iif(param_pos(faPARAM,'TITULO') > 0,param_fetch(faPARAM,'TITULO'),param_fetch(faPARAM,'TC_CATEGORIA'))

            // Selecionar o Sender --------------------------------------------------------------------------------------------------------
            if !empty(alltrim(WSet('LOGIN')))
               if db_select(laFIELDS,'acuser',;
                            {{2,lcTBORIGN,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WFREL',2)+'='+;
                                          'acuser.'+db_fetchcolvalue(laVINCULO,'WFIELD_APPREL',2)}},;
                            {'acuser.WUID='+alltrim(str(WSet('WUID')))}) == -1
                  error_sys('wfmktc: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laSENDER := db_fetchall()
            else
               laTEMP  := {}
               laTEMP1 := {}
               for ii := 1 to len(laFIELDS)
                   aadd(laTEMP,substr(laFIELDS[ii],at('.',laFIELDS[ii])+1))
                   aadd(laTEMP1,'')
               next
               aadd(laSENDER,laTEMP)  //Nomes dos campos
               aadd(laSENDER,laTEMP1) //Conteúdo dos campos

               lcRETURN_PATH := alltrim(param_fetch(faPARAM,'EMAIL_SENDER'))
               if empty(lcRETURN_PATH)
                  lcRETURN_PATH := 'suporte@inso.com.br'
               endif

               laSENDER[2,ascan(laFIELDS,'acuser.LOGIN')]                                                 := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WUSER',2))]     := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2))]    := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2))]     := lcRETURN_PATH
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2))]       := '0'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2))] := '0'
            endif

            // Tratamento e seleção dos Participantes -------------------------------------------------------------------------------------
            laTEMP := {}
            for ii := 1 to len(laPART)
                if at('@',laPART[ii]) > 0
                   aadd(laEMAILS_DIV,laPART[ii])  // Emails diversos/avulsos
                else
                   aadd(laTEMP,lower(laPART[ii]))        // Logins de usuários
                endif
            next ii
            laPART := aclone(laTEMP)

            if len(laPART) > 0  // Seleciona dados dos destinatários apenas se o usuário os informou
               if db_select(laFIELDS,'acuser',;
                            {{2,lcTBORIGN,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WFREL',2)+'='+;
                                'acuser.'+db_fetchcolvalue(laVINCULO,'WFIELD_APPREL',2)}},;
                            {'acuser.LOGIN in ('+DLAP+lower(array2str(laPART,DLAP+','+DLAP))+DLAP+')'}) == -1
                  error_sys('wfmktc: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laSEND_TO := db_fetchall()
            endif

            // Notificação via email para participantes -----------------------------------------------------------------------------------
            if param_fetch(faPARAM,'FL_EMAILPART') == 'S'
               lcMSG := 'Início: '+right(lcDT_INI,2)+'/'+substr(lcDT_INI,5,2)+'/'+left(lcDT_INI,4)+' '+lcHR_INI+CRLF
               if lcTP_TC == 'T'
                  lcMSG += 'Prazo: '
               else
                  lcMSG += 'Término: '
               endif
               lcMSG += right(lcDT_END,2)+'/'+substr(lcDT_END,5,2)+'/'+left(lcDT_END,4)+' '+lcHR_END+CRLF
               lcMSG += param_fetch(faPARAM,'NM_TC')
               if len(laSEND_TO) > 1
                  for ii := 2 to len(laSEND_TO)
                      writelog('Email Interno: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'LOGIN',2),2)+;
                               ' <'+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2)+'>')
                      writelog('Email Interno: To.....: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii))
                      writelog('Email Interno: Subject: '+lcTITLE)
                      writelog('Email Interno: Body...: '+lcMSG)

                      if !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii))
                         wsendmail(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2),;   //Remetente
                                   db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii),; //Detinatário
                                   ,;                                                                            //CC
                                   ,;                                                                            //BCC
                                   lcTITLE,;                                                                     //Assunto
                                   lcMSG,;                                                                       //Corpo da mensagem
                                   'Agenda Isj')                                                                 //Nome do remetente
                      else
                         lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui email cadastrado!'
                         puterror(lcMSG_ERRO)
                         writelog(lcMSG_ERRO)
                      endif
                  next ii
               else
                  lcMSG_ERRO := 'Email: Usuários do sistema não encontrados ou não informados'
                  puterror(lcMSG_ERRO)
                  writelog(lcMSG_ERRO)
               endif

               // Envio de avisos aos emails informados diretamente na lista de participantes ------------------------------------------
               if len(laEMAILS_DIV) > 0
                  for ii := 1 to len(laEMAILS_DIV)

                      writelog('Email Externo: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'LOGIN',2),2)+;
                               ' <'+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2)+'>')
                      writelog('Email Externo: To.....: '+laEMAILS_DIV[ii])
                      writelog('Email Externo: Subject: '+lcTITLE)
                      writelog('Email Externo: Body...: '+lcMSG)

                      wsendmail(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2),; //Remetente
                                laEMAILS_DIV[ii],;                                                          //Detinatário
                                ,;                                                                          //CC
                                ,;                                                                          //BCC
                                lcTITLE,;                                                                   //Assunto
                                lcMSG,;                                                                     //Corpo da mensagem
                                'Agenda Isj')                                                               //Nome do remetente

                  next ii
               endif
            endif

            // Notificação via sms para participantes ----------------------------------------------------------------------------------------
            if param_fetch(faPARAM,'FL_SMSPART') == 'S'
               if len(laSEND_TO) > 1
                  lcMSG := right(lcDT_INI,2)+'/'+substr(lcDT_INI,5,2)+'/'+left(lcDT_INI,4)+' '+lcHR_INI+CRLF+;
                           param_fetch(faPARAM,'NM_TC')
                  for ii := 2 to len(laSEND_TO)

                      writelog('SMS: Device.: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii))
                      writelog('SMS: Nr.....: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))
                      writelog('SMS: Subject: '+lcTITLE)
                      writelog('SMS: Body...: '+lcMSG)
                      writelog('SMS: Alias..: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2),2))
                      writelog('SMS: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2))

                      if !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii)) .and.;
                         !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))

                         lcALIAS := alltrim(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2),2))
                         wsendsms(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii),; //Tipo de dispositivo
                                  db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii),;       //Cód do dispositivo
                                  lcTITLE,;                                                                         //Assunto
                                  lcMSG,;                                                                           //Mensagem
                                  'ISJ'+iif(!empty(lcALIAS),'-'+lcALIAS,'ISJ'),;                                    //Apelido do sender
                                  db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2))        //Email do sender
                      else
                         if empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))           //Sem nr do celular cadastrado
                            lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui SMS cadastrado!'
                            puterror(lcMSG_ERRO)
                            writelog(lcMSG_ERRO)
                         elseif empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii)) //Sem tipo de dispositivo cadastrado
                            lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui tipo de Dispositvo cadastrado!'
                            puterror(lcMSG_ERRO)
                            writelog(lcMSG_ERRO)
                         endif
                      endif
                  next ii
               else
                  lcMSG_ERRO := 'SMS: Usuários do sistema não encontrados ou não informados'
                  puterror(lcMSG_ERRO)
                  writelog(lcMSG_ERRO)
               endif
            endif
         endif
      endif
   endif
   WSet('_PROJECT',lcPROJECT)
return(lnID)

/*
* Function..: calc_lembrete(faPARAM,fcTYPE_LEMBR,fnQTD_LEMBR,fcTYPE_RET)
* Objetivo..: Calcular lembretes
* Parâmetros:
*   faPARAM......: Matriz bidimensional. Formato obrigatório abaixo:
*      {{'PARAM1',VAL_PARAM1},;
*       {'PARAM2',VAL_PARAM2},;
*       {'PARAM3',VAL_PARAM3},;
*       {'PARAM4',VAL_PARAM4},;
*       {' ...  ',   ...    },;
*       {'PARAMn',VAL_PARAMn}}
*
*      Onde:
*        Col 1 - Nome do parâmetro
*        Col 2 - Valor do parâmetro
*    fcTYPE_LEMBR: Tipo de lembrete. [T]-Tarefa [C]-Compromisso
*    fnQTD_LEMBR.: Quantidade de dias/horas/minutos para o lembrete
*    fcTYPE_LEMBR: Tipo de retorno. [D]-Date [T]-Time

* Retorno:
*   Se fcTYPE_LEMBR = T (Time) retorna Hora
*   Se fcTYPE_LEMBR = D (Date) retorna Data
*/
Static function calc_lembrete(faPARAM,fcTYPE_LEMBR,fnQTD_LEMBR,fcTYPE_RET)
   local lcTSTP   := '' ,;
         lcHORA   := '' ,;
         lcRETURN := '' as string

   if faPARAM[param_pos(faPARAM,'TP_TC'),2] == 'T'
      if faPARAM[param_pos(faPARAM,'FL_DIAINTEIRO'),2] == 'S'
         lcHORA := '000000'
      else
         lcHORA := char_rem(':',faPARAM[param_pos(faPARAM,'HR_PRAZO'),2])
      endif
      // Glauber 08/2012 - Erro na adição de data
      if valtype(faPARAM[param_pos(faPARAM,'DT_PRAZO'),2]) == "D"
         lcTSTP := dtos(faPARAM[param_pos(faPARAM,'DT_PRAZO'),2])+substr(lcHORA,1,2)+substr(lcHORA,3,2)+'00'
      else
         lcTSTP := faPARAM[param_pos(faPARAM,'DT_PRAZO'),2]+substr(lcHORA,1,2)+substr(lcHORA,3,2)+'00'
      endif
   elseif faPARAM[param_pos(faPARAM,'TP_TC'),2] == 'C'
      lcHORA := char_rem(':',faPARAM[param_pos(faPARAM,'HR_INICIO'),2])
      if valtype(faPARAM[param_pos(faPARAM,'DT_INICIO'),2]) == "D"
         lcTSTP := dtos(faPARAM[param_pos(faPARAM,'DT_INICIO'),2])+substr(lcHORA,1,2)+substr(lcHORA,3,2)+'00'
      else
         lcTSTP := faPARAM[param_pos(faPARAM,'DT_INICIO'),2]+substr(lcHORA,1,2)+substr(lcHORA,3,2)+'00'
      endif
   endif

   if fcTYPE_LEMBR == 'D'
      lcTSTP := calcTSTP(lcTSTP, -(fnQTD_LEMBR*86400)) //Converte dias em segundos
   elseif fcTYPE_LEMBR == 'H'
      lcTSTP := calcTSTP(lcTSTP, -(fnQTD_LEMBR*3600))  //Converte horas em segundos
   elseif fcTYPE_LEMBR == 'M'
      lcTSTP := calcTSTP(lcTSTP, -(fnQTD_LEMBR*60))    //Converte minutos em segundos
   endif

   if fcTYPE_RET == 'D'
      lcRETURN := substr(lcTSTP,1,8) //Retorno data ANSI YYYYMMDD
   else
      lcRETURN := substr(lcTSTP,9)   //Retorno hora HHMM
   endif
return(lcRETURN)

/*
* Function..: param_pos(faARRAY,fcPARAM)
* Objetivo..: Procurar a posição (linha) de um valor em uma matriz bidimensional
* Parâmetros:
*    faARRAY.: Matriz bidimensional. Formato obrigatório abaixo:
*      {{'PARAM1',VAL_PARAM1},;
*       {'PARAM2',VAL_PARAM2},;
*       {'PARAM3',VAL_PARAM3},;
*       {'PARAM4',VAL_PARAM4},;
*       {' ...  ',   ...    },;
*       {'PARAMn',VAL_PARAMn}}
*
*      Onde:
*        Col 1 - Nome do parâmetro
*        Col 2 - Valor do parâmetro
*
*    fcPARAM.: Parametro a procurar
* Retorno:
*   Retorna a linha em que o item foi encontrado
*/
Static function param_pos(faARRAY,fcPARAM)
return(ascan(faARRAY,{|laFIND| alltrim(upper(laFIND[1]))==alltrim(upper(fcPARAM))}))

/*
* Function..: param_fetch(faARRAY,fcPARAM)
* Objetivo..: Procurar a posição (linha) de um valor em uma matriz bidimensional
* Parâmetros:
*    faARRAY.: Matriz bidimensional. Formato obrigatório abaixo:
*      {{'PARAM1',VAL_PARAM1},;
*       {'PARAM2',VAL_PARAM2},;
*       {'PARAM3',VAL_PARAM3},;
*       {'PARAM4',VAL_PARAM4},;
*       {' ...  ',   ...    },;
*       {'PARAMn',VAL_PARAMn}}
*
*      Onde:
*        Col 1 - Nome do parâmetro
*        Col 2 - Valor do parâmetro
*
*    fcVALUE.: Valor a procurar
* Retorno:
*   Retorna o valor do parâetro
*/
Static function param_fetch(faARRAY,fcPARAM)
  local luVALUE :=  nil

  luVALUE := param_pos(faARRAY,fcPARAM)
  if luVALUE > 0
     luVALUE := faARRAY[luVALUE,2]
  else
     luVALUE := ''
     puterror('param_fetch: Parâmetro não encontrado -> '+fcPARAM)
  endif
return(luVALUE)



/*
* Data de Criação: 08/2012k- Glauber
* Observação: Nova funcionalidade workflow
* Function: ConcluirTAuto()
* Objetivo: Concluir do portal do usuário uma tarefa ou compromisso automaticamente.
*
* Parâmetros:
*  pNR_PASTA       Número da pasta
*  pTP_ANDAMENTO   Tipo de andamento
*  pTP_DOCUMENTO   Tipo de documento Ged
*
* Retorno: nenhum
*
*/

function ConcluirTAuto(pNR_PASTA, pTP_ANDAMENTO, pTP_DOCUMENTO)

    local laRES          := {} as Array
    local lcFIELD        := '',;
          lcWHERE        := '',;
          lcPROJECT      := '' as String
    local ii             := 0 as int


    if (pNR_PASTA == 0)
        puterror("ConcluirTAuto: número de pasta inválido.")
        return
    endif
    if  empty(pTP_ANDAMENTO) .and. empty(pTP_DOCUMENTO)
        puterror("ConcluirTAuto: tipo de andamento e tipo de documento da pasta " + alltrim(pNR_PASTA)+" inválido.")
        return
    endif

    lcPROJECT := WSet('_PROJECT')
    WSet('_PROJECT','workflow')

    if (! empty(pTP_ANDAMENTO))
       lcFIELD  := "tarefa_compromisso.BAIXA_TP_ANDAMENTO"
       lcWHERE := "tarefa_compromisso.REFERENCIA='pasta' AND tarefa_compromisso.REF_CHAVE = '" + alltrim(str(pNR_PASTA)) + "' AND " +lcFIELD + " LIKE '%" + pTP_ANDAMENTO + "%'"
    endif
    if (! empty(pTP_DOCUMENTO))
       lcFIELD  := "tarefa_compromisso.BAIXA_TP_DOCUMENTO"
       lcWHERE := "tarefa_compromisso.REFERENCIA='pasta' AND tarefa_compromisso.REF_CHAVE = '" + alltrim(str(pNR_PASTA)) + "' AND " +lcFIELD + " LIKE '%" + pTP_DOCUMENTO + "%'"
    endif

    if db_select({'NR_CONTROLE'},'tarefa_compromisso',,{lcWHERE}) == -1
       error_sys(db_error())
    endif
    laRES := db_fetchall()
//wout('Wget:'+Wget('TP_ANDAMENTO'))
//wout('Where:' + lcWHERE)
//debug2(laRES,,20)
    laSWP := {}
    for ii := 2 to len(laRES)
        aadd(laSWP,str(laRES[ii,1]))
    next ii
// debug2(laSWP,,20)
    if len(laRES)>1
       BaixarTarefa(laSWP, .T.) // função presente no programa jsongridcomp.html
    endif
    WSet('_PROJECT',lcPROJECT)

return





/******* Glauber 27/02/2014 ==> Implementação da geração de documentos versão Linux ********/




/*
* Data de Criação:  Glauber
* Observação: Funcionalidade Aba Geração Automatica de Documentos
* Function: GetCabecDocX()
* Objetivo: Retornar o cabeçalho xml necessário para geração do arquivo.
*
* Parâmetros:
*
*
* Retorno: string com o cabeçalho.
*
*/

   Function GetCabecDocX()

   local lcCabec := '<?xml version="1.0" encoding="ISO-8859-1"?> ' +chr(13) +;
                    '<DOCUMENTO>' + chr(13)
   return(lcCabec)

/*
* Data de Criação:  Glauber
* Observação: Funcionalidade Aba Geração Automatica de Documentos
* Function: GetRodapeDocX()
* Objetivo: Retornar o rodape xml necessário para geração do arquivo.
*
* Parâmetros:
*
*
* Retorno: string com o rodape.
*
*/

   Function GetRodapeDocX()

   return("</DOCUMENTO>")


/*
* Data de Criação:  Glauber
* Observação: Funcionalidade Aba Geração Automatica de Documentos
* Function: Res2DocxFields()
* Objetivo: Retornar o string xml com as tags Campo, necessário para geração do arquivo.
*
* Parâmetros:
*  paRES           Array no formato laRESULT
*  plLabels        Se verdadeiro converte o nome tecnico dos campos em paRES[1] para o conteúdo do label cadastrado.
*
* Retorno: string xml com as tags Campo
*
*/

   Function Res2DocxFields(paRES, plLabels)

   local lnIdentCampo := 3,;
         lnIdentNome  := 5,;
         lnii         := 0 as int
   local lcRet        := '' as String
   if len(paRES) < 2
      error_sys("Res2DocxFields: tamanho do array inválido, esperado 2, recebido "+alltrim(len(paRES)))
   endif

   if plLabels
      for ii := 1 to len(paRES[1])
          paRES[ii] := lblfscreen(paRES[1])
      next ii
   endif

   aadd(paRES[1],'DIA_ATUAL')
   aadd(paRES[1],'MES_ATUAL')
   aadd(paRES[1],'ANO_ATUAL')
   aadd(paRES[1],'MES_ATUAL_EXTENSO')
   aadd(paRES[1],'HORA_ATUAL')

   aadd(paRES[2],alltrim(day(date())))
   aadd(paRES[2],alltrim(month(date())))
   aadd(paRES[2],alltrim(year(date())))
   aadd(paRES[2],MesExtenso(month(date())))
   aadd(paRES[2],time())


   for ii := 1 to len(paRES[1])
       lcRet += space(lnIdentCampo) + '<Campo>' + chr(13)
       lcRet += space(lnIdentNome) + '<Nome>' + DocxAcento(alltrim(paRES[1,ii])) + '</Nome>' + chr(13)
       lcRet += space(lnIdentNome) + '<Valor>' + DocxAcento(alltrim(paRES[2,ii])) + '</Valor>' + chr(13)
       lcRet += space(lnIdentCampo) + '</Campo>' + chr(13)
   next ii

   return lcRet



/*
* Data de Criação:  Glauber
* Observação: Funcionalidade Aba Geração Automatica de Documentos
* Function: MesExtenso()
* Objetivo: Retornar o nome do mês.
*
* Parâmetros:
*  pnMES       Numero do mês.
*
* Retorno: Nome do Mês
*
*/

Function MesExtenso(pnMES)

    local laMES := {'Janeiro',;
                    'Fevereiro',;
                    'Março',;
                    'Abril',;
                    'Maio',;
                    'Junho',;
                    'Julho',;
                    'Agosto',;
                    'Setembro',;
                    'Outubro',;
                    'Novembro',;
                    'Dezembro'} as Array

   if (pnMES >= 1 .and. pnMES <= 12)
      return laMES[pnMES]
   endif

return


/*
* Data de Criação:  Glauber
* Observação: Funcionalidade Aba Geração Automatica de Documentos
* Function: Grid2DocxTable()
* Objetivo: Retornar o string xml com as tags Campo, necessário para geração do arquivo.
*
* Parâmetros:
*  pcGrid          Nome da Grid que deverá aparecer na tag TabelaNome, exemplo: PEDIDOS, ANDAMENTOS.
*  paRES           Array no formato laRESULT
*
* Retorno: string xml com as tags Tabela
*
*/

   Function Grid2DocxTable(pcGrid, paRES)

   local lcRet        := '' as String
   local lnQtdMax     := 10,;
         ii           := 0,;
         lnIdentNome  := 3,;
         lnIdentCampo := 5,;
         xx           := 0,;
         zz           := 0 as int

   if len(paRES) < 2
      error_sys("Grid2DocxTable: tamanho do array inválido, esperado 2, recebido "+alltrim(len(paRES)))
   endif
//   if len(paRES[1]) > lnQtdMax
//      error_sys("Grid2DocxTable: tamanho do array inválido, esperado " +alltrim(lnQtdMax)+", recebido "+alltrim(len(paRES[1])))
//   endif
   if empty(alltrim(pcGrid))
      error_sys("Grid2DocxTable: Nome da grid não foi informado. ")
   endif


   lcRet += space(lnIdentNome) + "<Tabela>" + chr(13)
   lcRet += space(lnIdentCampo) + "<TabelaNome>"+alltrim(pcGrid)+"</TabelaNome>" + chr(13)
   lcRet += space(lnIdentCampo) + "<TabelaCabecalho>" + chr(13)

   for ii := 1 to lnQtdMax
       lcRet += "COLUNA" + alltrim(ii)
       if ii < lnQtdMAx
          lcRet += ","
       endif
   next ii
   lcRet += space(lnIdentCampo) + "</TabelaCabecalho>" + chr(13)

   for ii := 2 to len(paRES)
       lcRet += space(lnIdentCampo) + "<TabelaValor>"
       for xx := 1 to len(paRES[1])
           lcRet += DocxAcento(alltrim(paRES[ii,xx]))
           if xx < len(paRES[1])
              lcRet += "#" // Separador de coluna
           endif
           // Caso o array não contenha a quantidade de elementos obrigatório, é gerado o conteúdo vazio automaticamente.
           if len(paRES[1]) < lnQtdMax
              for zz := (len(paRES[1])+1) to lnQtdMax
                  lcRet += "#"
              next zz
           endif
           lcRet += "@" // Indicador de final de linha
       next xx
       lcRet += space(lnIdentCampo) + "</TabelaValor>" +chr(13)
   next ii

   return lcRet


/*
*
* Autor.....: Glauber Duma - 06/03/2014
* Function..: DocxAcento(pcConteudo)
* Objetivo..: Faz o tratamento da string, removendo os caracteres acentuados que gera erro no consumo do webservice.
* Parâmetros:
*   pcConteudo: Conteúdo a ser tratado.
*
* Retorno:
*               String tratada.
*/

function DocxAcento(pcConteudo)

    pcConteudo := strtran(pcConteudo,'&','&amp;')
    pcConteudo := strtran(pcConteudo,'%','&porc;')

return pcConteudo


/*
*
* Autor.....: Glauber Duma
* Function..: ForceJSDownload(pcArquivo)
* Objetivo..: Forçar o download de um arquivo via javascript
* Parâmetros:
*   pcArquivo..: Nome do arquivo a ser baixado a partir do diretório raiz do Isj.
*                Exemplo: teste.xml ou /tmp/teste.xml
* Retorno:
*               Nenhum
*/

Function ForceJSDownload(pcArquivo)

    local lcURL     := '',;
          lcJSCRIPT := '' as String
      WSet('_WDEBUG','DISABLE')
      lcURL := strtran(GetUrl(),'gr5','') + pcArquivo
      lcJSCRIPT := '<script type="text/javascript">' + LF
      lcJSCRIPT += '   window.location.href = "' + lcURL + '"' + LF
      lcJSCRIPT += '</script>' + LF
      wout(lcJSCRIPT)

return


function obrilabel(fcROW)
   local lnPOS := 0 ,;
         lnPOS2 := 0 ,;
         lnASC := 0 ,;
         ii    := 0  as int
   local lcVALUE := '' ,;
         lcFIELD := '' ,;
         lcROWUPPER := '' as string

   lcROWUPPER := upper(fcROW)
   lnPOS := at('OBRILABEL.',lcROWUPPER)

   lnPOS2 := 0
   do while lnPOS > 0
      for ii := lnPOS+10 to len(fcROW)
         lnASC := asc(substr(lcROWUPPER,ii,1))
         if (lnASC < 65 .or. lnASC > 90) .and. (lnASC < 48 .or. lnASC > 57) .and. lnASC != 46 .and. lnASC != 95
            lnPOS2 := ii
            exit
         endif
      next ii
      if lnPOS2 = 0
         lnPOS2 := len(fcROW)
      endif

      lcVALUE := obrifieldtag(substr(lcROWUPPER,lnPOS+9,lnPOS2-(lnPOS+9))+".LABEL")

      fcROW := stuff(fcROW,;
              lnPOS,;
              lnPOS2-lnPOS,;
              lcVALUE)

      lcROWUPPER := upper(fcROW)

      if at(LF,lcVALUE) > 0  // verifica se lcVALUE tem mais de uma linha
         lnPOS := at('OBRILABEL.',lcROWUPPER,lnPOS+len(lcVALUE))
      else
         lnPOS := at('OBRILABEL.',lcROWUPPER)
      endif

      lnPOS2 := 0
   enddo
return(fcROW)

// constroi a tag html
function obrifieldtag(fcFIELD)
   local lcTAG   := '' as string
   local faFIELD := {} as array

   local lcVALUE := '' ,;
         lcSTYLE := '' ,;
         lcCLASS := '' ,;
         lnFIELDSIZE := '' ,;
         lnGETSIZE := ''  ,;
         lcALIGN := ''    ,;
         lcPICTURE := ''  ,;
         lcHINT := ''     ,;
         lcREADONLY := '' ,;
         lcDISABLE := ''  ,;
         lcUNAVAILABLE := '' as string

   local laOPTION := {} ,;
         laOPTIONVALUE := {} as array

   local lbHELPONLINE := .f.

   faFIELD := str2array(fcFIELD,".")
   if len(faFIELD) > 1
      if upper(faFIELD[2]) = 'LABEL'
         lbHELPONLINE := .t.
         lcVALUE := lblfscreen(faFIELD[1])
      endif
   endif

   if WSet('HELPONLINE') = 'DISABLE'
      lbHELPONLINE := .f.
   endif

   if attribtag(fcFIELD,@lcVALUE,@lcSTYLE,@lcCLASS,@lnFIELDSIZE,@lnGETSIZE,@lcALIGN,@laOPTION,@laOPTIONVALUE,@lcPICTURE,@lcHINT,@lcREADONLY,@lcDISABLE,@lcUNAVAILABLE) = 0
      if empty(lcVALUE)
         puterror('TAG empty: '+fcFIELD)

         return(fcFIELD)
      endif
   endif

   if lcUNAVAILABLE == 'Y'
      return('') // "some" com o conteúdo
   endif

   if ! empty(lcALIGN)
      lcTAG += '<div align="'+lcALIGN+'">'
   endif

   if ! empty(lnFIELDSIZE)
      lcVALUE := substr(lcVALUE,1,val(lnFIELDSIZE))
   endif

   if !empty(lcPICTURE)
      lcVALUE := transform(lcVALUE,lcPICTURE)
   endif

   if !empty(lcSTYLE) .or. !empty(lcCLASS) .or. !empty(lcHINT) .or. lbHELPONLINE
      if lbHELPONLINE
         lcSTYLE += 'cursor:help;'
      endif
      lcTAG += '<span'

      *if !empty(lcCLASS)
      *   lcTAG += ' class="'+lcCLASS+'"'
      *endif

      if lbHELPONLINE
         lcTAG += ' class="winputobriga"'
      endif

      if !empty(lcSTYLE)
         lcTAG += ' style="'+lcSTYLE+'"'
      endif
      if !empty(lcHINT)
         lcTAG += ' title="'+lcHINT+'"'
      endif

     // Help Online
      if lbHELPONLINE
         lcTAG += ' onclick="HelpOnlineLayer('+DLAP+faFIELD[1]+DLAP+',event)"'
      endif

      lcTAG += '>'
      lcTAG += lcVALUE
      lcTAG += '</span>'
   else
      lcTAG += lcVALUE
   endif

   if ! empty(lcALIGN)
      lcTAG += '</div>'
   endif
return(lcTAG)

/*
* Glauber - 03/2014
*
* Function..: NovaGrid(<faCOLUMNS>,<faVIEW>,<flZEBRADO>,<fcCOR1>,<fcCOR2>,<flTRACEJADO>,<fcCORTRACEJADO>,<faTABLECFG>)
* Objetivo..: Construir grids de selecao
* Parâmetros:
*    faCOLUMNS: matriz contendo o resultado de um db_select()/db_fetchall()
*       Formato:
*       {{CAMPO1,CAMPO2,...,CAMPOn}
*        {Valor1.1,Valor2.1,...,ValorN.M}
*        {Valor1.2,Valor2.2,...,ValorN.M}
*        {...}
*        {Valor1.N,Valor2.N,...,Valorn.M}}
*
*    faVIEW: campo que serão visualizado na grid.
*       Formato:
*       {CAMPO1,CAMPO2,...,CAMPOn}
*    flZEBRADO: Indica se a grid será zebrada
*       Formato:
*       .t. ou .f.
*    fcCOR1: Cor das linhas impares.
*       Formato:
*       #ffffff
*    fcCOR2: Cor das linhas pares.
*       Formato:
*       #ffffff
*    flTRACEJADO: Indica se a grid deve conter uma linha tracejada abaixo de cada linha de informação.
*       Formato:
*       .t. ou .f.
*    fcCORTRACEJADO: Cor da linha tracejada.
*       Formato:
*       #ffffff
*    faTABLECFG: Array com a configuração da tabela
*       Formato:
*       {{WITH,BORDER,CELLSPACING,CELLPADDING, ALIGN}
*        {96%,0,1,0,center}
*
* Retorno...:
*
*    HTML gerado de acordo com faVIEW
*
*/

function NovaGrid(faCOLUMNS,faVIEW, flZEBRADO, fcCOR1, fcCOR2, flTRACEJADO, fcCORTRACEJADO, faTABLECFG, pcTABLENAME)

  local lcHTML  := '',;
        lcLINK  := '',;
        lcTMP   := '',;
        lcALIGN := "center",;
        CR      := chr(13)  as string
  local ii    := 0 ,;
        jj    := 0 ,;
        lnPOS := 0 ,;
        lnPOSCOR_LINK := 0,;
        lnPOSLINK := 0 as int
  local llJAVA := .F. as logical
  local llSHOWHEADER := .T. as logical
  local laREDEF := {} as Array



  if faCOLUMNS == NIL
     error_sys('NovaGrid: ('+alltrim(str(procline()))+') - parâmetro faCOLUMNS não definido')
  endif
  if faVIEW == NIL
     error_sys('NovaGrid: ('+alltrim(str(procline()))+') - parâmetro faVIEW não definido')
  endif

  if flZEBRADO == NIL
     flZEBRADO := .F.
  endif

  if flTRACEJADO == NIL
     flTRACEJADO := .F.
  endif

  if fcCORTRACEJADO == NIL
     fcCORTRACEJADO := "#8EBECE"
  endif

  if faTABLECFG == NIL
     faTABLECFG := {{'WITH','BORDER','CELLSPACING','CELLPADDING','ALIGN'},;
                    {'96%','0','1','0','center'}}
  endif

  if ascan(faTABLECFG[1],'SHOWHEADER') > 0
     llSHOWHEADER := faTABLECFG[2,ascan(faTABLECFG[1],'SHOWHEADER')]
  endif


  // Glauber 04/04/2013 - Implementar a consulta de renomeação de campos por tipo de pasta

//WDataGlobal('_FIELDREDEF_'+laRESULT[lnindRES,1],'N|&'+laRESULT[lnindRES,2]+'|&'+laRESULT[lnindRES,5]+'|&N|&'+laRESULT[lnindRES,6]+'|&|&'+laRESULT[lnindRES,7]+'|&'+laRESULT[lnindRES,8])
//  Campo:HORAS_TRABALHADAS
//.: Inicio Function Debug(Var) Ver. 2 :.
//N|& |& |&N|& |&|& |&                     |
//.: Fim Function Debug(Var) Ver. 2 :.

//Campo:DOCUMENTO
//.: Inicio Function Debug(Var) Ver. 2 :.
//S|&Documento|&|&S|&|&|&|&                |

if llSHOWHEADER
  for ii := 1 to len(faVIEW)

      laREDEF := Str2Array(WDataGlobal('_FIELDREDEF_'+faVIEW[ii]),'|')
      if len(laREDEF) > 0
         // Verificar se o campo esta oculto, remover da grid
         if (laREDEF[1] == 'N')
            adel(faVIEW,ii)
            asize(faVIEW, len(faVIEW)-1)

         endif
         // Pega o conteúdo da label de redef e coloca no título
         if (laREDEF[1] == 'S')
            lcTMP := alltrim(strtran(laREDEF[2],'&',''))
            if len(lcTMP) > 0
               lnPOS := ascan(faCOLUMNS[1],faVIEW[ii])
               if lnPOS > 0 .and. lcTMP != lblfscreen(faCOLUMNS[1,lnPOS])
                  faCOLUMNS[1,lnPOS] := '[' + lcTMP + ']'
                  faVIEW[ii]         := '[' + lcTMP + ']'
               endif
            endif
         endif
      endif

  next ii
endif

  if len(faCOLUMNS) > 0
     // lcHTML += '<table width="96%" border="0" cellspacing="1" cellpadding="0" align="center">'+CR
     if llSHOWHEADER
         if (pcTABLENAME == NIL)
            lcHTML += '<table width="' +faTABLECFG[2,1]+  '" border="'+faTABLECFG[2,2]+'0" cellspacing="'+faTABLECFG[2,3]+'" cellpadding="'+faTABLECFG[2,4]+ '" align="'+faTABLECFG[2,5]+'">'+CR
         else
            lcHTML += '<table width="' +faTABLECFG[2,1]+  '" border="'+faTABLECFG[2,2]+'0" cellspacing="'+faTABLECFG[2,3]+'" cellpadding="'+faTABLECFG[2,4]+  'name="' + alltrim(pcTABLENAME) +'" id="'+ alltrim(pcTABLENAME) +'" align="'+faTABLECFG[2,5]+'">'+CR
         endif
     endif
     lnPOS := ascan(faCOLUMNS[1],'(row)')
     lnPOSCOR_LINK := ascan(faCOLUMNS[1],'COR_LINK')
     lnPOSLINK := ascan(faCOLUMNS[1],'(link)')

     //Abre a TABLE principal
     if llSHOWHEADER
         lcHTML += '<div align="center" class="fundo_tabelas">'+CR
         //lcHTML += '<table align="left" border="0" width="100%" cellspacing="1" cellpadding="2" '
         lcHTML += '<table align="center" border="0" width="96%" cellspacing="1" cellpadding="2" '
         lcHTML += ' class="aba_azul_pq" name="wgrid" id="wgrid">'+CR
         //Abre a TR para o titulo das colunas
         lcHTML += '<thead>'+CR
         lcHTML += '<tr>'+CR

         //Criação do cabecalho da TABLE - Títulos
         for ii := 1 to len(faCOLUMNS[1])
             //Ignora a coluna (row) evitando a criacao de colunas vazias
             if (ii != lnPOS) .and. (ii != lnPOSCOR_LINK) .and. ( ascan(faVIEW,faCOLUMNS[1,ii]) > 0 )
                lcHTML += '    <td class="wgridheader" >'+CR
                if at('[',faCOLUMNS[1,ii]) > 0       //Titulo para coluna link
                   lcHTML += substr(faCOLUMNS[1,ii],at('[',faCOLUMNS[1,ii])+1,at(']',faCOLUMNS[1,ii])-2)
                else
                   lcHTML += lblfscreen(faCOLUMNS[1,ii])+CR
                endif
                lcHTML += '</td>'+CR
             endif
         next ii

         //Fecha TR do o titulo das colunas
         lcHTML += '</tr>'+CR
         lcHTML += '</thead>'+CR
         lcHTML += '<tbody>'+CR // Inicia TBODY
     endif
     for ii := 2 to len(faCOLUMNS)

         if lnPOSLINK > 0
            //lcLINK := '<a href='+ DLAP + substr(faCOLUMNS[ii,lnPOSLINK],7,len(faCOLUMNS[ii,lnPOSLINK])) + DLAP  + '>'+'{0}'+'</a>'
            if (lnPOSCOR_LINK > 0)
                lcLINK := '<a href='+ DLAP + substr(faCOLUMNS[ii,lnPOSLINK],7,len(faCOLUMNS[ii,lnPOSLINK])) + DLAP  + '>'+'<font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+'{0}'+'</a> </font>'
            else
                lcLINK := '<a href='+ DLAP + substr(faCOLUMNS[ii,lnPOSLINK],7,len(faCOLUMNS[ii,lnPOSLINK])) + DLAP  + '>'+'{0}'+'</a>'
            endif
         endif

         if flZEBRADO
            if (ii % 2 == 0)
               //lcHTML += '<tr class="wgridrowzebra" backgroundcolor="'+ fcCOR1+'">'
               lcHTML += '<tr class="wgridrow" backgroundcolor="'+ fcCOR1+'">'
            else
               lcHTML += '<tr class="wgridrowzebra" backgroundcolor="'+ fcCOR2+'">'
            endif
         else
            lcHTML += '<tr class="wgridrow">'
         endif

         lcHTML += CR   //Abre a TR para linha da TABLE
         for jj := 1 to len(faCOLUMNS[ii])
             // Se a coluna (row) ocorrer no meio do grid, ignora, evitando a insercao de
             // codigos HTML nos DIVs
             if (jj != lnPOS) .and. (jj != lnPOSCOR_LINK) .and. ( ascan(faVIEW,faCOLUMNS[1,jj]) > 0 )
                if lnPOS > 0 .and. at('[',faCOLUMNS[ii,jj]) <= 0  //TD com evento onClick
                   if at('javascript',faCOLUMNS[ii,lnPOS]) <= 0
                      llJAVA := .F.
                      lcHTML += '<td  onClick="document.location ='+chr(39)
                   else
                      llJAVA := .T.
                      lcHTML += '<td>'
                   endif

                   lcHTML += substr(faCOLUMNS[ii,lnPOS],at('(row)',faCOLUMNS[ii,lnPOS])+5)
                   if !llJAVA
                      lcHTML += chr(39)+'">'+CR
                   else
                      lcHTML += '</td>' + CR
                   endif
                else                                             //TD padrao
                   lcHTML += '<td>'+CR
                endif
                if at('[',faCOLUMNS[ii,jj]) > 0 //Criacao do link/botao
                   lcHTML += '<div align="center"><a class="wgridbutton" href="'
                   lcHTML += substr(faCOLUMNS[ii,jj],at(']',faCOLUMNS[ii,jj])+1)+'">'    //Link
                   lcHTML += substr(faCOLUMNS[ii,jj],at('[',faCOLUMNS[ii,jj])+1,at(']',faCOLUMNS[ii,jj])-2) //Titulo link
                   lcHTML += '</div></a>'+CR
                else
                   if valtype(faCOLUMNS[ii,jj]) == 'N' .or. valtype(faCOLUMNS[ii,jj]) == 'I'
                      // Glauber 07/04/2014 - Caso o campo seja numérico mudar o alinhamento para direita e colocar a máscara de edição definida no catálogo.
                      lcTMP := wpictrans(faCOLUMNS[1,jj],faCOLUMNS[ii,jj])
                      if valtype(faCOLUMNS[ii,jj]) == 'N'
                         lcALIGN := "right"
                      endif
                      if (lnPOSCOR_LINK > 0)
                          if (lnPOSLINK > 0)
                             //lcHTML += '<div align="' +lcALIGN +'"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+strtran(lcLINK,'{0}',alltrim(str(faCOLUMNS[ii,jj])))  +'</font></div>'+CR
                             lcHTML += '<div align="' +lcALIGN +'"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+strtran(lcLINK,'{0}',lcTMP)  +'</font></div>'+CR
                          else
                               //lcHTML += '<div align="' +lcALIGN +'"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+alltrim(str(faCOLUMNS[ii,jj]))+'</font></div>'+CR
                               lcHTML += '<div align="' +lcALIGN +'"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+lcTMP+'</font></div>'+CR
                          endif
                      else
                          if (lnPOSLINK > 0)
                             //lcHTML += '<div align="' +lcALIGN +'"> ' + strtran(lcLINK,'{0}',alltrim(str(faCOLUMNS[ii,jj])))  +'</div>'+CR
                             lcHTML += '<div align="' +lcALIGN +'"> ' + strtran(lcLINK,'{0}',lcTMP)  +'</div>'+CR
                          else
                             //lcHTML += '<div align="' +lcALIGN +'"> ' + alltrim(str(faCOLUMNS[ii,jj]))+'</div>'+CR
                             lcHTML += '<div align="' +lcALIGN +'"> ' + lcTMP+'</div>'+CR
                          endif
                      endif
                   elseif valtype(faCOLUMNS[ii,jj]) == 'D'
                      if (lnPOSCOR_LINK > 0)
                          if (lnPOSLINK > 0)
                             lcHTML += '<div align="center"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+strtran(lcLINK,'{0}',dtoc(faCOLUMNS[ii,jj]))  +'</font></div>'+CR
                          else
                             lcHTML += '<div align="center"><font color="'+ faCOLUMNS[ii,lnPOSCOR_LINK]+'">' +dtoc(faCOLUMNS[ii,jj])+'</font></div>'+CR
                          endif
                      else
                          if (lnPOSLINK > 0)
                             lcHTML += '<div align="center"> ' +strtran(lcLINK,'{0}',dtoc(faCOLUMNS[ii,jj]))+'</div>'+CR
                          else
                             lcHTML += '<div align="center">'+dtoc(faCOLUMNS[ii,jj])+'</div>'+CR
                          endif
                      endif
                   else
                      if (lnPOSCOR_LINK > 0)
                          if (lnPOSLINK > 0)
                             if at('type="button"',faCOLUMNS[ii,jj]) > 0
                                lcHTML += '<div align="center"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+alltrim(faCOLUMNS[ii,jj])  +'</font></div>'+CR
                             else
                                lcHTML += '<div align="left"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+strtran(lcLINK,'{0}',alltrim(faCOLUMNS[ii,jj]))  +'</font></div>'+CR
                             endif
                          else
                             lcHTML += '<font color="'+ faCOLUMNS[ii,lnPOSCOR_LINK]+'">' +alltrim(faCOLUMNS[ii,jj])+'</font></div>'+CR
                          endif
                      else
                          if (lnPOSLINK > 0)
                             if (lnPOSCOR_LINK > 0)
                                lcHTML += '<div align="left"> <font color="' + faCOLUMNS[ii,lnPOSCOR_LINK] +'">'+strtran(lcLINK,'{0}',alltrim(faCOLUMNS[ii,jj]))  +'</font></div>'+CR
                             else
                                lcHTML += '<div align="left"> ' +strtran(lcLINK,'{0}',alltrim(faCOLUMNS[ii,jj]))  +'</div>'+CR
                             endif
                          else
                             lcHTML += alltrim(faCOLUMNS[ii,jj])+CR
                          endif
                      endif
                   endif
                endif
                //lcHTML += '</font></td>'+CR
                lcHTML += '</td>'+CR
             endif
         next jj
         lcHTML += '</tr>'+CR  //Fecha TR das linha da TABLE

         // Coloca a linha de espaçamento tracejada.

         if flTRACEJADO

             lcHTML += '<tr>' +CR   //Abre a TR para linha da TABLE

             for jj := 1 to len(faCOLUMNS[ii])
                 // Se a coluna (row) ocorrer no meio do grid, ignora, evitando a insercao de
                 // codigos HTML nos DIVs
                 if (jj != lnPOS) .and. (jj != lnPOSCOR_LINK) .and. (at('javascript',faCOLUMNS[ii,jj]) == 0) .and. ( ascan(faVIEW,faCOLUMNS[1,jj]) > 0 )

                    //TD padrao
                    lcHTML += '<td  align="center">  '+CR

                    if (valtype(faCOLUMNS[ii,jj]) == 'D') // Data
                       lcHTML += StrTran('<font color="{0}">' +replicate('-',10)+'</font>'+CR,"{0}",fcCORTRACEJADO)
                    elseif valtype(faCOLUMNS[ii,jj]) == 'N' .or. valtype(faCOLUMNS[ii,jj]) == 'I'
                       lcHTML += StrTran('<font color="{0}">' +replicate('-',len(alltrim(faCOLUMNS[ii,jj])))+'</font>'+CR,"{0}",fcCORTRACEJADO)
                    elseif wmd_fieldtype(faCOLUMNS[1,jj]) == 'TEXT'
                       lcHTML += StrTran('<font color="{0}">' +replicate('-',150)+'</font>'+CR,"{0}",fcCORTRACEJADO)
                    else
                       lcHTML += StrTran('<font color="{0}">' +replicate('-',wmd_fieldsize(faCOLUMNS[1,jj]))+'</font>'+CR,"{0}",fcCORTRACEJADO)
                    endif
                    lcHTML += '</td>'+CR
                 endif
             next jj
             lcHTML += '</tr>'+CR  //Fecha TR das linha da TABLE
         endif

     next ii
     if llSHOWHEADER
         lcHTML += '</tbody>'+CR // Fecha TBODY
         //Fecha a TABLE principal
         lcHTML += '</table>'+CR
         lcHTML += '</div>'+CR
// Glauber 01/07/2014 - O trecho abaixo gera erro de javascript visualizado pelo debug do IE
//         lcHTML += '<script language="javascript">init ("wgrid")</script>'+CR
     endif
  endif
return(lcHTML)









/*
* Glauber - 12/2014
*
* Function..: NovoCbox(<fcALVO>,<fcOPTION>,<fcOPTVALUE>,<fcTABLE>,<fcWHERE>,<faEMPTY>)
* Objetivo..: Alimentar um combo box.
* Parâmetros:
*
*    fcALVO     : nome do combo na tela.
*
*    fcOPTION   : nome do campo que vai alimentar o rotulo(option) do combo.
*
*    fcOPTVALUE : nome do campo que vai alimentar o valor(value) do combo.
*
*    fcTABLE    : nome da tabela.
*
*    fcWHERE    : Expressão where a ser utilizada.
*
*    fcORDERBY  : Nome do campo para ordernação.
*
*    faEMPTY    : Vetor com os valores para inserção da linha em branco.
*       Formato:
*       {0,''} ou {'',''}
*
* Retorno...:
*
*    nada.
*
*/


Function NovoCbox(fcALVO,fcOPTION,fcOPTVALUE,fcTABLE,fcWHERE,fcORDERBY,faEMPTY)


    local laRESULT  := {},;
          laOPT     := {},;
          laOPTVAL  := {} as Array
    local ii        := 0 as Int

    if empty(fcALVO)
       putError('NovoCbox error: Nome do combo(alvo) não foi informado.')
       return
    endif

    if empty(fcOPTION)
       putError('NovoCbox error: Nome do campo option não foi informado.')
       return
    endif

    if empty(fcOPTVALUE)
       putError('NovoCbox error: Nome do campo option value não foi informado.')
       return
    endif

    if empty(fcTABLE)
       putError('NovoCbox error: Nome da tabela não foi informado.')
       return
    endif

   if ! empty(fcWHERE)
       if db_select({fcOPTION, fcOPTVALUE},fcTABLE,,{fcWHERE},{fcORDERBY}) == -1
          error_sys(db_error())
       endif
   else
       if db_select({fcOPTION, fcOPTVALUE},fcTABLE,,,{fcORDERBY}) == -1
          error_sys(db_error())
       endif
   endif
   laRESULT := db_fetchall()

   if len(laRESULT) > 1
      if (len(faEMPTY) == 2)
          aadd(laOPT,faEMPTY[1])
          aadd(laOPTVAL,faEMPTY[2])
      endif

      for ii := 2 to len(laRESULT)
          aadd(laOPT,laRESULT[ii,1])
          aadd(laOPTVAL,laRESULT[ii,2])
      next ii

      WPut(fcALVO + '.optionvalue',laOPT)
      WPut(fcALVO + '.option',laOPTVAL)


   endif

return






/*
* Glauber - 01/2015
*
* Function..: nlblfscreen(pcFIELD)
* Objetivo..: Quebra galho para permitir a montagem do cabeçalho de pasta respeitando as redefinições na tabela wfield_perfil.
* Parâmetros:
*
*    pcFIELD : nome do campo
*
* Retorno...: label do campo.
*
*
*
*/

Static Function nlblfscreen(pcFIELD)


//    if db_select({'LABEL_SCREEN'},'wfield_perfil',,{'TP_PASTA='+DLAP +WGET('TP_PASTA')+DLAP + ' and WFIELD='+DLAP + pcFIELD + DLAP + ' and WGID= ' + alltrim(WSet('WGID'))}) == -1

    if db_select({'LABEL_SCREEN'},'wfield_perfil',,{'(pastas like ' +DLAP +'%' +WGET('TP_PASTA') +'%'+ DLAP +' and GROUPS like ' +DLAP+'%' +alltrim(WSet('WGID'))+'%'+DLAP + ') and wfield =' +DLAP + pcFIELD + DLAP}) == -1
       error_sys(db_error())
    endif
    laRES := db_fetchall()
    if len(laRES) > 1
       return laRES[2,1]
    else
       if db_select({'LABEL_SCREEN'},'wfield',,{'PROJECT='+DLAP +'gr5'+DLAP + ' and WFIELD='+DLAP + pcFIELD + DLAP}) == -1
          error_sys(db_error())
       endif
       laRES := db_fetchall()
       if len(laRES) > 1
          return laRES[2,1]
       endif
    endif

 return pcFIELD



/*
* Glauber - 11/2011  
*
* Function  : wic_random()
* Objetivo  : gerar um número aleatório usando como semente a soma do valor retornado 
*             pela função seconds mais o valor retornado pela função execpidnum.
*             
*             
*             
* Parâmetros:
*
* Retorno   : Numero aleatório. 
*             
*/   

Function wic_random()
LOCAL_LONG Init_Val, random_num

      init_val := SECONDS()+ExecPIDnum()
      #Cinline
         srand48 (init_val);
         random_num = lrand48();
      #endCinline
      lnRand  := val(substr(str(random_num,10),5,6))

return(lnRand)


***********************
function html2str(sSTR)
***********************
* Rufino 11/06/2015 13:58:42

local zz:=0 as int
local ii:=0 as int




*if at('#0',sSTR) > 0
*   for zz:=0 to 255
*       sSTR := strtran(sSTR,'&#0'+alltrim(str(zz))+';',chr(zz))
*       zz:=zz+1
*   next zz
*endif

if at('#',sSTR) > 0
   for ii:=0 to 255

       if at('&#'+alltrim(str(ii))+';',sSTR) > 0
          walert('acho')
          sSTR := strtran(sSTR,'&#'+alltrim(str(ii))+';',chr(ii))
          debug2(sSTR,,30)
       endif

       ii:=ii+1
   next ii
endif



return(sSTR)


**************************************************************
function cargacbox(fcTABLE,faFIELDS,faORDER,fcDESTINO)
**************************************************************
*** rufino 30/07/2015 16:28:03
*** cargacbox('indice_reajuste',{'CD_INDICE','NM_INDICE'},{'CD_INDICE'},'NM_INDICE')


local lcWHERE:=''
local laRES:={}
local laLST_NOVA:={}
local laVINCULADO:={}

local paAUTO     :={} as array



local  laOPT    := {} ,;
       laOPTV   := {} ,;
       laPUT    := {} ,;
       laDEF    := {} ,;
       laDEFV   := {} ,;
       laATI    := {} ,;
       laATIV   := {} ,;
       laINA    := {} ,;
       laINAV   := {} ,;
       laPUTV   := {} ,;
       laFIELD  := {} as array


local  jj    := 1  ,;
       liPOS := 0  as int


laDEF := {}
laDEFV:= {}

laATI := {}
laATIV:= {}

laINA := {}
laINAV:= {}

laPUT := {}
laPUTV:= {}

laFIELD := structtable(WSet("DB_ACTIVE"),fcTABLE,1,'A')
liPOS   := ascan(laFIELD,'FL_ATIVO')

if liPOS<>0
   aadd(faFIELDS,'FL_ATIVO')
endif

laFIELD:=faFIELDS

if db_select(laFIELD,fcTABLE,,,faORDER) == -1
   error_sys(db_error())
endif
laRES := db_fetchall()


if liPOS<>0 .and. len(laFIELD)==3
*** codigo,descrição,ativo

for jj := 2 to len(laRES)
    if liPOS<>0
       if laRES[jj,3] == 'D'
          aadd(laDEF,laRES[jj,2])
          aadd(laDEFV,laRES[jj,1])

        elseif laRES[jj,3] == 'I'
          aadd(laINA,laRES[jj,2])
          aadd(laINAV,laRES[jj,1])

        else
          aadd(laATI,laRES[jj,2])
          aadd(laATIV,laRES[jj,1])
       endif
    else
       aadd(laATI,laRES[jj,2])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if liPOS<>0 .and. len(laFIELD)==2
***descricao,ativo

for jj := 2 to len(laRES)
    if liPOS<>0
       if laRES[jj,2] == 'D'
          aadd(laDEF,laRES[jj,1])
          aadd(laDEFV,laRES[jj,1])

        elseif laRES[jj,2] == 'I'
          aadd(laINA,laRES[jj,1])
          aadd(laINAV,laRES[jj,1])

        else
          aadd(laATI,laRES[jj,1])
          aadd(laATIV,laRES[jj,1])
       endif
    else
       aadd(laATI,laRES[jj,1])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif


if liPOS==0 .and. len(laFIELD)==2
*** codigo,descrição

for jj := 2 to len(laRES)
    if liPOS<>0
       aadd(laATI,laRES[jj,2])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if liPOS==0 .and. len(laFIELD)==1
***descricao

for jj := 2 to len(laRES)
    if liPOS<>0
       aadd(laATI,laRES[jj,1])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if len(laDEF) == 0
   aadd(laDEF,'') // Adiciona uma linha vazia no inicio do combo, caso seja solicitado
   aadd(laDEFV,'')
endif

for jj=1 to len(laDEF)
    aadd(laPUT,laDEF[jj])
    aadd(laPUTV,laDEFV[jj])
next jj

for jj=1 to len(laATI)
    aadd(laPUT,laATI[jj])
    aadd(laPUTV,laATIV[jj])
next jj

for jj=1 to len(laINA)
    aadd(laPUT,'INATIVO - '+laINA[jj])
    aadd(laPUTV,laINAV[jj])
next jj

WPut(fcDESTINO+'.option',laPUT)
WPut(fcDESTINO+'.optionvalue',laPUTV)

return(nil)

/*
*
* Glauber 02/2016
*
* Function..: prewfmktc(<faPARMS>)
* Objetivo..: Nova função para criar Tarefas ou Compromisso com base em pré-requisitos a ser atendida.
*             inserido ira permitir a baixa automática do compromisso ou tarefa gerado por esta função.
* Parâmetros:
*    faPARMS: Matriz bidimensional contendo os nomes de campos/parametros e seus respectivos valores
*    Formato:
*     Parametro---------        Tipo---   Formato de envio--------------------------------  Descrição-------------------------------------------
*     {{'NR_CONTROLE'         , [expN] }                                                    Número de Controle
*      {'TP_TC'               , [expC] }  [T]-Tarefa [C]-Compromisso                        Tipo de Agenda
*      {'TITULO'              , [expC] }                                                    Título
*      {'LOGIN_AGENDADO'      , [expC] }                                                    Agendado por
*      {'DT_AGENDADO'         , [expC] }  YYYYMMDD                                          Data de agendamento
*      {'HR_AGENDADO'         , [expC] }  HHMMSS                                            Hora de agendamento
*      {'FL_PARTICULAR'       , [expC] }  [S]-Sim [N]-Não                                   TC particular
*      {'FL_PRAZO'            , <expC> }  [S]-Sim [N]-Não                                   Flag de prazo
*      {'DT_PRAZO'            , [expC] }  YYYYMMDD                                          Data do prazo
*      {'HR_PRAZO'            , [expC] }  HHMMSS                                            Hora do prazo
*      {'FL_INICIO'           , <expC> }  [S]-Sim [N]-Não                                   Flag de inicio
*      {'DT_INICIO'           , [expC] }  YYYYMMDD                                          Data de inicio
*      {'HR_INICIO'           , [expC] }  HHMMSS                                            Hora de inicio
*      {'FL_HR_OCUPADO'       , [expC] }  [S]-Sim [N]-Não                                   Flag de hora ocupada
*      {'FL_FIM'              , <expC> }  [S]-Sim [N]-Não                                   Flag de hora ocupada
*      {'DT_FIM'              , [expC] }  YYYYMMDD                                          Data final no formato
*      {'HR_FIM'              , [expC] }  HHMMSS                                            Hora final no formato
*      {'FL_DIAINTEIRO'       , [expC] }  [S]-Sim [N]-Não                                   Dia inteiro
*      {'FL_FILA'             , <expC> }  [S]-Sim [N]-Não                                   Fila
*      {'FL_POPUPPART'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via popup
*      {'FL_EMAILPART'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via email
*      {'FL_SMSPART'          , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao participante via sms
*      {'FL_NOTIFICA'         , <expC> }  [S]-Sim [N]-Não                                   Avisar na criação
*      {'FL_REJEITA'          , [expC] }  [S]-Sim [N]-Não                                   Permitir recusa
*      {'FL_REDIRECIONA'      , [expC] }  [S]-Sim [N]-Não                                   Permitir redirecionamento
*      {'FL_AUTENTICA'        , [expC] }  [S]-Sim [N]-Não                                   Exige autenticação
*      {'FL_POPUPRESP'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via popup
*      {'FL_EMAILRESP'        , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via email
*      {'FL_SMSRESP'          , [expC] }  [S]-Sim [N]-Não                                   Enviar aviso ao responsável via sms
*      {'REFERENCIA'          , [expC] }                                                    Referencia a um item no sistema
*      {'REF_CHAVE'           , [expC] }                                                    Chave da referencia
*      {'NM_TC'               , [expC] }                                                    Descrição do compromisso
*      {'PRIORIDADE'          , [expC] }                                                    Prioridade
*      {'LOGIN_ALTERA'        , [expC] }                                                    Login da ultima alteração
*      {'DT_ALTERA'           , [expC] }  YYYYMMDD                                          Data da ultima alteração
*      {'HR_ALTERA'           , [expC] }  HHMMSS                                            Hora da ultima alteração
*      {'TC_CATEGORIA'        , [expC] }                                                    Categoria da tarefa/compromisso
*      {'PARTICIPANTES'       , <expA> }  {'marcos','eduardo','mahler@inso.com.br','julio'} Participantes, pode ser usuário, grupo ou contato.
*      {'LEMBRETES'           , <expA> }  {{'D',10},{'D',10},{'H',10},{'M',30},{'D',20}}    Lembretes
*      {'RESPONSAVEIS'        , <expA> }  {'mahler','bruno','master'}                       Responsáveis, pode ser usuário ou grupo
*      {'EMAIL_SENDER'        , <expC> }  marcos@inso.com.br                                Email do remetente. Será usado quando o gr5tasks
*      {'BAIXA_TP_ANDAMENTO'  , <expC> }  Audiência                                   Tipo do Andamento que habilita a baixa automática.
*      {'BAIXA_TP_DOCUMENTO'  , <expC> }  Doc01                                       Tipo de documento ged que habilita a baixa automática.
*      {'AGENDA_GOOGLE'       , <expC> }  [S]-Sim [N]-Não                             Indica se a tarefa ou compromisso vai ser agendado também na agenda do google.
*      {'AGENDA_LOCAL'        , <expC> }  Inso                                        Indica o local do compromisso na agenda do google.
*      {'PRE_CONDICAO        , <expC> }  =IIF(WFDBGETVALUE(...)...                    Bloco de código a ser analisado onde sempre o resultado deve retornar .T. ou .F.
* 																												  enviar uma mensagem
*
*    OBS.: O parametro PARTICIPANTE poderá ter dois formatos: vetor ou matriz bidimensional
*
*       Vetor.: DEVE ser informado apenas na inserção de uma tarefa ou compromisso. Ex: {'marcos','eduardo','mahler@inso.com.br','julio'}
*       Matriz: DEVE ser informado apenas na alteração de uma tarefa ou compromisso, pois nesta situação existem os dados do grid
*               detalhado, tais dados devem ser gravados na tabela de participantes [tc_participante]. O formato OBRIGTÓRIO é:
*               {{LOGIN_PART1,TC_STATUS1,PC_CONCLUIDO1},;
*                {LOGIN_PART2,TC_STATUS2,PC_CONCLUIDO2},;
*                {LOGIN_PART3,TC_STATUS3,PC_CONCLUIDO3},;
*                {   ...     ,   ...    ,     ...     },;
*                {LOGIN_PARTn,TC_STATUSn,PC_CONCLUIDOn}}
*
*               Onde:
*                  Col 1 - Login do usuário participante
*                  Col 2 - Status do compromisso
*                  Col 3 - Percentual de conclusão
*
* Retorno...: int
*   > 0: Número do compromisso inserido
*   = 0: em caso de falha
*
*/
function prewfmktc(faPARAM)
   local lcDATA        := '' ,;
         lcHORA        := '' ,;
         lcTSTP        := '' ,;
         lcDT_LEMBRETE := '' ,;
         lcHR_LEMBRETE := '' ,;
         lcDT_INI      := '' ,;
         lcHR_INI      := '' ,;
         lcDT_END      := '' ,;
         lcHR_END      := '' ,;
         lcPROJECT     := '' ,;
         lcALIAS       := '' ,;
         lcTBORIGN     := '' ,;
         lcRETURN_PATH := '' ,;
         lcMSG         := '' ,;
         lcMSG_ERRO     := '' as string

   local laPARAM      := {} ,;
         laFIELDS     := {} ,;
         laSAVE       := {} ,;
         laSAVE_AUX   := {} ,;
         laWHERE      := {} ,;
         laPART       := {} ,;
         laPART_ANT   := {} ,;
         laLEMBR      := {} ,;
         laRESP       := {} ,;
         laREF        := {} ,;
         laSENDER     := {} ,;
         laSEND_TO    := {} ,;
         laTEMP       := {} ,;
         laTEMP1      := {} ,;
         laVINCULO    := {} ,;
         laEMAILS_DIV := {} as array // Emails diversos/avulsos

   local ii   := 0 ,;
         iiL  := 0 ,;
         jj   := 0 ,;
         lnID := 0 as int

   local llFOUND := .F. ,;
         llINS   := .F. as logical


   local luTMP

   local lcBLOCOEVAL,;
         llEXECUTAR

   lcPROJECT := WSet('_PROJECT')
   WSet('_PROJECT','workflow')

   /* Descrição do array:
   *  Coluna 1 - Nome do campo/parâmetro
   *  Coluna 2 - Indica se é campo obrigatorio ou não - [Y/N]
   */
   laPARAM := {{'NR_CONTROLE'   ,'' },; // Número de Controle
               {'TP_TC'         ,'Y'},; // Tipo de Agenda [T]-Tarefa [C]-Compromisso
               {'TITULO'        ,'' },; // Título
               {'LOGIN_AGENDADO','' },; // Agendado por
               {'DT_AGENDADO'   ,'' },; // Data de agendamento no formato YYYYMMDD
               {'HR_AGENDADO'   ,'' },; // Hora de agendamento no formato HHMMSS
               {'FL_PARTICULAR' ,'' },; // Compromisso/Tarefa particular ? [S]-Sim [N]-Não
               {'FL_PRAZO'      ,'Y'},; // Flag de prazo [S]-Sim [N]-Não
               {'DT_PRAZO'      ,'' },; // Data do prazo no formato YYYYMMDD
               {'HR_PRAZO'      ,'' },; // Hora do prazo no formato HHMMSS
               {'FL_INICIO'     ,'Y'},; // Flag de inicio [S]-Sim [N]-Não
               {'DT_INICIO'     ,'' },; // Data de inicio no formato YYYYMMDD
               {'HR_INICIO'     ,'' },; // Hora de inicio no formato HHMMSS
               {'FL_HR_OCUPADO' ,'' },; // Flag de hora ocupada [S]-Sim [N]-Não
               {'FL_FIM'        ,'Y'},; // Flag de hora ocupada [S]-Sim [N]-Não
               {'DT_FIM'        ,'' },; // Data final no formato YYYYMMDD
               {'HR_FIM'        ,'' },; // Hora final no formato HHMMSS
               {'FL_DIAINTEIRO' ,'' },; // Flag de dia inteiro [S]-Sim [N]-Não
               {'FL_FILA'       ,'Y'},; // Flag de fila [S]-Sim [N]-Não
               {'FL_POPUPPART'  ,'' },; // Flag de aviso do participante via popup [S]-Sim [N]-Não
               {'FL_EMAILPART'  ,'' },; // Flag de aviso do participante via email [S]-Sim [N]-Não
               {'FL_SMSPART'    ,'' },; // Flag de aviso do participante via sms [S]-Sim [N]-Não
               {'FL_NOTIFICA'   ,'Y'},; // Flag de aviso na criação [S]-Sim [N]-Não
               {'FL_REJEITA'    ,'' },; // Flag de permissão de recusa [S]-Sim [N]-Não
               {'FL_REDIRECIONA','' },; // Flag de permissão de redirecionamento [S]-Sim [N]-Não
               {'FL_AUTENTICA'  ,'' },; // Flag de exigencia de autenticação [S]-Sim [N]-Não
               {'FL_POPUPRESP'  ,'' },; // Flag de aviso do responsável via popup [S]-Sim [N]-Não
               {'FL_EMAILRESP'  ,'' },; // Flag de aviso do responsável via email [S]-Sim [N]-Não
               {'FL_SMSRESP'    ,'' },; // Flag de aviso do responsável via sms [S]-Sim [N]-Não
               {'REFERENCIA'    ,'' },; // Referencia a um item no sistema
               {'REF_CHAVE'     ,'' },; // Chave da referencia
               {'NM_TC'         ,'' },; // Descrição do compromisso
               {'PRIORIDADE'    ,'' },; // Prioridade
               {'LOGIN_ALTERA'  ,'' },; // Login da ultima alteração
               {'DT_ALTERA'     ,'' },; // Data da ultima alteração no formato YYYYMMDD
               {'HR_ALTERA'     ,'' },; // Hora da ultima alteração no formato HHMMSS
               {'TC_CATEGORIA'  ,'' },; // Categoria da tarefa/compromisso
               {'PARTICIPANTES' ,'Y'},; // Participantes, pode ser usuário, grupo ou contato.
               {'LEMBRETES'     ,'Y'},; // Lembretes
               {'RESPONSAVEIS'  ,'Y'},; // Responsáveis, pode ser usuário ou grupo
               {'EMAIL_SENDER'  ,'' },;  // Email do remetente. Será usado quando o gr5tasks enviar uma mensagem
               {'BAIXA_TP_ANDAMENTO', ''},; // Tipo do Andamento que habilita a baixa automática.
               {'BAIXA_TP_DOCUMENTO', ''},; // Tipo de documento ged que habilita a baixa automática.
               {'AGENDA_GOOGLE', ''},;      // Indica se a tarefa ou compromisso vai ser agendado também na agenda do google.
               {'AGENDA_LOCAL', ''},; // Indica o local do compromisso na agenda do google.
               {'PRE_CONDICAO', 'Y'}} // Pre-condição a ser atendida.



   // Caso o campo de pre-condição não esteja preenchido, deve-se retornar sem realzizar nenhuma operação.


   if param_pos(faPARAM,'PRE_CONDICAO') > 0
      llEXECUTAR  :=  faPARAM[param_pos(faPARAM,'PRE_CONDICAO'),2] //eval({||&lcBLOCOEVAL})

//wout('<br><b>Atende Pré-Condição:' + transform(llExecutar))

      if (! llEXECUTAR) // Pré-condição não atendida.
         return(0)
      endif
   else
      return(0)
   endif


   if param_pos(faPARAM,'TP_TC') > 0
      lcTP_TC := upper(alltrim(faPARAM[param_pos(faPARAM,'TP_TC'),2]))
   else
      error_sys('wfmktc('+alltrim(str(procline()))+') Parameter not defined: TP_TC')
      WSet('_PROJECT',lcPROJECT)
      return(0)
   endif

//? 'Tipo:',lcTP_TC
//? 'Excluido de faPARAM --------------------'

   // Elimina parametros não utilizados para o tipo de agenda enviado ---------------------------------------------------------------------
   laTEMP := aclone(faPARAM)
   for ii := 1 to len(laTEMP)
       if (lcTP_TC=='T' .and. at(laTEMP[ii,1],'FL_FIM DT_FIM HR_FIM') > 0) .or.;
          (lcTP_TC=='C' .and. at(laTEMP[ii,1],'FL_PRAZO DT_PRAZO HR_PRAZO FL_DIAINTEIRO FL_INICIO FL_FILA PRIORIDADE') > 0)
          putERROR('wfmktc: Parameter not used: '+faPARAM[ii,1])

//? 'Linha:',param_pos(faPARAM,laTEMP[ii,1]),'excluido:',laTEMP[ii,1]

          adel(faPARAM,param_pos(faPARAM,laTEMP[ii,1]))
          asize(faPARAM,len(faPARAM)-1)
       endif
   next ii

   //Validação de parâmetros obrigatórios
   //for ii := 1 to len(laPARAM)
   //    if laPARAM[ii,2] == 'Y' .and. param_pos(faPARAM,laPARAM[ii,1]) == 0
   //       error_sys('wfmktc('+alltrim(str(procline()))+') Parameter not defined: '+laPARAM[ii,1])
   //       return(0)
   //    endif
   //next ii

   laFIELDS := structtable(WSet("DB_ACTIVE"),'tarefa_compromisso',1,'N','workflow')


//? 'Excluido de laFIELDS --------------------'

   // Elimina campos não utilizados para o tipo de agenda enviado -------------------------------------------------------------------------
   laTEMP := aclone(laFIELDS)
   for ii := 1 to len(laTEMP)
       if lcTP_TC == 'C' .and. ;
          at(laTEMP[ii],'FL_PRAZO DT_PRAZO HR_PRAZO FL_DIAINTEIRO FL_INICIO FL_FILA PRIORIDADE') > 0
          adel(laFIELDS,ascan(laFIELDS,laTEMP[ii]))
          asize(laFIELDS,len(laFIELDS)-1)

//? 'Tipo:',lcTP_TC,'Linha:',ii,'excluido:',laTEMP[ii],len(laFIELDS),len(laTEMP)

       elseif lcTP_TC == 'T' .and. at(laTEMP[ii],'FL_FIM DT_FIM HR_FIM') > 0
          adel(laFIELDS,ascan(laFIELDS,laTEMP[ii]))
          asize(laFIELDS,len(laFIELDS)-1)

//? 'Tipo:',lcTP_TC,'Linha:',ii,'excluido:',laTEMP[ii],len(laFIELDS),len(laTEMP)

       endif
   next ii

   laTEMP := {}
   if param_pos(faPARAM,'NR_CONTROLE') > 0
      lnID := val(faPARAM[param_pos(faPARAM,'NR_CONTROLE'),2])
   else
      lnID := 0
   endif

   // Gravacao de [tarefa_compromisso] ----------------------------------------------------------------------------------------------------
   aadd(laSAVE,laFIELDS)
   for ii := 1 to len(laFIELDS)
       lnPOS   := param_pos(faPARAM,laFIELDS[ii])  //posicao do campo na matriz de parametros
       llFOUND := lnPOS > 0
       do case
          case laFIELDS[ii] == 'TP_TC'          //Tipo [T]-Tarefa [C]-Compromisso
             aadd(laSAVE_AUX,faPARAM[lnPOS,2])
          case laFIELDS[ii] == 'TITULO'         //Titulo
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],'Compromisso automático'))
          case laFIELDS[ii] == 'LOGIN_AGENDADO' //Agendado por
             aadd(laSAVE_AUX,lower(iif(llFOUND,faPARAM[lnPOS,2],WSet('LOGIN'))))
          case laFIELDS[ii] == 'DT_AGENDADO'    //Data do agendamento
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],dtos(date())))
          case laFIELDS[ii] == 'HR_AGENDADO'    //Hora do agendamento
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],substr(time(),1,5)))
          case laFIELDS[ii] == 'FL_PARTICULAR'  //Compromisso particular
             aadd(laSAVE_AUX,iif(llFOUND,faPARAM[lnPOS,2],'N'))
          case laFIELDS[ii] == 'DT_ALTERA' .or. laFIELDS[ii] == 'HR_ALTERA'
             if llFOUND
                if lnID > 0
                   aadd(laSAVE_AUX,iif(!empty(faPARAM[lnPOS,2]),faPARAM[lnPOS,2],iif(laFIELDS[ii] == 'DT_ALTERA',date(),time())))
                else
                   aadd(laSAVE_AUX,nil)
                endif
             else
                aadd(laSAVE_AUX,nil)
             endif
          otherwise
             if llFOUND
                aadd(laSAVE_AUX,faPARAM[lnPOS,2])
             else
                aadd(laSAVE_AUX,nil)
             endif
       endcase
   next ii
   aadd(laSAVE,laSAVE_AUX)

   db_begin()
   if db_replace(laSAVE,'tarefa_compromisso',{'NR_CONTROLE='+alltrim(str(lnID))}) == -1
      error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
      WSet('_PROJECT',lcPROJECT)
      return(0)
   endif

   if lnID == 0
      llINS := .T.
      lnID  := db_insert_id()
   endif

//debug2(faPARAM,,30)

   // Gravação de [tc_participante] -------------------------------------------------------------------------------------------------------
   if param_pos(faPARAM,'PARTICIPANTES') > 0
      // Glauber 08/2012
      // Verificar se o prâmetro participantes é string ou array e fazer o devido tratamento
      if valtype(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]) == "C"
         laPART := str2array(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2],",")
      else
         laPART := faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]
      endif
//debug2(laPART,,30)
      if len(laPART) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_participante',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laPART)

             // Se for alteração e status for 1, armazena os participantes para serem enviados a wfremovealert
             // e atualizados em tc_login_lembrete.FL_AVISO='S' para gerar novamente o aviso caso seja necessário
             if !llINS .and. laPART[ii,2] == '1'
                aadd(laTEMP,laPART[ii,1])
             endif

             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                       aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'LOGIN_PARTICIPANTE'
                       aadd(laSAVE_AUX,lower(iif(llINS,laPART[ii],laPART[ii,1])))
                    case laFIELDS[jj] == 'TC_STATUS'
                       if lcTP_TC == 'T'
                          if faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
                             if llINS
                                aadd(laSAVE_AUX,'F')             // Encaminhado para fila
                             else
                                aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'F'))
                             endif
                          else
                             if llINS
                                aadd(laSAVE_AUX,'1')          // Não Notificado
                             else
                                aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'1'))
                             endif
                          endif
                       else
                          if llINS
                             aadd(laSAVE_AUX,'1')          // Não notificado
                          else
                             aadd(laSAVE_AUX,iif(!empty(laPART[ii,2]),laPART[ii,2],'1'))
                          endif
                       endif
                    case laFIELDS[jj] == 'DT_CONCLUSAO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          if laPART[ii,2] == '5'
                             aadd(laSAVE_AUX,date())
                          else
                             aadd(laSAVE_AUX,nil)
                          endif
                       endif
                    case laFIELDS[jj] == 'HR_CONCLUSAO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          if laPART[ii,2] == '5'
                             aadd(laSAVE_AUX,time())
                          else
                             aadd(laSAVE_AUX,nil)
                          endif
                       endif
                    case laFIELDS[jj] == 'PC_CONCLUIDO'
                       if llINS
                          aadd(laSAVE_AUX,nil)
                       else
                          aadd(laSAVE_AUX,iif(!empty(laPART[ii,3]) .or. laPART[ii,3] != 0,laPART[ii,3],nil))  // **ALTERACAO APENAS** -> Percentual informado pelo usuário (grid detalhado)
                       endif
                    otherwise
                       aadd(laSAVE_AUX,nil)
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+' and LOGIN_PARTICIPANTE='+DLAP+lower(iif(llINS,laPART[ii],laPART[ii,1]))+DLAP)
             laSAVE_AUX := {}
         next ii
         if db_replace(laSAVE,'tc_participante',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif

         if !llINS  // ** ALTERAÇÃO APENAS **

            // Remove avisos relacionados a TC e atualiza tc_login_lembrete.FL_AVISO='S' para gerar novamento os avisos caso necessário
            if len(laTEMP) > 0
               wfremovealert({param_fetch(faPARAM,'NR_CONTROLE',2)},laTEMP)
            else
               wfremovealert({param_fetch(faPARAM,'NR_CONTROLE',2)})
            endif

            // Adiciona usuários extras informados no grid detalhado na manuntenção de TCs
            laTEMP := {}
            for ii := 1 to len(laPART)
                aadd(laTEMP,laPART[ii,1])
            next ii
            laPART := aclone(laTEMP)
            laTEMP := {}
         endif
      endif
   endif

   // Gravação de [tc_lembrete] e [tc_login_lembrete] -------------------------------------------------------------------------------------
   if param_pos(faPARAM,'LEMBRETES') > 0

      //Se for tarefa para fila, gera aviso para responsáveis e para o criador (LOGIN_AGENDADO)
      if lcTP_TC == 'T' .and. faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
         laPART := faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]
//         WOUT('<BR><B>faPARAM')
//         DEBUG2(faPARAM,,50)
         aadd(laPART,lower(faPARAM[param_pos(faPARAM,'LOGIN_AGENDADO'),2]))
      endif


//               {'LEMBRETES'     ,{{'D',10},{'D',10},{'H',10},{'M',30},{'D',20}}},;                  // Lembretes
      // Glauber 08/2012
      // Preparar o array corretamente, pois o parâmetro vem no formato string

      if valtype(faPARAM[param_pos(faPARAM,'LEMBRETES'),2]) == "C"
         laTEMP := Str2Array(faPARAM[param_pos(faPARAM,'LEMBRETES'),2],";")
// debug2(laTEMP,,30)
         laSWP := {}
         for ii := 1 to len(laTEMP)
             if ! empty(laTEMP[ii])
                aadd(laSWP,{substr(laTEMP[ii],1,1), val(substr(laTEMP[ii],2,len(laTEMP[ii])))})
             endif
         next ii
// debug2(laSWP,,30)
         laLEMBR := aclone(laSWP)
      else
          laLEMBR := faPARAM[param_pos(faPARAM,'LEMBRETES'),2]
      endif


      if len(laLEMBR) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_lembrete',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laLEMBR)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                       aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'TP_LEMBRETE'
                       aadd(laSAVE_AUX,laLEMBR[ii,1])
                    case laFIELDS[jj] == 'QTD_LEMBRETE'
                       aadd(laSAVE_AUX,laLEMBR[ii,2])
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+;
                          ' and TP_LEMBRETE='+DLAP+laLEMBR[ii,1]+DLAP+;
                          ' and QTD_LEMBRETE='+alltrim(str(laLEMBR[ii,2])))
             laSAVE_AUX := {}
         next ii

// debug2(laWHERE,,60)
         if db_replace(laSAVE,'tc_lembrete',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif

         // Gravação dos lembretes [tc_login_lembrete] ------------------------------------------------------------------------------------
         if len(laPART) > 0
            if (valtype(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]) == "C")
               laPART_ANT := Str2Array(faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2],",")
            else
               laPART_ANT := faPARAM[param_pos(faPARAM,'PARTICIPANTES'),2]
            endif

            // Quando for implementar a validação dos parametros recebidos, este bloco deve ser removido deste ponto e inserido
            // juntamente com o restante das validações
            if lcTP_TC == 'T'
               if param_pos(faPARAM,'FL_DIAINTEIRO') > 0
                  if empty(alltrim(param_fetch(faPARAM,'FL_DIAINTEIRO')))
                     faPARAM[param_pos(faPARAM,'FL_DIAINTEIRO'),2] := 'S'
                  endif
               else
                 aadd(faPARAM,{'FL_DIAINTEIRO','N'})
               endif
            endif
            // ----------------------------------------------------------------------------------------------------------------------------

            if !llINS //Alteração - apaga os avisos não estiverem OK
               if db_delete('tc_login_lembrete','NR_CONTROLE='+alltrim(str(lnID))+' and DT_OK is NULL') == -1
                  error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
                  WSet('_PROJECT',lcPROJECT)
                  return(0)
               endif
            endif

            laSAVE     := {}
            laSAVE_AUX := {}
            laWHERE    := {}
            laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_login_lembrete',1,'N','workflow')
            aadd(laSAVE,laFIELDS)
            for ii := 1 to len(laPART)
                for iiL := 1 to len(laLEMBR)
                    for jj := 1 to len(laFIELDS)
                        do case
                           case laFIELDS[jj] == 'NR_CONTROLE'
                              aadd(laSAVE_AUX,lnID)
                           case laFIELDS[jj] == 'LOGIN_PARTICIPANTE'
                              aadd(laSAVE_AUX,lower(laPART[ii]))
                           case laFIELDS[jj] == 'DT_LEMBRETE'
                              lcDT_LEMBRETE := calc_lembrete(faPARAM,laLEMBR[iiL,1],laLEMBR[iiL,2],'D')
                              aadd(laSAVE_AUX,lcDT_LEMBRETE)
                           case laFIELDS[jj] == 'HR_LEMBRETE'
                              if param_fetch(faPARAM,'FL_DIAINTEIRO') == 'N' .or. empty(alltrim(param_fetch(faPARAM,'FL_DIAINTEIRO')))
                                 lcHR_LEMBRETE := calc_lembrete(faPARAM,laLEMBR[iiL,1],laLEMBR[iiL,2],'T')
                              else
                                 lcHR_LEMBRETE := '000000'
                              endif
                              aadd(laSAVE_AUX,lcHR_LEMBRETE)
                           case laFIELDS[jj] == 'FL_SENDSMS' .or. laFIELDS[jj] == 'FL_SENDEMAIL'
                              aadd(laSAVE_AUX,'N')
                           case laFIELDS[jj] == 'FL_FILA'
                              if lcTP_TC == 'T' .and. faPARAM[param_pos(faPARAM,'FL_FILA'),2] == 'S'
                                 aadd(laSAVE_AUX,'S')
                              else
                                 aadd(laSAVE_AUX,nil)
                              endif
                           case laFIELDS[jj] == 'FL_AVISO'
                              aadd(laSAVE_AUX,'N')
                           case laFIELDS[jj] == 'DT_OK'
                              if llINS
                                 aadd(laSAVE_AUX,nil)
                              else
                                 if laPART_ANT[ii,2] == '5'     // Se o status for igual a 5-Concluído, grava DT_OK para não gerar avisos
                                    aadd(laSAVE_AUX,date())
                                 else
                                    aadd(laSAVE_AUX,nil)
                                 endif
                              endif
                           case laFIELDS[jj] == 'HR_OK'
                              if llINS
                                 aadd(laSAVE_AUX,nil)
                              else
                                 if laPART_ANT[ii,2] == '5'    // Se o status for igual a 5-Concluído, grava HR_OK para não gerar avisos
                                    aadd(laSAVE_AUX,time())
                                 else
                                    aadd(laSAVE_AUX,nil)
                                 endif
                              endif
                           otherwise
                              aadd(laSAVE_AUX,nil)
                        endcase
                    next jj
                    aadd(laSAVE,laSAVE_AUX)
                    aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+;
                                 ' and LOGIN_PARTICIPANTE='+DLAP+lower(laPART[ii])+DLAP+;
                                 ' and DT_LEMBRETE='+DLAP+lcDT_LEMBRETE+DLAP+;
                                 ' and HR_LEMBRETE='+DLAP+lcHR_LEMBRETE+DLAP)
                    laSAVE_AUX := {}
                next iiL
            next ii
            if db_replace(laSAVE,'tc_login_lembrete',laWHERE) == -1
               error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
               WSet('_PROJECT',lcPROJECT)
               return(0)
            endif
         endif
      endif
   endif

   // Gravação de [tc_responsavel] --------------------------------------------------------------------------------------------------------
   if param_pos(faPARAM,'RESPONSAVEIS') > 0
      if Valtype(faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]) == "C"
         laRESP := Str2Array(faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2],",")
      else
         laRESP := faPARAM[param_pos(faPARAM,'RESPONSAVEIS'),2]
      endif
      if len(laRESP) > 0

         // Alteração - apaga todos os responsáveis e reinsere
         if lnID != 0
            if db_delete('tc_responsavel','NR_CONTROLE='+alltrim(str(lnID))) ==   -1
               error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
               WSet('_PROJECT',lcPROJECT)
               return(0)
            endif
         endif

         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := structtable(WSet("DB_ACTIVE"),'tc_responsavel',1,'N','workflow')
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laRESP)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'NR_CONTROLE'
                         aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'LOGIN_RESPONSAVEL'
                         aadd(laSAVE_AUX,lower(laRESP[ii]))
                    case laFIELDS[jj] == 'FL_AVISO'
                         aadd(laSAVE_AUX,'N')
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'NR_CONTROLE='+alltrim(str(lnID))+' and LOGIN_RESPONSAVEL='+DLAP+lower(laRESP[ii])+DLAP)
             laSAVE_AUX := {}
         next ii

         if db_replace(laSAVE,'tc_responsavel',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif
      endif
   endif

   // Gravação de [tc_reftc] --------------------------------------------------------------------------------------------------------------
   if !empty(param_fetch(faPARAM,'REFERENCIA')) .and. !empty(param_fetch(faPARAM,'REF_CHAVE'))
      laREF := str2array(param_fetch(faPARAM,'REF_CHAVE'),',')
      if len(laREF) > 0
         laSAVE     := {}
         laSAVE_AUX := {}
         laWHERE    := {}
         laFIELDS   := {'CHAVE_TC','REF_CHAR','REF_NUM'}
         aadd(laSAVE,laFIELDS)
         for ii := 1 to len(laREF)
             for jj := 1 to len(laFIELDS)
                 do case
                    case laFIELDS[jj] == 'CHAVE_TC'
                         aadd(laSAVE_AUX,lnID)
                    case laFIELDS[jj] == 'REF_CHAR'
                         //? 'REF_CHAR Tipo:',valtype(laREF[ii]),'Conv:',alltrim(str(laREF[ii])),'Valor:',laREF[ii]

                         luTMP := laREF[ii]
                         if valtype(luTMP) == 'N'
                            luTMP := alltrim(str(luTEMP))
                         elseif valtype(luTMP) == 'D'
                            luTMP := dtoc(luTEMP)
                         endif
                         aadd(laSAVE_AUX,laREF[ii])
                    case laFIELDS[jj] == 'REF_NUM'
                         //? 'REF_NUM Tipo:',valtype(laREF[ii]),'Conv:',val(laREF[ii]),'Valor:',laREF[ii]

                         luTMP := laREF[ii]
                         if valtype(luTMP) == 'C'
                            luTMP := val(luTMP)
                         elseif valtype(luTMP) == 'D'
                            luTMP := 0
                         endif
                         aadd(laSAVE_AUX,luTMP)
                 endcase
             next jj
             aadd(laSAVE,laSAVE_AUX)
             aadd(laWHERE,'CHAVE_TC='+alltrim(str(lnID)))
             laSAVE_AUX := {}
         next ii
         if db_replace(laSAVE,'tc_reftc',laWHERE) == -1
            error_sys('wfmktc('+alltrim(str(procline()))+'): '+db_error())
            WSet('_PROJECT',lcPROJECT)
            return(0)
         endif
      endif
   endif
   db_commit()

   if param_fetch(faPARAM,'FL_NOTIFICA') == 'S'
      laVINCULO := wfgetpersonal()
      if len(laVINCULO) > 0
         lcTBORIGN := db_fetchcolvalue(laVINCULO,'WTABLE_ORIGIN',2)
         laFIELDS  := {'acuser.LOGIN'}
         for ii := 1 to len(laVINCULO[1])
             if at(laVINCULO[1,ii],'NR_CONTROLE WTABLE_ORIGIN WFIELD_WFREL WFIELD_APPREL') == 0 .and. !empty(laVINCULO[2,ii])
                aadd(laFIELDS,lcTBORIGN+'.'+laVINCULO[2,ii])
             endif
         next ii

         if len(laPART) > 0
            if lcTP_TC == 'T'
               lcDT_INI := dtos(param_fetch(faPARAM,'DT_INICIO'))
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := dtos(param_fetch(faPARAM,'DT_PRAZO'))
               lcHR_END := param_fetch(faPARAM,'HR_PRAZO')
            else
               lcDT_INI := dtos(param_fetch(faPARAM,'DT_INICIO'))
               lcHR_INI := param_fetch(faPARAM,'HR_INICIO')
               lcDT_END := dtos(param_fetch(faPARAM,'DT_FIM'))
               lcHR_END := param_fetch(faPARAM,'HR_FIM')
            endif

            lcTITLE := iif(param_pos(faPARAM,'TITULO') > 0,param_fetch(faPARAM,'TITULO'),param_fetch(faPARAM,'TC_CATEGORIA'))

            // Selecionar o Sender --------------------------------------------------------------------------------------------------------
            if !empty(alltrim(WSet('LOGIN')))
               if db_select(laFIELDS,'acuser',;
                            {{2,lcTBORIGN,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WFREL',2)+'='+;
                                          'acuser.'+db_fetchcolvalue(laVINCULO,'WFIELD_APPREL',2)}},;
                            {'acuser.WUID='+alltrim(str(WSet('WUID')))}) == -1
                  error_sys('wfmktc: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laSENDER := db_fetchall()
            else
               laTEMP  := {}
               laTEMP1 := {}
               for ii := 1 to len(laFIELDS)
                   aadd(laTEMP,substr(laFIELDS[ii],at('.',laFIELDS[ii])+1))
                   aadd(laTEMP1,'')
               next
               aadd(laSENDER,laTEMP)  //Nomes dos campos
               aadd(laSENDER,laTEMP1) //Conteúdo dos campos

               lcRETURN_PATH := alltrim(param_fetch(faPARAM,'EMAIL_SENDER'))
               if empty(lcRETURN_PATH)
                  lcRETURN_PATH := 'suporte@inso.com.br'
               endif

               laSENDER[2,ascan(laFIELDS,'acuser.LOGIN')]                                                 := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WUSER',2))]     := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2))]    := 'gr5tasks'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2))]     := lcRETURN_PATH
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2))]       := '0'
               laSENDER[2,ascan(laFIELDS,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2))] := '0'
            endif

            // Tratamento e seleção dos Participantes -------------------------------------------------------------------------------------
            laTEMP := {}
            for ii := 1 to len(laPART)
                if at('@',laPART[ii]) > 0
                   aadd(laEMAILS_DIV,laPART[ii])  // Emails diversos/avulsos
                else
                   aadd(laTEMP,lower(laPART[ii]))        // Logins de usuários
                endif
            next ii
            laPART := aclone(laTEMP)

            if len(laPART) > 0  // Seleciona dados dos destinatários apenas se o usuário os informou
               if db_select(laFIELDS,'acuser',;
                            {{2,lcTBORIGN,lcTBORIGN+'.'+db_fetchcolvalue(laVINCULO,'WFIELD_WFREL',2)+'='+;
                                'acuser.'+db_fetchcolvalue(laVINCULO,'WFIELD_APPREL',2)}},;
                            {'acuser.LOGIN in ('+DLAP+lower(array2str(laPART,DLAP+','+DLAP))+DLAP+')'}) == -1
                  error_sys('wfmktc: ('+alltrim(str(procline()))+') - '+db_error())
               endif
               laSEND_TO := db_fetchall()
            endif

            // Notificação via email para participantes -----------------------------------------------------------------------------------
            if param_fetch(faPARAM,'FL_EMAILPART') == 'S'
               lcMSG := 'Início: '+right(lcDT_INI,2)+'/'+substr(lcDT_INI,5,2)+'/'+left(lcDT_INI,4)+' '+lcHR_INI+CRLF
               if lcTP_TC == 'T'
                  lcMSG += 'Prazo: '
               else
                  lcMSG += 'Término: '
               endif
               lcMSG += right(lcDT_END,2)+'/'+substr(lcDT_END,5,2)+'/'+left(lcDT_END,4)+' '+lcHR_END+CRLF
               lcMSG += param_fetch(faPARAM,'NM_TC')
               if len(laSEND_TO) > 1
                  for ii := 2 to len(laSEND_TO)
                      writelog('Email Interno: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'LOGIN',2),2)+;
                               ' <'+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2)+'>')
                      writelog('Email Interno: To.....: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii))
                      writelog('Email Interno: Subject: '+lcTITLE)
                      writelog('Email Interno: Body...: '+lcMSG)

                      if !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii))
                         wsendmail(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2),;   //Remetente
                                   db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),ii),; //Detinatário
                                   ,;                                                                            //CC
                                   ,;                                                                            //BCC
                                   lcTITLE,;                                                                     //Assunto
                                   lcMSG,;                                                                       //Corpo da mensagem
                                   'Agenda Isj')                                                                 //Nome do remetente
                      else
                         lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui email cadastrado!'
                         puterror(lcMSG_ERRO)
                         writelog(lcMSG_ERRO)
                      endif
                  next ii
               else
                  lcMSG_ERRO := 'Email: Usuários do sistema não encontrados ou não informados'
                  puterror(lcMSG_ERRO)
                  writelog(lcMSG_ERRO)
               endif

               // Envio de avisos aos emails informados diretamente na lista de participantes ------------------------------------------
               if len(laEMAILS_DIV) > 0
                  for ii := 1 to len(laEMAILS_DIV)

                      writelog('Email Externo: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'LOGIN',2),2)+;
                               ' <'+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2)+'>')
                      writelog('Email Externo: To.....: '+laEMAILS_DIV[ii])
                      writelog('Email Externo: Subject: '+lcTITLE)
                      writelog('Email Externo: Body...: '+lcMSG)

                      wsendmail(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2),; //Remetente
                                laEMAILS_DIV[ii],;                                                          //Detinatário
                                ,;                                                                          //CC
                                ,;                                                                          //BCC
                                lcTITLE,;                                                                   //Assunto
                                lcMSG,;                                                                     //Corpo da mensagem
                                'Agenda Isj')                                                               //Nome do remetente

                  next ii
               endif
            endif

            // Notificação via sms para participantes ----------------------------------------------------------------------------------------
            if param_fetch(faPARAM,'FL_SMSPART') == 'S'
               if len(laSEND_TO) > 1
                  lcMSG := right(lcDT_INI,2)+'/'+substr(lcDT_INI,5,2)+'/'+left(lcDT_INI,4)+' '+lcHR_INI+CRLF+;
                           param_fetch(faPARAM,'NM_TC')
                  for ii := 2 to len(laSEND_TO)

                      writelog('SMS: Device.: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii))
                      writelog('SMS: Nr.....: '+db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))
                      writelog('SMS: Subject: '+lcTITLE)
                      writelog('SMS: Body...: '+lcMSG)
                      writelog('SMS: Alias..: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2),2))
                      writelog('SMS: From...: '+db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2))

                      if !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii)) .and.;
                         !empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))

                         lcALIAS := alltrim(db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_WALIAS',2),2))
                         wsendsms(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii),; //Tipo de dispositivo
                                  db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii),;       //Cód do dispositivo
                                  lcTITLE,;                                                                         //Assunto
                                  lcMSG,;                                                                           //Mensagem
                                  'ISJ'+iif(!empty(lcALIAS),'-'+lcALIAS,'ISJ'),;                                    //Apelido do sender
                                  db_fetchcolvalue(laSENDER,db_fetchcolvalue(laVINCULO,'WFIELD_EMAIL',2),2))        //Email do sender
                      else
                         if empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMS',2),ii))           //Sem nr do celular cadastrado
                            lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui SMS cadastrado!'
                            puterror(lcMSG_ERRO)
                            writelog(lcMSG_ERRO)
                         elseif empty(db_fetchcolvalue(laSEND_TO,db_fetchcolvalue(laVINCULO,'WFIELD_SMSDEVICE',2),ii)) //Sem tipo de dispositivo cadastrado
                            lcMSG_ERRO := 'Usuário '+DLMT+lower(db_fetchcolvalue(laSEND_TO,'LOGIN',ii))+DLMT+' não possui tipo de Dispositvo cadastrado!'
                            puterror(lcMSG_ERRO)
                            writelog(lcMSG_ERRO)
                         endif
                      endif
                  next ii
               else
                  lcMSG_ERRO := 'SMS: Usuários do sistema não encontrados ou não informados'
                  puterror(lcMSG_ERRO)
                  writelog(lcMSG_ERRO)
               endif
            endif
         endif
      endif
   endif
   WSet('_PROJECT',lcPROJECT)
return(lnID)


/*
* Glauber 22/02/2016
*
* Function..: prewsendmail(fcREMETENTE,fcDESTINATARIO,fcCC,fcBC,fcASSUNTO,fcCORPO,fcREMETENTE, fcPRECONDICAO)
* Objetivo..: Enviar um email com base em uma pré-condição.
* Parâmetros:
*   fcREMETENTE : Endereço do remetente
*   fcDESTINATARIO : Endereço do destinatário
*   fcCC           : Copia
*   fcBC           : Copia oculta
*   fcASSUNTO      : Assunto
*   fcCORPO        : Corpo do email
*   fcNOMEREM      : Nome do Remetente
*
* Retorno:
*
*
*/
function prewsendmail(fcREMETENTE,fcDESTINATARIO,fcCC,fcBC,fcASSUNTO,fcCORPO,fcNOMEREM, fcPRECONDICAO)

    if (fcCONDICAO != NIL) .and. (fcCONDICAO == .T.)

       wsendmail(fcREMETENTE,;                                  // Remetente
                 fcDESTINATARIO,;                               // Detinatário
                 fcCC,;                                         // CC
                 fcBC,;                                         // BCC
                 fcASSUNTO,;                                    // Assunto
                 fcCORPO,;                                      // Corpo da mensagem
                 iif(Empty(fcNOMEREM),'Agenda Isj',fcNOMEREM))  // Nome do remetente
    endif

return











/*
* Data......: 04/2016 - Glauber
* Function..: amkgedico(fcWTABLE,fcNR_PASTA)
* Objetivo..: Verificar a existencia de configurções GED para uma determinada tabela e criar o link para o ícone do GED nas abas
* Parâmetros:
* fcWTABLE: Nome da tabela
* fcNR_PASTA: Numero da pasta
* Retorno...: Nenhum
*/

Function amkgedico(fcWTABLE,fcPK)
   local lcPARAMS  := '' ,;
         lcHTML    := '' ,;
         lcCONTENT := '' as string

   local laFIELDS := {} ,;
         laRESULT := {} as array

   local ii := 0 as int

   wput('GED_ICO','')

   if valtype(fcWTABLE) == 'U' .or. empty(fcWTABLE)
      puterror('nmkgedico: Tabela não definida')
      return(nil)
   endif

   laFIELDS := {'WTABLE','CD_BUSINESS','WFIELD1','WFIELD2','WFIELD3','WFIELD4','WFIELD5'}
   if db_select(laFIELDS,'gdrelacionamento',,{'WTABLE='+DLAP+fcWTABLE+DLAP}) == -1
      puterror('nmkgedico: ('+alltrim(str(procline()))+') '+db_error())
      return(nil)
   endif
   laRESULT := db_fetchrow()

   if len(laRESULT) > 0
      if !empty(laRESULT[2]) .and. !empty(laRESULT[3])
         lcPARAMS += 'WTABLE='+fcWTABLE
         lcPARAMS += '&CD_BUSINESS='+alltrim(laRESULT[2])
         lcPARAMS += '&TP_PASTA='+alltrim(WGET('TP_PASTA'))
         for ii := 1 to 5
             if !empty(laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))])
                //
                // Glauber 20/05/2016
                //
                // Primeiro tentar resgatar o conteúdo com wget, caso não consiga, tentar resgatar getwput
                //
                lcCONTENT := alltrim(WGET(laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))],'C')) // Recupera dados da UI
                if Empty(lcCONTENT)
                   lcCONTENT := alltrim(getwput(laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))],'C')) // Recupera dados da UI
                endif
                if !empty(lcCONTENT)
                   lcPARAMS += '&WFIELD'+alltrim(str(ii))+'='+lcCONTENT
                else
                   lcPARAMS += '&WFIELD'+alltrim(str(ii))+'=RELATIONEMPTY.'+laRESULT[ascan(laFIELDS,'WFIELD'+alltrim(str(ii)))]
                endif
             endif
         next ii

//      debug2(lcparams,,250)

         lcPARAMS := wic_action('wicaction_workflow/ged.mgr.html')+'?'+lcPARAMS

         lcHTML += '<style>'+CRLF
         lcHTML += '   div.prin {'+CRLF
         lcHTML += '      position: fixed;'+CRLF
         lcHTML += '      border:0px solid #000000;'+CRLF
         lcHTML += '      right: 8px;'+CRLF
         lcHTML += '      z-index: 1000;'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '</style>'+CRLF

         lcHTML += '<style>'+CRLF
         lcHTML += '   div.btged {'+CRLF
         lcHTML += '      cursor:pointer;'+CRLF
         lcHTML += '      background-image:url('+WSet('PATH_COMPONENTS')+'/btged.gif);'+CRLF
         lcHTML += '      background-repeat:none;'+CRLF
         lcHTML += '      border:0px solid #000000;'+CRLF
         lcHTML += '      width:66px;'+CRLF
         lcHTML += '      height:62px;'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '</style>'+CRLF

         lcHTML += '<style>'+CRLF
         lcHTML += '  #divged {'+CRLF
         lcHTML += '     overflow:hidden;'+CRLF
         lcHTML += '     position: fixed;'+CRLF
         lcHTML += '     width: 890px;'+CRLF
         lcHTML += '     height: 500px;'+CRLF
         lcHTML += '     top: 10%;'+CRLF
         lcHTML += '     left: 9%;'+CRLF
         lcHTML += '     background-color: #FFFFFF;'+CRLF
         lcHTML += '     border:1px solid #000000;'+CRLF
         lcHTML += '     visibility:hidden;'+CRLF
         lcHTML += '     z-index: 1000; '+CRLF
         lcHTML += ' }'+CRLF
         lcHTML += '</style>'+CRLF

         lcHTML += '<style>'+CRLF
         lcHTML += '   #totged {'+CRLF
         lcHTML += '      position:fixed;'+CRLF
         lcHTML += '      border:0px solid #000000;'+CRLF
         lcHTML += '      width:33px;'+CRLF
         lcHTML += '      height:20px;'+CRLF
         lcHTML += '      text-align:right;'+CRLF
         lcHTML += '      margin-left: 28px;'+CRLF
         lcHTML += '      margin-top: 40px;'+CRLF
         lcHTML += '      z-index: 1000;'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '</style>'+CRLF

         lcHTML += '<div id="ICOG" class="prin">'+CRLF
         lcHTML += '   <div class="btged" title="Clique aqui caso queira inserir documentos no Ged." onclick="wingedn('+DLAP+'open'+DLAP+')">'+CRLF
         lcHTML += '      <div id="totged"><label>'+totged(fcWTABLE, fcPK)+'</label></div>'+CRLF
         lcHTML += '   </div>'+CRLF

         lcHTML += '</div>'+CRLF

         lcHTML += '<script language="javascript">'+CRLF

         lcHTML += '   /*'+CRLF
         lcHTML += '   * function wingedn()'+CRLF
         lcHTML += '   * Abre iframe com programa de visualização de Documentos'+CRLF
         lcHTML += '   * Parametros:'+CRLF
         lcHTML += '   * wACTION - open | close -> Abre/fecha iframe.'+CRLF
         lcHTML += '   */'+CRLF


         lcHTML += '   function wingedn(wACTION,wURL,objevent) {'+CRLF
         lcHTML += '      if (wACTION == '+DLAP+'open'+DLAP+') {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.visibility = '+DLAP+'visible'+DLAP+';'+CRLF
         lcHTML += '         iframeged.location.href = '+DLAP+lcPARAMS+DLAP+';'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '      else {'+CRLF
         lcHTML += '         document.getElementById('+DLAP+'divged'+DLAP+').style.visibility = '+DLAP+'hidden'+DLAP+';'+CRLF
         lcHTML += '         iframeged.location.href = '+DLAP+'about:blank'+DLAP+';'+CRLF
         lcHTML += '      }'+CRLF
         lcHTML += '   }'+CRLF
         lcHTML += '</script>'+CRLF



      endif
      wput('GED_ICO',lcHTML) // Tag localizada na UI da aplicação - mnt.pasta.html
   endif
return(nil)

*****************************************
static function totged(fcTABLE, fcPK)
*****************************************
local laRESULT:={} as array

if db_select({'count(*)'},'ged',,{'wtable=' +DLAP + fcTABLE + DLAP ,'REFERENCIA1='+fcPK}) == -1
   error_sys(db_error())
endif
laRESULT := db_fetchrow()

return(alltrim(str(laRESULT[1])))






/*
* Data......: 06/2016 - Glauber
* Function..: AssDoc(pNrPasta, pTpPasta, pCdBusiness, pTpAndamentoAssinatura, pTpDocumentoOrigem, pTpNovoDocumento, pGdKeyWord, pGdComment, pTpNovoAndamento, pCorpoNovoAndamento)
* Objetivo..: Executa a chamada para rotina de assinatura automática de documentos
* Parâmetros:
*    pNrPasta...................: Número da pasta
*    pTpPasta...................: Tipo da pasta
*    pCdBusiness................: Código de negócio ged
*    pTpAndamentoAssinatura.....: Tipo de Andamento Assinatura
*    pTpDocumentoOrigem.........: Tipo de Documento Origem
*    pTpNovoDocumento...........: Tipo Documento para Novo Documento
*    pGdKeyWord.................: Palavra Chave Novo Documento
*    pGdComment.................: Comentário do Novo Documento
*    pTpNovoAndamento...........: Tipo Andamento Novo Andamento
*    pCorpoNovoAndamento........: Corpo do novo andamento
*
* Retorno...: Nenhum
*
*/

Function AssDoc(pNrPasta, pTpPasta, pCdBusiness, pTpAndamentoAssinatura, pTpDocumentoOrigem, pTpNovoDocumento, pGdKeyWord, pGdComment, pTpNovoAndamento, pCorpoNovoAndamento)

    local objAssinatura := AssinarDocumentoNew()

          objAssinatura:NrPasta                  := iif(ValType(pNrPasta) == "C", Val(pNrPasta), pNrPasta)
          objAssinatura:TpPasta                  := pTpPasta
          objAssinatura:CdBusiness               := pCdBusiness
          objAssinatura:TpAndamentoAssinatura    := pTpAndamentoAssinatura
          objAssinatura:TpDocumentoOrigem        := pTpDocumentoOrigem
          objAssinatura:TpNovoDocumento          := pTpNovoDocumento
          objAssinatura:GdKeyWord                := pGdKeyWord
          objAssinatura:GdComment                := pGdComment
          objAssinatura:TpNovoAndamento          := pTpNovoAndamento
          objAssinatura:CorpoNovoAndamento       := pCorpoNovoAndamento

          objAssinatura:Execute()
//wout('<br><b>Codigo de erro:'+transform(objAssinatura:CodErro))
//wout('<br><b>Descricao de erro:'+transform(objAssinatura:DescErro))
          if (objAssinatura:CodErro != 0)
             Wset('_lastsql','********************************************************************************************************************************')
             Wset('_lastsql','*                      E R R O  A O  P R O C E S S A R  A S S I N A T U R A   D E  D O C U M E N T O S                         *')
             Wset('_lastsql','********************************************************************************************************************************')
             Wset('_lastsql','* Código do Erro...: ' + AllTrim(objAssinatura:CodErro))
             Wset('_lastsql','* Descrição do Erro: ' + AllTrim(objAssinatura:DescErro))
             Wset('_lastsql','*                                                                                                                              *')
             Wset('_lastsql','*                                                                                                                              *')
             Wset('_lastsql','********************************************************************************************************************************')
          endif

return


**************************************************************
function cargawbox(fcTABLE,faFIELDS,faORDER,fcDESTINO,fcWHERE)
**************************************************************
*** rufino 30/07/2015 16:28:03   / sonia 12/07/2017 10:09:26
*** cargacbox('indice_reajuste',{'CD_INDICE','NM_INDICE'},{'CD_INDICE'},'NM_INDICE')


local lcWHERE:=''
local laRES:={}
local laLST_NOVA:={}
local laVINCULADO:={}

local paAUTO     :={} as array



local  laOPT    := {} ,;
       laOPTV   := {} ,;
       laPUT    := {} ,;
       laDEF    := {} ,;
       laDEFV   := {} ,;
       laATI    := {} ,;
       laATIV   := {} ,;
       laINA    := {} ,;
       laINAV   := {} ,;
       laPUTV   := {} ,;
       laFIELD  := {} as array


local  jj    := 1  ,;
       liPOS := 0  as int


laDEF := {}
laDEFV:= {}

laATI := {}
laATIV:= {}

laINA := {}
laINAV:= {}

laPUT := {}
laPUTV:= {}

laFIELD := structtable(WSet("DB_ACTIVE"),fcTABLE,1,'A')
liPOS   := ascan(laFIELD,'FL_ATIVO')

if liPOS<>0
   aadd(faFIELDS,'FL_ATIVO')
endif

laFIELD:=faFIELDS

if db_select(laFIELD,fcTABLE,,fcWHERE,faORDER) == -1
   error_sys(db_error())
endif
laRES := db_fetchall()


if liPOS<>0 .and. len(laFIELD)==3
*** codigo,descrição,ativo

for jj := 2 to len(laRES)
    if liPOS<>0
       if laRES[jj,3] == 'D'
          aadd(laDEF,laRES[jj,2])
          aadd(laDEFV,laRES[jj,1])

        elseif laRES[jj,3] == 'I'
          aadd(laINA,laRES[jj,2])
          aadd(laINAV,laRES[jj,1])

        else
          aadd(laATI,laRES[jj,2])
          aadd(laATIV,laRES[jj,1])
       endif
    else
       aadd(laATI,laRES[jj,2])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if liPOS<>0 .and. len(laFIELD)==2
***descricao,ativo

for jj := 2 to len(laRES)
    if liPOS<>0
       if laRES[jj,2] == 'D'
          aadd(laDEF,laRES[jj,1])
          aadd(laDEFV,laRES[jj,1])

        elseif laRES[jj,2] == 'I'
          aadd(laINA,laRES[jj,1])
          aadd(laINAV,laRES[jj,1])

        else
          aadd(laATI,laRES[jj,1])
          aadd(laATIV,laRES[jj,1])
       endif
    else
       aadd(laATI,laRES[jj,1])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif


if liPOS==0 .and. len(laFIELD)==2
*** codigo,descrição

for jj := 2 to len(laRES)
    if liPOS<>0
       aadd(laATI,laRES[jj,2])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if liPOS==0 .and. len(laFIELD)==1
***descricao

for jj := 2 to len(laRES)
    if liPOS<>0
       aadd(laATI,laRES[jj,1])
       aadd(laATIV,laRES[jj,1])
    endif
next jj

endif

if len(laDEF) == 0
   aadd(laDEF,'') // Adiciona uma linha vazia no inicio do combo, caso seja solicitado
   aadd(laDEFV,'')
endif

for jj=1 to len(laDEF)
    aadd(laPUT,laDEF[jj])
    aadd(laPUTV,laDEFV[jj])
next jj

for jj=1 to len(laATI)
    aadd(laPUT,laATI[jj])
    aadd(laPUTV,laATIV[jj])
next jj

for jj=1 to len(laINA)
    aadd(laPUT,'INATIVO - '+laINA[jj])
    aadd(laPUTV,laINAV[jj])
next jj

WPut(fcDESTINO+'.option',laPUT)
WPut(fcDESTINO+'.optionvalue',laPUTV)

return(nil)
